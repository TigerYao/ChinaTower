import React, { cloneElement, Component } from 'react';
import PropTypes from 'prop-types';
import { StyleSheet, css } from 'aphrodite/no-important';
import BigScreen from 'isomorphic-bigscreen';
import { EVENTS, createMessageHelper, ACTIONS } from 'griffith-message';
import { ua, reduce, sequence, isMSESupported, isHlsNativeSupported, logger } from 'griffith-utils';
import { parse } from 'query-string';
import noop from 'lodash/noop';
import EventEmitter from 'eventemitter3';
import elementResizeEvent from 'element-resize-event';
import debounce from 'lodash/debounce';
import clamp from 'lodash/clamp';
import memoize from 'lodash/memoize';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// https://github.com/zloirock/core-js/issues/280
function pad(number) {
  let result = String(number);

  if (result.length < 2) {
    result = '0' + result;
  }

  return result;
}

function formatTime(time) {
  if (!Number.isFinite(time)) return '';
  time = Math.floor(time);
  const seconds = time % 60;
  const minutes = Math.floor(time / 60);
  return `${pad(minutes)}:${pad(seconds)}`;
}

class Time extends React.Component {
  render() {
    const {
      value
    } = this.props;
    return React.createElement("span", null, formatTime(value));
  }

}

_defineProperty(Time, "propTypes", {
  value: PropTypes.number
});

_defineProperty(Time, "defaultProps", {
  value: 0
});

var styles = StyleSheet.create({
  root: {
    display: 'inline-block',
    width: '1.5em',
    height: '1.5em'
  },
  svg: {
    display: 'block',
    width: '100%',
    height: '100%',
    fill: 'currentColor'
  }
});

function Icon({
  icon,
  styles: customStyles
}) {
  const children = cloneElement(icon, {
    className: css(styles.svg)
  });
  return React.createElement("span", {
    className: css(styles.root, customStyles)
  }, children);
}

Icon.propTypes = {
  icon: PropTypes.element.isRequired
};

var alert = React.createElement("svg", {
  viewBox: "0 0 20 20"
}, React.createElement("path", {
  d: "M10 0C4.477 0 0 4.477 0 10s4.477 10 10 10 10-4.477 10-10S15.523 0 10 0zm-.034 2.966c1.95 0 1.485 1.807 1.485 2.21 0 .116-.784 7.79-.784 7.79h-1.4S8.48 5.344 8.48 5.23c0-.417-.462-2.264 1.486-2.264zm1.057 13.522c-.294.287-.647.43-1.056.43-.41 0-.762-.142-1.058-.43-.296-.286-.444-.643-.444-1.07 0-.41.148-.762.443-1.057.294-.294.647-.44 1.057-.44.41 0 .762.142 1.056.43.296.286.443.643.443 1.07 0 .426-.147.782-.443 1.068z"
}));

var pause = React.createElement("svg", {
  viewBox: "0 0 72 72"
}, React.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, React.createElement("circle", {
  cx: "36",
  cy: "36",
  r: "36",
  fill: "#FFF",
  fillOpacity: ".95"
}), React.createElement("path", {
  fill: "#444",
  fillRule: "nonzero",
  d: "M41.143 22.5h5.786v27h-5.786zM25.071 22.5h5.786v27h-5.786z"
})));

var play = React.createElement("svg", {
  viewBox: "0 0 72 72"
}, React.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, React.createElement("circle", {
  cx: "36",
  cy: "36",
  r: "36",
  fill: "#FFF",
  fillOpacity: ".95"
}), React.createElement("path", {
  fill: "#444",
  fillRule: "nonzero",
  d: "M50.8350169,37.0602664 L29.4767217,49.9693832 C28.900608,50.3175908 28.1558807,50.1251285 27.8133266,49.5395068 C27.701749,49.3487566 27.6428571,49.1309436 27.6428571,48.9090213 L27.6428571,23.0907876 C27.6428571,22.4094644 28.1862113,21.8571429 28.8564727,21.8571429 C29.0747919,21.8571429 29.2890685,21.9170066 29.4767217,22.0304257 L50.8350169,34.9395425 C51.4111306,35.28775 51.6004681,36.0447682 51.257914,36.6303899 C51.154433,36.8072984 51.0090531,36.9550776 50.8350169,37.0602664 Z"
})));

var replay = React.createElement("svg", {
  viewBox: "0 0 24 24"
}, React.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, React.createElement("rect", {
  width: "24",
  height: "24"
}), React.createElement("path", {
  fill: "#FFF",
  d: "M12.4049973,3.62840003 C17.1876069,3.84468032 21,7.87252205 21,12.8096305 C21,17.8853314 16.9705627,22 12,22 C7.02943725,22 3,17.8853314 3,12.8096305 C3,12.0229797 3.624497,11.3852732 4.39485308,11.3852732 C5.16520917,11.3852732 5.78970616,12.0229797 5.78970616,12.8096305 C5.78970616,16.3120298 8.57014942,19.1512855 12,19.1512855 C15.4298506,19.1512855 18.2102938,16.3120298 18.2102938,12.8096305 C18.2102938,9.44617464 15.6460805,6.69429107 12.4049973,6.4812447 L12.4049973,8.30324795 C12.4049973,8.71101381 12.0954942,9.04157334 11.7137028,9.04157334 C11.5841406,9.04157334 11.457186,9.00268616 11.3473174,8.92934663 L6.42999892,5.64693477 C6.10624047,5.4308193 6.00781868,4.97530916 6.21016772,4.62952441 C6.26580359,4.53445089 6.34098153,4.45415835 6.42999892,4.3947374 L11.3473174,1.11232554 C11.6710759,0.896210069 12.0975703,1.00132779 12.2999193,1.34711255 C12.3685872,1.46445578 12.4049973,1.60004749 12.4049973,1.73842422 L12.4049973,3.62840003 Z"
})));

const SIZE = 64;
const BORDER = 3;
const RADIUS = (SIZE - BORDER) / 2;
const PERIMETER = 2 * Math.PI * RADIUS;
const animation = {
  '0%': {
    transform: 'rotate(0deg)'
  },
  '100%': {
    transform: 'rotate(360deg)'
  }
};
const circleAnimation = {
  '0%': {
    strokeDashoffset: PERIMETER,
    transform: 'rotate(0deg)'
  },
  '50%': {
    strokeDashoffset: PERIMETER / 4,
    transform: 'rotate(90deg)'
  },
  '100%': {
    strokeDashoffset: PERIMETER,
    transform: 'rotate(360deg)'
  }
};
var styles$1 = StyleSheet.create({
  root: {
    width: '4em',
    height: '4em'
  },
  svg: {
    display: 'block',
    width: '100%',
    height: '100%',
    animationName: animation,
    animationDuration: '2s',
    animationIterationCount: 'infinite',
    animationTimingFunction: 'linear'
  },
  circle: {
    cx: '50%',
    cy: '50%',
    r: RADIUS,
    strokeDasharray: PERIMETER,
    stroke: 'currentColor',
    strokeWidth: BORDER,
    strokeLinecap: 'round',
    fill: 'none',
    transformOrigin: 'center',
    animationName: circleAnimation,
    animationDuration: '1.5s',
    animationIterationCount: 'infinite',
    animationTimingFunction: 'ease-in-out'
  }
});

class Loader extends Component {
  render() {
    return React.createElement("div", {
      className: css(styles$1.root)
    }, React.createElement("svg", {
      viewBox: "0 0 64 64",
      className: css(styles$1.svg)
    }, React.createElement("circle", {
      className: css(styles$1.circle)
    })));
  }

}

const VideoSourceContext = React.createContext({});
VideoSourceContext.displayName = 'VideoSourceContext';

const QUALITY_ORDER = ['ld', 'sd', 'hd'];
const getQualities = (sources, isMobile) => {
  const qualities = Object.keys(sources).sort((a, b) => QUALITY_ORDER.indexOf(a) - QUALITY_ORDER.indexOf(b));

  if (qualities.length > 1) {
    if (isMobile) {
      // 移动端只返回最低清晰度
      return qualities.slice(0, 1);
    } else {
      // 桌面端端去掉低清，除非只有一个低清
      return qualities.filter(item => item !== 'ld');
    }
  }

  return qualities;
};
const getSources = (qualities, sources) => qualities.map(quality => {
  const {
    play_url,
    ...rest
  } = sources[quality];
  return { ...rest,
    source: play_url,
    quality
  };
});

const {
  isMobile
} = ua;
class VideoSourceProvider extends React.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      qualities: [],
      currentQuality: null,
      format: null,
      sources: [],
      expiration: 0,
      dataKey: null
    });

    _defineProperty(this, "setCurrentQuality", quality => {
      const prevQuality = this.state.currentQuality;

      if (prevQuality !== quality) {
        this.setState({
          currentQuality: quality
        });
        this.props.onEvent(EVENTS.PLAYER.QUALITY_CHANGE, {
          prevQuality,
          quality
        });
      }
    });

    _defineProperty(this, "getCurrentSrc", () => {
      const {
        currentQuality,
        sources
      } = this.state;

      if (sources.length === 0) {
        return;
      }

      const source = sources.find(item => item.quality === currentQuality) || sources[0];
      return source.source;
    });
  }

  render() {
    const {
      qualities,
      currentQuality,
      format,
      dataKey,
      sources
    } = this.state;
    return React.createElement(VideoSourceContext.Provider, {
      value: {
        dataKey,
        qualities,
        format,
        sources,
        currentQuality,
        currentSrc: this.getCurrentSrc(),
        setCurrentQuality: this.setCurrentQuality
      }
    }, this.props.children);
  }

}

_defineProperty(VideoSourceProvider, "propTypes", {
  onEvent: PropTypes.func.isRequired,
  sources: PropTypes.object,
  id: PropTypes.string.isRequired
});

_defineProperty(VideoSourceProvider, "getDerivedStateFromProps", ({
  sources: videoSources,
  id
}, state) => {
  if (!videoSources) return null;
  const {
    format,
    play_url
  } = Object.values(videoSources)[0];
  const {
    expiration
  } = parse(play_url);
  const dataKey = `${id}-${expiration}`; // expiration 和 id 组合可以唯一标识一次请求的数据

  if (dataKey == state.dataKey) return null;
  const qualities = getQualities(videoSources, isMobile);
  const sources = getSources(qualities, videoSources);

  if (!isMobile && format === 'm3u8') {
    qualities.unshift('auto');
  }

  const currentQuality = state.currentQuality || qualities[0];
  return {
    currentQuality,
    qualities,
    sources,
    format,
    expiration: Number(expiration),
    dataKey
  };
});

const EVENT_TYPE = 'event';
const ACTION_TYPE = 'action';
/**
 * 用于播放器内部，只能接收外界传入的 Action，向外界发出 Event
 */

const InternalContext = React.createContext({});
InternalContext.displayName = 'InternalMessageContext';
/**
 * 用于播放器外部，只能接收播放器发出的 Event, 或者向播放器发送 Action
 */

const ExternalContext = React.createContext({});
ExternalContext.displayName = 'ExternalMessageContext';
class MessageProvider extends React.PureComponent {
  constructor(props) {
    super(props);

    _defineProperty(this, "emitEvent", (eventName, data) => {
      this.emitter.emit(eventName, {
        __type__: EVENT_TYPE,
        data
      });

      if (this.props.enableCrossWindow) {
        this.dispatchCrossWindowMessage(window.parent, eventName, data);
      }
    });

    _defineProperty(this, "subscribeEvent", (eventName, listener) => {
      const realLisener = ({
        __type__,
        data
      } = {}) => {
        if (__type__ === EVENT_TYPE) {
          listener(data);
        }
      };

      this.emitter.on(eventName, realLisener);
      return {
        unsubscribe: () => this.emitter.off(eventName, realLisener)
      };
    });

    _defineProperty(this, "dispatchAction", (actionName, data) => {
      this.emitter.emit(actionName, {
        __type__: ACTION_TYPE,
        data
      });
    });

    _defineProperty(this, "subscribeAction", (eventName, listener) => {
      const realLisener = ({
        __type__,
        data
      }) => {
        if (__type__ === ACTION_TYPE) {
          listener(data);
        }
      };

      this.emitter.on(eventName, realLisener);
      return {
        unsubscribe: () => this.emitter.off(eventName, realLisener)
      };
    });

    this.emitter = new EventEmitter();
    const {
      id,
      targetOrigin
    } = this.props;
    const {
      subscribeMessage,
      dispatchMessage
    } = createMessageHelper(id, targetOrigin);
    this.subscribeCrossWindowMessage = subscribeMessage;
    this.dispatchCrossWindowMessage = dispatchMessage;
  }

  componentDidMount() {
    if (this.props.enableCrossWindow) {
      this.crossWindowMessageSubscription = this.subscribeCrossWindowMessage(this.dispatchAction);
    }
  }

  componentWillUnmount() {
    if (this.crossWindowEventSubscription) {
      this.crossWindowEventSubscription.unsubscribe();
    }
  }

  render() {
    return React.createElement(InternalContext.Provider, {
      value: {
        emitEvent: this.emitEvent,
        subscribeAction: this.subscribeAction
      }
    }, React.createElement(ExternalContext.Provider, {
      value: {
        dispatchAction: this.dispatchAction,
        subscribeEvent: this.subscribeEvent
      }
    }, this.props.children));
  }

}

_defineProperty(MessageProvider, "propsTypes", {
  id: PropTypes.string.isRequired,
  enableCrossWindow: PropTypes.bool,
  targetOrigin: PropTypes.string.isRequired
});

_defineProperty(MessageProvider, "defaultProps", {
  targetOrigin: '*'
});

const ObjectFitContext = React.createContext({});
ObjectFitContext.displayName = 'ObjectFitContext';

const VALID_FIT = ['fill', 'contain', 'cover', 'none', 'scale-down'];
class ObjectFitProvider extends React.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      objectFit: this.props.initialObjectFit
    });

    _defineProperty(this, "setObjectFit", objectFit => {
      if (VALID_FIT.includes(objectFit) && this.state.objectFit !== objectFit) {
        this.setState({
          objectFit
        });
      }
    });
  }

  componentDidUpdate(prevProps) {
    const {
      initialObjectFit
    } = this.props;

    if (initialObjectFit !== prevProps.initialObjectFit) {
      this.setObjectFit(initialObjectFit);
    }
  }

  render() {
    const {
      objectFit
    } = this.state;
    return React.createElement(ObjectFitContext.Provider, {
      value: {
        objectFit,
        setObjectFit: this.setObjectFit
      }
    }, this.props.children);
  }

}

_defineProperty(ObjectFitProvider, "propTypes", {
  initialObjectFit: PropTypes.oneOf(VALID_FIT).isRequired
});

_defineProperty(ObjectFitProvider, "defaultProps", {
  initialObjectFit: 'contain'
});

const PositionContext = React.createContext({
  isFullWidth: false
});
PositionContext.displayName = 'PositionContext';

var styles$2 = StyleSheet.create({
  root: {
    position: 'relative',
    width: '100%',
    height: '100%'
  }
});

class PositionProvider extends React.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      videoWidth: 0,
      videoHeight: 0,
      isFullWidth: false,
      helperImageSrc: null
    });

    _defineProperty(this, "ref", React.createRef());

    _defineProperty(this, "startObservingResize", () => {
      const root = this.ref.current;

      if (root) {
        elementResizeEvent(root, this.updateIsFullWidth);
      }
    });

    _defineProperty(this, "updateHelperImageSrc", () => {
      const {
        videoWidth,
        videoHeight
      } = this.state;

      if (!videoWidth || !videoHeight) {
        return;
      }

      const [width, height] = reduce(videoWidth, videoHeight);
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const helperImageSrc = canvas.toDataURL();
      this.setState({
        helperImageSrc
      });
    });

    _defineProperty(this, "updateIsFullWidth", () => {
      const {
        videoWidth,
        videoHeight
      } = this.state;

      if (!videoWidth || !videoHeight) {
        return;
      }

      const root = this.ref.current;
      if (!root) return;
      const {
        width,
        height
      } = root.getBoundingClientRect(); // 因为视频缩放后，长宽可能不严格相等，所以认为差值小于等于 0.01 的就算相等。
      // 比如 1280x720 (1.777777778) 和 848x478 (1.774058577)，认为相等。

      const isFullWidth = width / height - videoWidth / videoHeight <= 0.01;

      if (isFullWidth !== this.state.isFullWidth) {
        this.setState({
          isFullWidth
        });
      }
    });

    _defineProperty(this, "triggerUpdateIsFullWidth", () => requestAnimationFrame(this.updateIsFullWidth));

    _defineProperty(this, "updateVideoSize", ({
      videoWidth,
      videoHeight
    }) => {
      this.setState({
        videoWidth,
        videoHeight
      });
    });
  }

  componentDidMount() {
    if (this.props.shouldObserveResize) {
      this.startObservingResize();
    }

    this.triggerUpdateIsFullWidth();
    this.updateHelperImageSrc();
  }

  componentDidUpdate(prevProps, prevState) {
    const {
      shouldObserveResize: prevShouldObserve
    } = prevProps;
    const {
      videoWidth: prevWidth,
      videoHeight: prevHeight
    } = prevState;
    const {
      shouldObserveResize
    } = this.props;
    const {
      videoWidth,
      videoHeight
    } = this.state;

    if (prevWidth !== videoWidth || prevHeight !== videoHeight) {
      this.triggerUpdateIsFullWidth();
      this.updateHelperImageSrc();
    }

    if (!prevShouldObserve && shouldObserveResize) {
      this.startObservingResize();
    }

    if (prevShouldObserve && !shouldObserveResize) {
      this.stopObservingResize();
    }
  }

  componentWillUnmount() {
    this.stopObservingResize();
  }

  stopObservingResize() {
    const root = this.ref.current;

    if (root) {
      elementResizeEvent.unbind(root);
    }
  }

  render() {
    const {
      children
    } = this.props;
    const {
      isFullWidth,
      helperImageSrc
    } = this.state;
    return React.createElement(PositionContext.Provider, {
      value: {
        isFullWidth,
        helperImageSrc,
        updateVideoSize: this.updateVideoSize
      }
    }, React.createElement("div", {
      className: css(styles$2.root),
      ref: this.ref
    }, children));
  }

}

_defineProperty(PositionProvider, "propTypes", {
  shouldObserveResize: PropTypes.bool
});

const eventMap = [[EVENTS.DOM.PLAY, 'onPlay'], [EVENTS.DOM.PLAYING, 'onPlaying'], [EVENTS.DOM.PAUSE, 'onPause'], [EVENTS.DOM.ENDED, 'onEnded'], [EVENTS.DOM.TIMEUPDATE, 'onTimeUpdate'], [EVENTS.DOM.ERROR, 'onError'], [EVENTS.DOM.WAITING, 'onWaiting']];

function serializeDOMException(exception) {
  if (!exception) return null;
  const {
    code,
    messge,
    name
  } = exception;
  return {
    code,
    messge,
    name
  };
}

function getMediaEventPayload(event) {
  const {
    currentTime,
    duration,
    error
  } = event.currentTarget;
  return {
    currentTime,
    duration,
    error: serializeDOMException(error)
  };
}

const VideoWithMessage = React.forwardRef((props, ref) => {
  const renderChildren = (emitEvent, objectFit, updateVideoSize) => {
    const newProps = {};
    eventMap.map(([eventName, key]) => {
      const handler = props[key];

      const emit = event => emitEvent(eventName, getMediaEventPayload(event));

      newProps[key] = sequence(emit, handler || noop);
    });

    const updateVideoSizeOnLoadedMetadata = event => {
      const videoNode = event.currentTarget;

      if (videoNode) {
        const {
          videoWidth,
          videoHeight
        } = videoNode;
        updateVideoSize({
          videoWidth,
          videoHeight
        });
      }
    };

    const newOnLoadedMetadata = sequence(updateVideoSizeOnLoadedMetadata, props.onLoadedMetadata || noop);
    const {
      Video,
      ...otherProps
    } = props;
    return React.createElement(Video, _extends({}, otherProps, newProps, {
      ref: ref,
      style: {
        objectFit
      },
      onLoadedMetadata: newOnLoadedMetadata
    }));
  };

  return React.createElement(PositionContext.Consumer, null, ({
    updateVideoSize
  }) => React.createElement(ObjectFitContext.Consumer, null, ({
    objectFit
  }) => React.createElement(InternalContext.Consumer, null, ({
    emitEvent
  }) => renderChildren(emitEvent, objectFit, updateVideoSize))));
});

const NormalVideo = ({
  onRef,
  paused,
  currentQuality,
  sources,
  ...props
}) => React.createElement("video", _extends({}, props, {
  ref: onRef
}));

var NormalVideo$1 = {
  pluginName: 'native',
  VideoComponent: NormalVideo
};

/* global __WITHOUT_HLSJS__:false, __WITHOUT_MP4__:false */

function selectVideo(format, useMSE) {
  if (format === 'm3u8') {
    if (typeof __WITHOUT_HLSJS__ === 'undefined' ? false : __WITHOUT_HLSJS__) {
      return NormalVideo$1;
    } else if (isMSESupported() && !isHlsNativeSupported()) {
      return require('griffith-hls').default;
    }
  }

  if (format === 'mp4') {
    if (typeof __WITHOUT_MP4__ === 'undefined' ? false : __WITHOUT_MP4__) {
      return NormalVideo$1;
    } else if (isMSESupported() && useMSE) {
      return require('griffith-mp4').default;
    }
  }

  return NormalVideo$1;
}

var styles$3 = StyleSheet.create({
  root: {
    display: 'block',
    width: '100%',
    height: '100%'
  }
});

const {
  isMobile: isMobile$1
} = ua;

const isAbortError = error => error && error.name === 'AbortError' || error instanceof MediaError && error.code === MediaError.MEDIA_ERR_ABORTED;

const isNotAllowedError = error => error && error.name === 'NotAllowedError';

class Video extends Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "isMetadataLoaded", false);

    _defineProperty(this, "pendingAction", null);

    _defineProperty(this, "loading", false);

    _defineProperty(this, "root", null);

    _defineProperty(this, "safeExecute", fn => {
      if (this.playPromise !== undefined) {
        this.playPromise.then(() => {
          fn();
        });
      } else {
        fn();
      }
    });

    _defineProperty(this, "handleMetadataLoaded", () => {
      this.isMetadataLoaded = true;
      this.applyPendingAction();
    });

    _defineProperty(this, "handleError", () => {
      const {
        onError
      } = this.props;

      if (onError) {
        onError(this.root.error);
      }
    });

    _defineProperty(this, "handleDurationChange", () => {
      const {
        onDurationChange
      } = this.props;

      if (onDurationChange) {
        onDurationChange(this.root.duration);
      }
    });

    _defineProperty(this, "handleWaiting", () => {
      if (!this.loading) {
        this.loading = true;
      }

      this.props.onWaiting();
    });

    _defineProperty(this, "handlePlaying", () => {
      if (this.loading) {
        this.loading = false;
      }

      this.props.onPlaying();
    });

    _defineProperty(this, "handleTimeUpdate", arg => {
      const {
        onTimeUpdate,
        paused
      } = this.props;
      this.disposeTimer();

      if (paused || this.loading) {
        return;
      }

      const {
        currentTime
      } = this.root || {};

      if (onTimeUpdate && currentTime) {
        const isRaf = typeof arg === 'number'; // raf 调用 arg 是 时间戳，事件监听调用 arg 是 event

        onTimeUpdate(currentTime, isRaf);

        if (!isMobile$1) {
          // 移动端使用原生进度条，不需要频繁更新，减少性能压力
          this._playTimer = window.requestAnimationFrame(this.handleTimeUpdate);
        }
      }
    });

    _defineProperty(this, "handleProgress", () => {
      const {
        onProgress
      } = this.props;
      const buffered = this.root.buffered;
      const result = [];

      for (let i = 0; i < buffered.length; i++) {
        result.push({
          start: buffered.start(i),
          end: buffered.end(i)
        });
      }

      if (onProgress) {
        onProgress(result);
      }
    });

    _defineProperty(this, "handleError", () => {
      const {
        error,
        currentTime
      } = this.root || {};

      if (!error) {
        return;
      }

      const {
        code,
        message,
        name
      } = error;
      logger.debug('Error: %o', {
        code,
        message,
        name
      });
      const dontReportPlayFailed = isNotAllowedError(error) || isAbortError(error); // 这两种错误不认为是播放失败

      if (!dontReportPlayFailed) {
        this.props.onEvent(EVENTS.PLAYER.PLAY_FAILED, {
          currentTime
        });
      }

      this.props.onError(error);
    });
  }

  componentDidMount() {
    this.root.volume = this.props.volume ** 2;
  }

  getSnapshotBeforeUpdate() {
    return {
      paused: this.root.paused,
      currentTime: this.root.currentTime
    };
  }

  componentDidUpdate(prevProps, prevState, snapshot) {
    const {
      src,
      paused,
      volume,
      format,
      useMSE
    } = this.props;
    /**
     * 切换清晰度，如果是非 mse 视频（src 是 blob 类型）
     * data 变化的时候会 remount，所以 componentDidUpdate 中 src 变化一定是清晰度变了
     */

    if (prevProps.src && src !== prevProps.src) {
      const {
        willHandleSrcChange
      } = selectVideo(format, useMSE); // TODO 这一块逻辑需要 Video 自己处理

      if (!willHandleSrcChange) {
        this.safeExecute(() => {
          this.isMetadataLoaded = false;
          this.seek(snapshot.currentTime);

          if (!snapshot.paused) {
            this.play();
          }
        });
      }
    }

    if (paused !== prevProps.paused && paused !== this.root.paused) {
      if (paused) {
        this.pause();
      } else {
        this.play();
      }
    }

    if (this.root.volume !== volume ** 2 && !isMobile$1) {
      this.root.volume = volume ** 2;
    }
  }

  pending(action) {
    this.pendingAction = { ...this.pendingAction,
      ...action
    };
  }

  applyPendingAction() {
    if (!this.pendingAction) {
      return;
    }

    const action = this.pendingAction;
    this.pendingAction = null;

    if (action.currentTime !== undefined) {
      this.seek(action.currentTime);
    }

    if (action.paused !== undefined && action.paused !== this.root.paused) {
      if (action.paused) {
        this.pause();
      } else {
        this.play();
      }
    }
  }
  /**
   * @see https://developers.google.com/web/updates/2017/06/play-request-was-interrupted
   */


  play() {
    if (!isMobile$1 && !this.isMetadataLoaded) {
      this.pending({
        paused: false
      });

      if (this.root.load) {
        // workaround for some devices that not support preload="metadata"
        this.safeExecute(() => this.root.load());
      }

      return;
    }

    this.playPromise = Promise.resolve(this.root.play()) // 保证是 promise
    .catch(error => {
      const {
        onError
      } = this.props;

      if (onError) {
        onError(error);
      }
    });
  }

  pause() {
    if (!isMobile$1 && !this.isMetadataLoaded) {
      this.pending({
        paused: true
      });
      return;
    }

    this.safeExecute(() => this.root.pause());
  }

  seek(currentTime) {
    if (!Number.isFinite(currentTime)) return;

    if (!this.isMetadataLoaded) {
      this.pending({
        currentTime
      });
      return;
    } // see https://stackoverflow.com/a/23353005


    if (this.root.duration) {
      this.root.currentTime = currentTime;
    }
  }

  disposeTimer() {
    window.cancelAnimationFrame(this._playTimer);
  }

  render() {
    const {
      src,
      controls,
      paused,
      volume,
      onPlay,
      onPause,
      onEnded,
      onLoadedData,
      onSeeking,
      onSeeked,
      format,
      useMSE,
      sources,
      currentQuality
    } = this.props;
    const {
      VideoComponent
    } = selectVideo(format, useMSE);
    return React.createElement(VideoWithMessage, {
      onRef: node => {
        this.root = node;
      },
      className: css(styles$3.root),
      preload: "metadata",
      playsInline: true,
      "webkit-playsinline": "",
      "x-webkit-airplay": "deny",
      muted: !volume,
      controls: controls,
      src: src,
      onPlay: onPlay,
      onPause: onPause,
      onEnded: onEnded,
      onLoadedData: onLoadedData,
      onSeeking: onSeeking,
      onSeeked: onSeeked,
      onClick: this.handleClick,
      onLoadedMetadata: this.handleMetadataLoaded,
      onError: this.handleError,
      onDurationChange: this.handleDurationChange,
      onTimeUpdate: this.handleTimeUpdate,
      onProgress: this.handleProgress,
      onWaiting: this.handleWaiting,
      onPlaying: this.handlePlaying,
      paused: paused,
      sources: sources,
      currentQuality: currentQuality,
      Video: VideoComponent
    });
  }

}

_defineProperty(Video, "propTypes", {
  controls: PropTypes.bool,
  paused: PropTypes.bool,
  volume: PropTypes.number,
  onPlay: PropTypes.func,
  onPause: PropTypes.func,
  onEnded: PropTypes.func,
  onLoadedData: PropTypes.func,
  onDurationChange: PropTypes.func,
  onTimeUpdate: PropTypes.func,
  onWaiting: PropTypes.func,
  onPlaying: PropTypes.func,
  onSeeking: PropTypes.func,
  onSeeked: PropTypes.func,
  onProgress: PropTypes.func,
  onError: PropTypes.func.isRequired,
  onEvent: PropTypes.func.isRequired
});

_defineProperty(Video, "defaultProps", {
  src: null,
  paused: true,
  volume: 0.5
});

var Video$1 = React.forwardRef((props, ref) => React.createElement(VideoSourceContext.Consumer, null, ({
  currentSrc,
  sources,
  currentQuality,
  format
}) => React.createElement(Video, _extends({
  ref: ref
}, props, {
  src: currentSrc,
  format: format,
  sources: sources,
  currentQuality: currentQuality
}))));

var KeyCode = {
  ENTER: 13,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  F: 70,
  J: 74,
  K: 75,
  L: 76,
  M: 77
};

var styles$4 = StyleSheet.create({
  root: {
    display: 'flex',
    alignItems: 'center',
    height: '2.5em',
    padding: '0 0.5em'
  },
  button: {
    display: 'block',
    width: '2.5em',
    height: '2.5em',
    margin: 0,
    padding: '0.5em',
    border: 'none',
    borderRadius: 0,
    fontSize: 'inherit',
    color: 'rgba(255, 255, 255, 0.7)',
    background: 'none',
    cursor: 'pointer',
    transition: 'color 300ms',
    ':hover': {
      color: '#fff'
    },
    ':focus': {
      outline: 'none'
    }
  },
  menuContainer: {
    position: 'relative'
  },
  menu: {
    position: 'absolute',
    left: '50%',
    bottom: '100%',
    visibility: 'hidden',
    opacity: 0,
    transform: 'translateX(-50%)',
    transition: 'visibility 300ms, opacity 300ms',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    borderRadius: '4px'
  },
  menuShown: {
    visibility: 'visible',
    opacity: 1
  },
  timeline: {
    flex: 1
  },
  time: {
    padding: '0 0.5em',
    width: '100px',
    textAlign: 'center',
    fontSize: '0.875em',
    lineHeight: 2.5,
    color: 'rgba(255, 255, 255, 0.9)'
  },
  qualityButton: {
    width: 'auto',
    lineHeight: 1.5
  },
  qualityButtonText: {
    fontSize: '0.875em'
  },
  qualityMenu: {
    padding: '0.25em 0'
  },
  qualityMenuItem: {
    display: 'block',
    height: '2em',
    margin: 0,
    padding: '0 0.75em',
    border: 'none',
    borderRadius: 0,
    fontSize: '0.875em',
    lineHeight: 2,
    whiteSpace: 'nowrap',
    color: 'rgba(255, 255, 255, 0.5)',
    background: 'none',
    cursor: 'pointer',
    transition: 'color 300ms, background-color 300ms',
    ':hover': {
      backgroundColor: 'rgba(255, 255, 255, 0.2)'
    },
    ':focus': {
      outline: 'none'
    }
  },
  qualityMenuActiveItem: {
    color: '#fff'
  },
  fullScreenTooltip: {
    pointerEvents: 'none'
  },
  fullScreenedTime: {
    width: '150px'
  },
  fullScreenTooltipWide: {
    left: '30%'
  }
});

var fullscreen = React.createElement("svg", {
  viewBox: "0 0 24 24"
}, React.createElement("path", {
  d: "M20,10 L20,5 C20,4.44771525 19.5490248,4 19.009222,4 L14,4 L14,6 L18,6 L18,10 L20,10 Z M19.7115371,19.7068284 C19.8902571,19.5277733 20,19.2813055 20,19.009222 L20,14 L18,14 L18,18 L14,18 L14,20 L19.009222,20 C19.2776249,20 19.5240668,19.8893106 19.7040291,19.7101145 L19.7115371,19.7068284 Z M6,18 L6,14 L4,14 L4,19.009222 C4,19.2813055 4.10974288,19.5277733 4.28846285,19.7068284 C4.47593315,19.8893106 4.72237506,20 4.99077797,20 L10,20 L10,18 L6,18 Z M4.28846285,4.29317155 C4.10974288,4.47222673 4,4.71869448 4,4.99077797 L4,10 L6,10 L6,6 L10,6 L10,4 L4.99077797,4 C4.72237506,4 4.47593315,4.11068941 4.29597088,4.28988548 L4.28846285,4.29317155 Z"
}));

var muted = React.createElement("svg", {
  viewBox: "0 0 24 24"
}, React.createElement("path", {
  d: "M7.38001507,9.5 L5,9.5 L5,12.0119396 L5,14.5238791 L8.33098415,14.5238791 L8.33098415,14.5238791 C8.39017333,14.520451 8.4497727,14.5223174 8.50904598,14.5296109 C8.72475585,14.5524598 8.91816198,14.6424266 9.06920843,14.7779841 L13,17.4293365 L13,15.1199849 L7.38001507,9.5 Z M15,17.1199849 L15,19.251289 C15,19.8045373 14.5522847,20.25 14,20.25 C13.98423,20.25 13.9685502,20.2496405 13.9529683,20.2489292 C13.7472793,20.2584936 13.5372091,20.2041245 13.3535806,20.0802655 L8.08102098,16.5238791 L4.00000001,16.5238791 C3.71994909,16.5238791 3.46994918,16.4119504 3.29196292,16.2310404 C3.11117675,16.0497507 3,15.7991447 3,15.5223056 L3,12.0119396 L3,8.50157356 C3,8.2247344 3.11117675,7.97412842 3.29196292,7.79283868 C3.46994918,7.61192872 3.71994909,7.5 4.00000001,7.5 L5.38001507,7.5 L3.38382011,5.50380504 C2.99233448,5.1123194 2.98883249,4.48109777 3.38207944,4.08785081 C3.77260374,3.69732652 4.3999302,3.691488 4.79803367,4.08959148 L18.936688,18.2282458 C19.3281736,18.6197314 19.3316756,19.250953 18.9384286,19.6442 C18.5479043,20.0347243 17.9205779,20.0405628 17.5224744,19.6424593 L15,17.1199849 Z M10.792179,8.08373676 L9.35149599,6.64305379 L13.3535806,3.94361361 C13.5372091,3.81975463 13.7472793,3.76538554 13.9529683,3.77494994 C13.9685502,3.77423867 13.98423,3.77387913 14,3.77387913 C14.5522847,3.77387913 15,4.21934183 15,4.77259008 L15,12.0119396 L15,12.2915578 L13,10.2915578 L13,6.59454265 L10.792179,8.08373676 Z M18.0173138,15.3088716 C18.8917509,14.408489 19.4301566,13.1799808 19.4301566,11.8257212 C19.4301566,10.2214787 18.6746368,8.79369726 17.5,7.87877967 L17.5067574,7.87009164 C17.2041341,7.69816923 17,7.37292366 17,7 C17,6.44771525 17.4477153,6 18,6 C18.2836948,6 18.5397977,6.11813499 18.721799,6.30789526 L18.7279374,6.30000305 C20.3724289,7.58088767 21.4301566,9.57978168 21.4301566,11.8257212 C21.4301566,13.7322659 20.6679517,15.4607882 19.431636,16.7231938 L18.0173138,15.3088716 Z"
}));

var pause$1 = React.createElement("svg", {
  viewBox: "0 0 24 24"
}, React.createElement("path", {
  d: "M9,5 C10,5 10,6 10,6 C10,6 10,17 10,18 C10,19 9,19 9,19 L7,19 C6,19 6,18 6,18 L6,6 C6,5 7,5 7,5 C7,5 8,5 9,5 Z M17,5 C18,5 18,6 18,6 C18,6 18,17 18,18 C18,19 17,19 17,19 L15,19 C14,19 14,18 14,18 L14,6 C14,5 15,5 15,5 C15,5 16,5 17,5 Z"
}));

var play$1 = React.createElement("svg", {
  viewBox: "0 0 24 24"
}, React.createElement("path", {
  d: "M8.03610236,19.7012935 C6.93281899,20.3993842 6,19.8347521 6,18.4154722 L6,5.59575582 C6,4.14567779 6.91151094,3.59901121 8.03610236,4.30993442 L18.1645278,10.7185093 C19.2678112,11.4166 19.2891193,12.5817954 18.1645278,13.2927186 L8.03610236,19.7012935 Z"
}));

var smallscreen = React.createElement("svg", {
  viewBox: "0 0 24 24"
}, React.createElement("path", {
  d: "M14.2884629,14.2931716 C14.1097429,14.4722267 14,14.7186945 14,14.990778 L14,20 L16,20 L16,16 L20,16 L20,14 L14.990778,14 C14.7223751,14 14.4759332,14.1106894 14.2959709,14.2898855 L14.2884629,14.2931716 Z M16,8 L16,4 L14,4 L14,9.00922203 C14,9.28130552 14.1097429,9.52777327 14.2884629,9.70682845 C14.4759332,9.88931059 14.7223751,10 14.990778,10 L20,10 L20,8 L16,8 Z M8,16 L8,20 L10,20 L10,14.990778 C10,14.7186945 9.89025712,14.4722267 9.71153715,14.2931716 C9.52406685,14.1106894 9.27762494,14 9.00922203,14 L4,14 L4,16 L8,16 L8,16 Z M9.71153715,9.70682845 C9.89025712,9.52777327 10,9.28130552 10,9.00922203 L10,4 L8,4 L8,8 L4,8 L4,10 L9.00922203,10 C9.27762494,10 9.52406685,9.88931059 9.70402912,9.71011452 L9.71153715,9.70682845 Z"
}));

var volume = React.createElement("svg", {
  viewBox: "0 0 24 24"
}, React.createElement("path", {
  d: "M5,12.0119396 L5,14.5238791 L8.33098415,14.5238791 L8.33098415,14.5238791 C8.39017333,14.520451 8.4497727,14.5223174 8.50904598,14.5296109 C8.72475585,14.5524598 8.91816198,14.6424266 9.06920843,14.7779841 L13,17.4293365 L13,12.0119396 L13,6.59454265 L9.06920843,9.24589504 C8.91816198,9.38145255 8.72475585,9.47141933 8.50904598,9.49426822 C8.4497727,9.50156175 8.39017333,9.5034281 8.33098415,9.5 L8.33098415,9.5 L5,9.5 L5,12.0119396 Z M3,12.0119396 L3,8.50157356 C3,8.2247344 3.11117675,7.97412842 3.29196292,7.79283868 C3.46994918,7.61192872 3.71994909,7.5 4.00000001,7.5 L8.08102098,7.5 L13.3535806,3.94361361 C13.5372091,3.81975463 13.7472793,3.76538554 13.9529683,3.77494994 C13.9685502,3.77423867 13.98423,3.77387913 14,3.77387913 C14.5522847,3.77387913 15,4.21934183 15,4.77259008 L15,12.0119396 L15,19.251289 C15,19.8045373 14.5522847,20.25 14,20.25 C13.98423,20.25 13.9685502,20.2496405 13.9529683,20.2489292 C13.7472793,20.2584936 13.5372091,20.2041245 13.3535806,20.0802655 L8.08102098,16.5238791 L4.00000001,16.5238791 C3.71994909,16.5238791 3.46994918,16.4119504 3.29196292,16.2310404 C3.11117675,16.0497507 3,15.7991447 3,15.5223056 L3,12.0119396 Z M17.5059844,15.7803571 L17.5,15.7726628 C18.6746368,14.8577452 19.4301566,13.4299638 19.4301566,11.8257212 C19.4301566,10.2214787 18.6746368,8.79369726 17.5,7.87877967 L17.5067574,7.87009164 C17.2041341,7.69816923 17,7.37292366 17,7 C17,6.44771525 17.4477153,6 18,6 C18.2836948,6 18.5397977,6.11813499 18.721799,6.30789526 L18.7279374,6.30000305 C20.3724289,7.58088767 21.4301566,9.57978168 21.4301566,11.8257212 C21.4301566,14.0716608 20.3724289,16.0705548 18.7279374,17.3514394 L18.7211832,17.3427554 C18.5392202,17.5321404 18.283375,17.6500092 18,17.6500092 C17.4477153,17.6500092 17,17.2022939 17,16.6500092 C17,16.2774031 17.2037866,15.9523939 17.5059844,15.7803571 L17.5059844,15.7803571 Z"
}));

const PlayButtonItem = ({
  isPlaying,
  onClick
}) => React.createElement("div", {
  className: css(styles$4.toggle)
}, React.createElement("button", {
  className: css(styles$4.button),
  onClick: onClick
}, React.createElement(Icon, {
  icon: isPlaying ? pause$1 : play$1
})));

function calculatePercentage(value, total) {
  if (!total) {
    return `0%`;
  }

  return `${clamp(value / total, 0, 1) * 100}%`;
}

var styles$5 = StyleSheet.create({
  root: {
    overflow: 'hidden',
    userSelect: 'none',
    cursor: 'pointer',
    touchAction: 'none',
    WebkitTapHighlightColor: 'transparent',
    ':focus': {
      outline: 'none'
    }
  },
  inner: {
    position: 'relative',
    display: 'flex',
    alignItems: 'center',
    width: '100%',
    height: '100%'
  },
  track: {
    position: 'relative',
    flex: 1,
    overflow: 'hidden',
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    borderRadius: '2px'
  },
  bar: {
    position: 'absolute',
    backgroundColor: '#fff',
    borderRadius: '2px 0 0 2px'
  },
  thumbWrapper: {
    position: 'absolute'
  },
  thumb: {
    width: '1em',
    height: '1em',
    margin: '-0.5em',
    borderRadius: '50%',
    backgroundColor: '#fff'
  }
});
const horizontal = StyleSheet.create({
  root: {
    height: '1em',
    padding: `0 0.5em`
  },
  inner: {
    flexDirection: 'row'
  },
  track: {
    height: 4
  },
  bar: {
    top: 0,
    bottom: 0
  },
  thumbWrapper: {
    top: '50%'
  }
});
const vertical = StyleSheet.create({
  root: {
    width: '1em',
    padding: `0.5em 0`
  },
  inner: {
    flexDirection: 'column'
  },
  track: {
    width: 4
  },
  bar: {
    left: 0,
    right: 0
  },
  thumbWrapper: {
    left: '50%'
  }
});

class Slider extends Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      isSlideActive: false,
      isSliding: false,
      slidingValue: null // refs

    });

    _defineProperty(this, "trackRef", React.createRef());

    _defineProperty(this, "handleKeyDown", event => {
      const {
        reverse,
        value,
        total,
        step
      } = this.props;
      let direction = 0;

      if (event.keyCode === KeyCode.LEFT || event.keyCode === KeyCode.DOWN) {
        direction = -1;
      }

      if (event.keyCode === KeyCode.RIGHT || event.keyCode === KeyCode.UP) {
        direction = 1;
      }

      if (reverse) {
        direction = -direction;
      }

      const result = clamp(value + step * direction, 0, total);

      if (result !== value) {
        event.preventDefault();
        this.handleChange(result);
      }
    });

    _defineProperty(this, "handleDragStart", event => {
      if (event.button !== 0) return;
      const value = this.getSlidingValue(event);
      this.setState({
        isSlideActive: true,
        slidingValue: value
      });
      const {
        onDragStart
      } = this.props;

      if (onDragStart) {
        onDragStart();
      }

      this.handleChange(value);
      this.registerEvents();
    });

    _defineProperty(this, "handleDragMove", event => {
      const value = this.getSlidingValue(event);
      this.setState({
        slidingValue: value,
        isSliding: true
      });
      this.handleChange(value);
    });

    _defineProperty(this, "handleDragEnd", event => {
      this.unregisterEvents();
      const {
        onDragEnd
      } = this.props;

      if (onDragEnd) {
        onDragEnd();
      }

      if (this.state.isSliding) {
        // 点击动作不需要重复触发 change event
        this.handleChange(this.getSlidingValue(event));
      }

      this.setState({
        isSlideActive: false,
        slidingValue: null,
        isSliding: false
      });
    });

    _defineProperty(this, "handleChange", value => {
      const {
        onChange
      } = this.props;

      if (onChange) {
        onChange(value);
      }
    });
  }

  registerEvents() {
    document.addEventListener('mousemove', this.handleDragMove);
    document.addEventListener('mouseup', this.handleDragEnd);
  }

  unregisterEvents() {
    document.removeEventListener('mousemove', this.handleDragMove);
    document.removeEventListener('mouseup', this.handleDragEnd);
  }

  getVariantStyleSheet() {
    const {
      orientation
    } = this.props;
    return orientation === 'horizontal' ? horizontal : vertical;
  }

  getStyles(name) {
    let customStyles = this.props.styles;

    if (!Array.isArray(customStyles)) {
      customStyles = [customStyles];
    }

    customStyles = customStyles.filter(Boolean);
    return [styles$5[name], this.getVariantStyleSheet()[name], ...customStyles.map(item => item[name])];
  }

  getClassName(...names) {
    return css(...Array.prototype.concat.apply([], names.map(name => this.getStyles(name))));
  }

  getAlignKey() {
    const {
      orientation,
      reverse
    } = this.props;

    if (orientation === 'horizontal') {
      return reverse ? 'right' : 'left';
    } else {
      return reverse ? 'top' : 'bottom';
    }
  }

  getSizeKey() {
    const {
      orientation
    } = this.props;
    return orientation === 'horizontal' ? 'width' : 'height';
  }

  getPercentage() {
    const {
      value,
      total
    } = this.props;
    const {
      isSlideActive,
      slidingValue
    } = this.state;
    return calculatePercentage(isSlideActive ? slidingValue : value, total);
  }

  getBufferedPercentage() {
    const {
      buffered,
      total
    } = this.props;
    return calculatePercentage(buffered, total);
  }

  getSlidingValue(event) {
    const {
      orientation,
      reverse,
      total
    } = this.props;
    const track = this.trackRef.current;
    if (!track) return 0;
    const rect = track.getBoundingClientRect();
    let value;

    if (orientation === 'horizontal') {
      value = (event.clientX - rect.left) / rect.width;
    } else {
      value = (rect.bottom - event.clientY) / rect.height;
    }

    value = clamp(value, 0, 1);

    if (reverse) {
      value = 1 - value;
    }

    return value * total;
  }

  render() {
    const {
      buffered,
      onFocus,
      onBlur,
      noInteraction
    } = this.props;
    const {
      isSlideActive
    } = this.state;
    const interactionProps = noInteraction ? {} : {
      tabIndex: 0,
      onFocus,
      onBlur,
      onKeyDown: this.handleKeyDown,
      onMouseDown: this.handleDragStart
    };
    return React.createElement("div", _extends({
      className: this.getClassName('root')
    }, interactionProps), React.createElement("div", {
      className: this.getClassName('inner')
    }, React.createElement("div", {
      ref: this.trackRef,
      className: this.getClassName('track')
    }, Boolean(buffered) && React.createElement("div", {
      className: this.getClassName('bar', 'buffered'),
      style: {
        [this.getAlignKey()]: 0,
        [this.getSizeKey()]: this.getBufferedPercentage()
      }
    }), React.createElement("div", {
      className: this.getClassName('bar'),
      style: {
        [this.getAlignKey()]: 0,
        [this.getSizeKey()]: this.getPercentage()
      }
    })), !noInteraction && React.createElement("div", {
      className: this.getClassName('thumbWrapper'),
      style: {
        [this.getAlignKey()]: this.getPercentage()
      }
    }, React.createElement("div", {
      className: this.getClassName('thumb', isSlideActive && 'thumbSliding')
    }))));
  }

}

_defineProperty(Slider, "propTypes", {
  orientation: PropTypes.oneOf(['horizontal', 'vertical']),
  reverse: PropTypes.bool,
  value: PropTypes.number,
  buffered: PropTypes.number,
  total: PropTypes.number,
  step: PropTypes.number,
  onFocus: PropTypes.func,
  onBlur: PropTypes.func,
  onDragStart: PropTypes.func,
  onDragEnd: PropTypes.func,
  onChange: PropTypes.func,
  noInteraction: PropTypes.bool // 不可交互

});

_defineProperty(Slider, "defaultProps", {
  orientation: 'horizontal',
  reverse: false,
  value: 0,
  buffered: 0,
  total: 0,
  step: 1
});

var styles$6 = StyleSheet.create({});
const slider = StyleSheet.create({
  root: {
    height: 40
  },
  track: {
    transition: 'transform 300ms'
  },
  bar: {
    backgroundColor: '#0f88eb'
  },
  thumb: {
    transform: 'scale(0)',
    transition: 'transform 300ms'
  },
  buffered: {
    backgroundColor: 'rgba(255, 255, 255, 0.6)',
    borderRadius: '2px 0 0 2px'
  }
});
const hoveredSlider = StyleSheet.create({
  thumb: {
    transform: 'scale(1)'
  }
});
const minimal = StyleSheet.create({
  root: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    padding: 0,
    height: '3px'
  },
  track: {
    borderRadius: 0
  },
  thumb: {
    display: 'none'
  },
  buffered: {
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    borderRadius: '2px 0 0 2px'
  }
});

class Timeline extends Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      isHovered: false,
      isFocused: false,
      isDragging: false // refs

    });

    _defineProperty(this, "root", null);

    _defineProperty(this, "handlePointerEnter", () => {
      this.setState({
        isHovered: true
      });
    });

    _defineProperty(this, "handlePointerLeave", () => {
      this.setState({
        isHovered: false,
        isFocused: false
      });
    });

    _defineProperty(this, "handleFocus", () => {
      this.setState({
        isFocused: true
      });
    });

    _defineProperty(this, "handleBlur", () => {
      this.setState({
        isFocused: false
      });
    });

    _defineProperty(this, "handleDragStart", () => {
      this.setState({
        isDragging: true
      });
      const {
        onDragStart
      } = this.props;

      if (onDragStart) {
        onDragStart();
      }
    });

    _defineProperty(this, "handleDragEnd", () => {
      this.setState({
        isDragging: false
      });
      const {
        onDragEnd
      } = this.props;

      if (onDragEnd) {
        onDragEnd();
      }
    });

    _defineProperty(this, "handleChange", value => {
      const {
        onSeek,
        onChange
      } = this.props;

      if (onSeek && value !== this.props.value) {
        onChange(value);
      }

      if (this.state.isDragging) return;

      if (onSeek) {
        onSeek(value);
      }
    });
  }

  render() {
    const {
      isHovered,
      isFocused,
      isDragging
    } = this.state;
    return React.createElement("div", {
      className: css(styles$6.root),
      onMouseEnter: this.handlePointerEnter,
      onMouseLeave: this.handlePointerLeave
    }, React.createElement(Slider, _extends({}, this.props, {
      styles: [slider, (isHovered || isFocused || isDragging) && hoveredSlider],
      onFocus: this.handleFocus,
      onBlur: this.handleBlur,
      onDragStart: this.handleDragStart,
      onDragEnd: this.handleDragEnd,
      onChange: this.handleChange
    })));
  }

}

_defineProperty(Timeline, "propTypes", {
  onDragStart: PropTypes.func,
  onDragEnd: PropTypes.func,
  onChange: PropTypes.func,
  onSeek: PropTypes.func
});

class MinimalTimeline extends Component {
  shouldComponentUpdate(nextProps) {
    return this.props.show || nextProps.show;
  }

  render() {
    const {
      duration,
      currentTime,
      buffered
    } = this.props;
    return React.createElement(Slider, {
      value: currentTime,
      total: duration,
      buffered: buffered,
      styles: [slider, minimal],
      noInteraction: true
    });
  }

}

_defineProperty(MinimalTimeline, "propTypes", {
  duration: PropTypes.number.isRequired,
  currentTime: PropTypes.number.isRequired,
  buffered: PropTypes.number.isRequired,
  show: PropTypes.bool
});

_defineProperty(MinimalTimeline, "defaultProps", {
  duration: 0,
  currentTime: 0,
  buffered: 0
});

const TimelineItem = props => React.createElement("div", {
  className: css(styles$4.timeline)
}, React.createElement(Timeline, props));

const CombinedTimeItem = ({
  isFullScreen,
  currentTime,
  duration
}) => React.createElement("div", {
  className: css(styles$4.time, isFullScreen && styles$4.fullScreenedTime)
}, React.createElement("div", {
  className: css(styles$4.timeText)
}, React.createElement(Time, {
  value: currentTime
}), ' / ', React.createElement(Time, {
  value: duration
})));

/**
 * reverse an array without mutating the original one
 */
var reverseArray = (arr => arr.slice().reverse());

const LocaleContext = React.createContext('en');
LocaleContext.displayName = 'LocaleContext';

var strings = {
  en: {
    'quality-auto': 'Auto',
    'quality-ld': 'LD',
    'quality-sd': 'SD',
    'quality-hd': 'HD',
    'action-enter-fullscreen': 'Fullscreen',
    'action-exit-fullscreen': 'Exit Fullscreen'
  },
  ja: {
    'quality-auto': '自動',
    'quality-ld': '低画質',
    'quality-sd': '標準画質',
    'quality-hd': '高画質',
    'action-enter-fullscreen': '全画面',
    'action-exit-fullscreen': '全画面終了'
  },
  // covers zh-Hans-CN and zh-Hans-SG
  'zh-Hans': {
    'quality-auto': '自动',
    'quality-ld': '低清',
    'quality-sd': '标清',
    'quality-hd': '超清',
    'action-enter-fullscreen': '全屏',
    'action-exit-fullscreen': '退出全屏'
  },
  // covers zh-Hant-HK and zh-Hant-TW
  'zh-Hant': {
    'quality-auto': '自動',
    'quality-ld': '低畫質',
    'quality-sd': '標準畫質',
    'quality-hd': '高畫質',
    'action-enter-fullscreen': '全螢幕',
    'action-exit-fullscreen': '結束全螢幕'
  }
};

const TranslatedText = ({
  name
}) => React.createElement(LocaleContext.Consumer, null, locale => strings[locale][name]);

const QUALITIES = {
  auto: 'quality-auto',
  ld: 'quality-ld',
  sd: 'quality-sd',
  hd: 'quality-hd'
};

class QualityMenuItem extends React.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      isQualityHovered: false
    });

    _defineProperty(this, "handleQualityPointerEnter", () => {
      this.setState({
        isQualityHovered: true
      });
    });

    _defineProperty(this, "handleQualityPointerLeave", () => {
      this.setState({
        isQualityHovered: false
      });
    });
  }

  render() {
    const {
      isQualityHovered
    } = this.state;
    return React.createElement(VideoSourceContext.Consumer, null, ({
      qualities,
      setCurrentQuality,
      currentQuality
    }) => qualities.length > 1 && React.createElement("div", {
      className: css(styles$4.menuContainer),
      onMouseEnter: this.handleQualityPointerEnter,
      onMouseLeave: this.handleQualityPointerLeave
    }, React.createElement("button", {
      className: css(styles$4.button, styles$4.qualityButton)
    }, React.createElement("span", {
      className: css(styles$4.qualityButtonText)
    }, React.createElement(TranslatedText, {
      name: QUALITIES[currentQuality]
    }))), React.createElement("div", {
      className: css(styles$4.menu, isQualityHovered && styles$4.menuShown)
    }, React.createElement("div", {
      className: css(styles$4.qualityMenu)
    }, reverseArray(qualities).map(q => React.createElement("button", {
      key: q,
      className: css(styles$4.qualityMenuItem, currentQuality === q && styles$4.qualityMenuActiveItem),
      onClick: () => setCurrentQuality(q)
    }, React.createElement(TranslatedText, {
      name: QUALITIES[q]
    })))))));
  }

}

var styles$7 = StyleSheet.create({
  root: {
    padding: '0.375em 0'
  }
});
const slider$1 = StyleSheet.create({
  root: {
    width: '2.5em',
    height: '4em'
  },
  track: {
    margin: '-0.4em 0',
    // 之前是 -0.5em（thumb 的半径），是为了在 0 或 100% 的情况下，让 thumb 的边缘和 track 的边缘平齐
    // 因为下面缩放了 0.8 所以改为 0.5em * 0.8 = 0.4em
    // workaround for bug with overflow: hidden; in chrome
    transform: 'translate3d(0, 0, 0)'
  },
  thumb: {
    transform: 'scale(0.8)',
    transition: 'transform 300ms',
    ':hover': {
      transform: 'scale(1)'
    }
  },
  thumbSliding: {
    transform: 'scale(1)'
  }
});

class VolumeSlider extends Component {
  render() {
    return React.createElement("div", {
      className: css(styles$7.root)
    }, React.createElement(Slider, _extends({}, this.props, {
      styles: slider$1,
      orientation: "vertical",
      step: 0.1
    })));
  }

}

const VolumeItem = ({
  volume: volume$1,
  menuShown,
  onMouseEnter,
  onMouseLeave,
  onDragStart,
  onDragEnd,
  onChange,
  onToggleMuted
}) => React.createElement("div", {
  className: css(styles$4.menuContainer),
  onMouseEnter: onMouseEnter,
  onMouseLeave: onMouseLeave
}, React.createElement("button", {
  className: css(styles$4.button),
  onClick: onToggleMuted
}, React.createElement(Icon, {
  icon: volume$1 === 0 ? muted : volume
})), React.createElement("div", {
  className: css(styles$4.menu, menuShown && styles$4.menuShown)
}, React.createElement(VolumeSlider, {
  value: volume$1,
  total: 1,
  onDragStart: onDragStart,
  onDragEnd: onDragEnd,
  onChange: onChange
})));

var styles$8 = StyleSheet.create({
  root: {
    padding: '0.25em 0.5em',
    fontSize: '0.875em',
    whiteSpace: 'nowrap',
    color: '#fff'
  }
});

class Tooltip extends Component {
  render() {
    const {
      content
    } = this.props;
    return React.createElement("div", {
      className: css(styles$8.root)
    }, React.createElement(TranslatedText, {
      name: content
    }));
  }

}

_defineProperty(Tooltip, "propTypes", {
  content: PropTypes.string.isRequired
});

class Hover extends React.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      isHovered: false
    });

    _defineProperty(this, "handlePointerEnter", () => {
      this.setState({
        isHovered: true
      });
    });

    _defineProperty(this, "handlePointerLeave", () => {
      this.setState({
        isHovered: false
      });
    });
  }

  render() {
    const {
      onMouseEnter,
      onMouseLeave,
      children,
      ...rest
    } = this.props;
    const {
      isHovered
    } = this.state;
    return React.createElement("div", _extends({}, rest, {
      onMouseEnter: sequence(this.handlePointerEnter, onMouseEnter || noop),
      onMouseLeave: sequence(this.handlePointerLeave, onMouseLeave || noop)
    }), children(isHovered));
  }

}

const {
  isMobile: isMobile$2
} = ua;

const FullScreenButtonItem = ({
  isFullScreen,
  onClick
}) => React.createElement(Hover, {
  className: css(styles$4.menuContainer)
}, isFullScreenHovered => React.createElement(React.Fragment, null, React.createElement("button", {
  className: css(styles$4.button),
  onClick: onClick
}, React.createElement(Icon, {
  icon: isFullScreen ? smallscreen : fullscreen
})), React.createElement("div", {
  className: css(styles$4.fullScreenTooltip, styles$4.menu, isFullScreenHovered && styles$4.menuShown, isFullScreen && styles$4.fullScreenTooltipWide)
}, !isMobile$2 && React.createElement(Tooltip, {
  content: isFullScreen ? 'action-exit-fullscreen' : 'action-enter-fullscreen'
}))));

class Controller extends Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      isVolumeHovered: false,
      isVolumeDragging: false,
      isVolumeKeyboard: false
    });

    _defineProperty(this, "prevVolume", 1);

    _defineProperty(this, "firstKey", true);

    _defineProperty(this, "slideTime", null);

    _defineProperty(this, "onDragMove", slideTime => {
      const {
        duration
      } = this.props;
      slideTime = clamp(slideTime, 0, duration);
      this.setState({
        slideTime
      });
    });

    _defineProperty(this, "handleToggle", type => {
      const {
        isPlaying,
        onPlay,
        onPause
      } = this.props;

      if (!isPlaying && onPlay) {
        onPlay(type);
      }

      if (isPlaying && onPause) {
        onPause(type);
      }
    });

    _defineProperty(this, "handleSeek", currentTime => {
      const {
        duration,
        onSeek
      } = this.props;
      currentTime = clamp(currentTime, 0, duration);

      if (onSeek) {
        onSeek(currentTime);
        this.setState({
          slideTime: null
        });
      }
    });

    _defineProperty(this, "handleVolumeChange", volume => {
      volume = clamp(volume, 0, 1);
      const {
        onVolumeChange
      } = this.props;

      if (onVolumeChange) {
        onVolumeChange(volume);
      }
    });

    _defineProperty(this, "handleToggleMuted", () => {
      const {
        volume
      } = this.props;

      if (volume) {
        this.prevVolume = volume;
      }

      this.handleVolumeChange(volume ? 0 : this.prevVolume);
    });

    _defineProperty(this, "handleVolumePointerEnter", () => {
      this.setState({
        isVolumeHovered: true
      });
    });

    _defineProperty(this, "handleVolumePointerLeave", () => {
      this.setState({
        isVolumeHovered: false
      });
    });

    _defineProperty(this, "handleVolumeDragStart", () => {
      const {
        volume
      } = this.props;

      if (volume) {
        this.prevVolume = volume;
      }

      this.setState({
        isVolumeDragging: true
      });
      const {
        onDragStart
      } = this.props;

      if (onDragStart) {
        onDragStart();
      }
    });

    _defineProperty(this, "handleVolumeDragEnd", () => {
      this.setState({
        isVolumeDragging: false
      });
      const {
        onDragEnd
      } = this.props;

      if (onDragEnd) {
        onDragEnd();
      }
    });

    _defineProperty(this, "handleKeyDown", event => {
      const {
        duration,
        currentTime,
        volume,
        show,
        onToggleFullScreen
      } = this.props;
      let handled = true;

      switch (event.keyCode) {
        case KeyCode.SPACE:
        case KeyCode.K:
          if (this.firstKey) {
            this.handleToggle('keyCode');
          }

          break;

        case KeyCode.ENTER:
        case KeyCode.F:
          if (this.firstKey) {
            onToggleFullScreen();
          }

          break;

        case KeyCode.LEFT:
          this.handleSeek(currentTime - 5);
          break;

        case KeyCode.RIGHT:
          this.handleSeek(currentTime + 5);
          break;

        case KeyCode.J:
          if (this.firstKey) {
            this.handleSeek(currentTime - 10);
          }

          break;

        case KeyCode.L:
          if (this.firstKey) {
            this.handleSeek(currentTime + 10);
          }

          break;

        case KeyCode.ZERO:
        case KeyCode.ONE:
        case KeyCode.TWO:
        case KeyCode.THREE:
        case KeyCode.FOUR:
        case KeyCode.FIVE:
        case KeyCode.SIX:
        case KeyCode.SEVEN:
        case KeyCode.EIGHT:
        case KeyCode.NINE:
          if (show && this.firstKey) {
            const nextTime = duration / 10 * (event.keyCode - KeyCode.ZERO);
            this.handleSeek(nextTime);
          }

          break;

        case KeyCode.M:
          if (this.firstKey) {
            this.handleToggleMuted();
          }

          break;

        case KeyCode.UP:
          if (this.firstKey && volume) {
            this.prevVolume = volume;
          }

          this.setState({
            isVolumeKeyboard: true
          });
          this.handleVolumeChange(volume + 0.05);
          break;

        case KeyCode.DOWN:
          if (this.firstKey && volume) {
            this.prevVolume = volume;
          }

          this.handleVolumeChange(volume - 0.05);
          break;

        default:
          handled = false;
          break;
      }

      if (handled) {
        event.preventDefault();
      }

      this.firstKey = false;
    });

    _defineProperty(this, "handleKeyUp", event => {
      this.firstKey = true;

      switch (event.keyCode) {
        case KeyCode.UP:
        case KeyCode.DOWN:
          this.handleVolumeKeyboard();
          break;
      }
    });

    _defineProperty(this, "handleVolumeKeyboard", debounce(() => {
      this.setState({
        isVolumeKeyboard: false
      });
    }, 1000));
  }

  componentDidMount() {
    if (this.props.standalone) {
      document.addEventListener('keydown', this.handleKeyDown);
      document.addEventListener('keyup', this.handleKeyUp);
    }
  }

  shouldComponentUpdate(nextProps) {
    return this.props.show || nextProps.show;
  }

  componentWillUnmount() {
    if (this.props.standalone) {
      document.removeEventListener('keydown', this.handleKeyDown);
      document.removeEventListener('keyup', this.handleKeyUp);
    }
  }

  render() {
    const {
      isPlaying,
      buffered,
      duration,
      currentTime,
      volume,
      isFullScreen,
      onDragStart,
      onDragEnd,
      onToggleFullScreen,
      hiddenVolumeItem,
      hiddenQualityMenu
    } = this.props;
    const {
      isVolumeHovered,
      isVolumeDragging,
      isVolumeKeyboard,
      slideTime
    } = this.state;
    const displayedCurrentTime = slideTime || currentTime;
    return React.createElement("div", {
      className: css(styles$4.root, isFullScreen && styles$4.fullScreened)
    }, React.createElement(PlayButtonItem, {
      isPlaying: isPlaying,
      onClick: () => this.handleToggle('button')
    }), React.createElement(TimelineItem, {
      value: currentTime,
      total: duration,
      buffered: buffered,
      onDragStart: onDragStart,
      onDragEnd: onDragEnd,
      onChange: this.onDragMove,
      onSeek: this.handleSeek
    }), React.createElement(CombinedTimeItem, {
      isFullScreen: isFullScreen,
      currentTime: displayedCurrentTime,
      duration: duration
    }), !hiddenQualityMenu && React.createElement(QualityMenuItem, null), !hiddenVolumeItem && React.createElement(VolumeItem, {
      volume: volume,
      menuShown: isVolumeHovered || isVolumeDragging || isVolumeKeyboard,
      onMouseEnter: this.handleVolumePointerEnter,
      onMouseLeave: this.handleVolumePointerLeave,
      onToggleMuted: this.handleToggleMuted,
      onDragStart: this.handleVolumeDragStart,
      onDragEnd: this.handleVolumeDragEnd,
      onChange: this.handleVolumeChange
    }), React.createElement(FullScreenButtonItem, {
      isFullScreen: isFullScreen,
      onClick: onToggleFullScreen
    }));
  }

}

_defineProperty(Controller, "propTypes", {
  standalone: PropTypes.bool,
  isPlaying: PropTypes.bool,
  duration: PropTypes.number,
  currentTime: PropTypes.number,
  volume: PropTypes.number,
  buffered: PropTypes.number,
  isFullScreen: PropTypes.bool,
  onDragStart: PropTypes.func,
  onDragEnd: PropTypes.func,
  onPlay: PropTypes.func,
  onPause: PropTypes.func,
  onSeek: PropTypes.func,
  onQualityChange: PropTypes.func,
  onVolumeChange: PropTypes.func,
  onToggleFullScreen: PropTypes.func,
  show: PropTypes.bool,
  hiddenQualityMenu: PropTypes.bool,
  hiddenVolumeItem: PropTypes.bool
});

_defineProperty(Controller, "defaultProps", {
  standalone: false,
  isPlaying: false,
  duration: 0,
  currentTime: 0,
  volume: 0.5,
  buffered: 0,
  isFullScreen: false,
  hiddenVolumeItem: false,
  hiddenQualityMenu: false
});

function getBufferedTime(currentTime, buffered) {
  const item = buffered.find(item => item.start <= currentTime && currentTime <= item.end);

  if (item) {
    return item.end;
  }

  return 0;
}

const compatibleStorage = {
  store: {},

  setItem(key, value) {
    this.store[key] = value;
  },

  removeItem(key) {
    return delete this.store[key];
  },

  getItem(key) {
    return this.store[key];
  }

};
const storage = {
  isSupported: memoize(() => {
    try {
      const testSupport = {
        key: '__test_support_key__',
        value: '__test_support_value__'
      };
      const supported = Boolean(global.localStorage);
      localStorage.setItem(testSupport.key, testSupport.value);
      localStorage.removeItem(testSupport.key);
      return supported;
    } catch (err) {
      return false;
    }
  }),
  getStorage: memoize(() => storage.isSupported() ? localStorage : compatibleStorage),

  set(key, value) {
    storage.getStorage().setItem(key, JSON.stringify(value));
  },

  get(key) {
    try {
      const value = storage.getStorage().getItem(key);
      return JSON.parse(value);
    } catch (error) {
      return null;
    }
  },

  delete(key) {
    storage.getStorage().removeItem(key);
  }

};

const actionAnimation = {
  '0%': {
    opacity: 0,
    transform: 'scale(0)'
  },
  '50%': {
    opacity: 0.6,
    transform: 'scale(0.8)'
  },
  '100%': {
    opacity: 0,
    transform: 'scale(1)'
  }
};
const fadeinAnimation = {
  '0%': {
    opacity: 0
  },
  '100%': {
    opacity: 1
  }
};
const breakpoints = {
  mobile: '26em' // 416px

};

const breakTo = breakpoint => `@media screen and (max-width: ${breakpoints[breakpoint]})`;

var styles$9 = StyleSheet.create({
  root: {
    position: 'relative',
    overflow: 'hidden',
    userSelect: 'none',
    width: '100%',
    height: '100%',
    fontSize: 16,
    backgroundColor: '#000',
    ':focus': {
      outline: 'none'
    }
  },
  fullScreened: {
    fontSize: 24
  },
  actionButton: {
    width: '4.5em',
    height: '4.5em'
  },
  actionButtonAnimated: {
    animationName: actionAnimation,
    animationDuration: '600ms',
    animationFillMode: 'both'
  },
  actionIcon: {
    width: '4.5em',
    height: '4.5em',
    [breakTo('mobile')]: {
      transform: 'scale(0.75)'
    }
  },
  video: {
    width: '100%',
    height: '100%'
  },
  overlay: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    overflow: 'hidden'
  },
  overlayMask: {
    background: 'rgba(0, 0, 0, 0.08)'
  },
  loader: {
    position: 'absolute',
    left: '50%',
    top: '50%',
    color: '#0f88eb',
    transform: 'translate(-50%, -50%)'
  },
  action: {
    position: 'absolute',
    left: '50%',
    top: '50%',
    transform: 'translate(-50%, -50%)'
  },
  backdrop: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0
  },
  title: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    overflow: 'hidden',
    padding: '0 1em',
    lineHeight: 2.5,
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap',
    color: '#fff',
    backgroundImage: 'linear-gradient(to top, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.3))',
    transform: 'translateY(-100%)',
    transition: 'transform 300ms'
  },
  titleShown: {
    transform: 'translateY(0)'
  },
  controller: {
    position: 'absolute',
    left: 0,
    right: 0,
    bottom: 0,
    backgroundImage: 'linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.3))'
  },
  cover: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    overflow: 'hidden',
    backgroundColor: '#000',
    cursor: 'pointer',
    visibility: 'hidden',
    opacity: 0,
    transition: 'visibility 300ms, opacity 300ms'
  },
  coverShown: {
    visibility: 'visible',
    opacity: 1
  },
  coverImage: {
    position: 'absolute',
    left: 0,
    top: 0,
    width: '100%',
    height: '100%'
  },
  coverTime: {
    position: 'absolute',
    right: '0.5em',
    bottom: '0.5em',
    padding: '0.375em',
    fontSize: '0.875em',
    lineHeight: 1,
    color: 'rgba(255, 255, 255, 0.9)',
    backgroundColor: 'transparent',
    textShadow: '0 0 6px rgba(0, 0, 0, 0.4)'
  },
  coverTimeMobile: {
    padding: 0
  },
  coverAction: {
    position: 'absolute',
    left: '50%',
    top: '50%',
    transform: 'translate(-50%, -50%)'
  },
  coverReplayAction: {
    position: 'absolute',
    left: '0',
    right: '0',
    top: '0',
    bottom: '0',
    backgroundColor: 'rgba(0, 0, 0, 0.16)',
    animationName: fadeinAnimation,
    animationDuration: '600ms',
    animationFillMode: 'both'
  },
  coverReplayButton: {
    position: 'absolute',
    left: '0',
    right: '0',
    top: '0',
    bottom: '0',
    height: '40px',
    width: '116px',
    margin: 'auto',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    borderRadius: '4px',
    color: '#fff',
    fontSize: '16px',
    lineHeight: '24px',
    padding: '8px',
    boxSizing: 'border-box',
    textAlign: 'center',
    transition: 'transform 200ms, opacity 200ms',
    willChange: 'transform'
  },
  coverReplayButtonHovered: {
    transform: 'scale(1.1)'
  },
  coverReplayButtonPressed: {
    opacity: '0.7'
  },
  replayIcon: {
    verticalAlign: 'top',
    marginRight: '4px'
  },
  error: {
    position: 'absolute',
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    overflow: 'hidden',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    color: '#fff',
    backgroundColor: '#000'
  },
  errorIcon: {
    width: '2.5em',
    height: '2.5em',
    margin: '0 auto',
    fill: 'currentColor'
  },
  errorMessage: {
    marginTop: '1em',
    fontSize: '1.25em',
    lineHeight: 1,
    textAlign: 'center'
  }
});
const hiddenOrShownStyle = StyleSheet.create({
  base: {
    transition: `opacity .5s ease-in-out, visibility .5s ease-in-out`
  },
  hidden: {
    opacity: 0,
    visibility: 'hidden'
  },
  shown: {
    opacity: 1,
    visibility: 'visible'
  }
});

const CONTROLLER_HIDE_DELAY = 3000;
const {
  isMobile: isMobile$3
} = ua;

class Player extends Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      isPlaybackStarted: false,
      // 开始播放的时候设置为 true，播放中途暂停仍然为 true，直到播放到最后停止的时候才会变成 false，
      isNeverPlayed: true,
      // 用户第一次播放之后设置为 false，并且之后永远为 false
      lastAction: null,
      isDataLoaded: false,
      isPlaying: false,
      isLoading: false,
      duration: 0,
      currentTime: 0,
      volume: 0.5,
      buffered: [],
      isControllerShown: false,
      isControllerHovered: false,
      isControllerDragging: false,
      type: null,
      hovered: false,
      pressed: false
    });

    _defineProperty(this, "isSeeking", false);

    _defineProperty(this, "showLoaderTimeout", null);

    _defineProperty(this, "hideControllerTimeout", null);

    _defineProperty(this, "playerRef", React.createRef());

    _defineProperty(this, "videoRef", React.createRef());

    _defineProperty(this, "setDocumentTitle", () => {
      const {
        title,
        standalone
      } = this.props;

      if (standalone && typeof title === 'string' && title !== document.title) {
        document.title = title;
      }
    });

    _defineProperty(this, "handlePauseAction", ({
      dontApplyOnFullScreen
    } = {}) => {
      if (!this.state.isPlaying) return;
      if (dontApplyOnFullScreen && Boolean(BigScreen.element)) return;
      this.handlePause('button'); // 通过这种方式暂停不会显示中间的图标
    });

    _defineProperty(this, "handleToggle", () => {
      if (this.state.isPlaying) {
        this.handlePause('video');
      } else {
        this.handlePlay('video');
      }
    });

    _defineProperty(this, "handlePlay", (type = null) => {
      const {
        onEvent,
        onBeforePlay
      } = this.props;
      onEvent(EVENTS.PLAYER.REQUEST_PLAY);
      onBeforePlay().then(() => {
        if (!this.state.isPlaybackStarted) {
          onEvent(EVENTS.PLAYER.PLAY_COUNT);
          this.setState({
            isPlaybackStarted: true
          });

          if (!this.state.isDataLoaded) {
            this.setState({
              isLoading: true
            });
          } // workaround a bug in IE about replaying a video.


          if (this.state.currentTime !== 0) {
            this.handleSeek(0);
          }
        } else {
          this.setState({
            lastAction: 'play'
          });
        }

        this.setState({
          isPlaying: true,
          type,
          isNeverPlayed: false
        });
      }).catch(() => {
        onEvent(EVENTS.PLAYER.PLAY_REJECTED); // 播放被取消
      });
    });

    _defineProperty(this, "handlePause", (type = null) => {
      this.props.onEvent(EVENTS.PLAYER.REQUEST_PAUSE);
      const {
        isLoading
      } = this.state;

      if (!isLoading) {
        this.setState({
          lastAction: 'pause',
          isPlaying: false,
          type
        });
      }
    });

    _defineProperty(this, "handleVideoPlay", () => {
      if (!this.state.isPlaying) {
        this.setState({
          isPlaying: true
        });
      }
    });

    _defineProperty(this, "handleVideoPause", () => {
      if (this.state.isPlaying) {
        this.setState({
          isPlaying: false
        });
      }
    });

    _defineProperty(this, "handleVideoEnded", () => {
      this.setState({
        isPlaybackStarted: false,
        lastAction: null,
        isPlaying: false,
        isLoading: false
      });
    });

    _defineProperty(this, "handleVideoLoadedData", () => {
      this.setState({
        isDataLoaded: true,
        isLoading: false
      });
    });

    _defineProperty(this, "handleVideoError", () => {
      this.setState({
        isPlaying: false,
        isLoading: false
      });
    });

    _defineProperty(this, "handleVideoDurationChange", duration => {
      this.setState({
        duration
      });
    });

    _defineProperty(this, "handleVideoTimeUpdate", currentTime => {
      const {
        isLoading
      } = this.state;
      if (isLoading || this.isSeeking) return;
      if (this.isSeeking) return;
      this.setState({
        currentTime
      });
    });

    _defineProperty(this, "handleVideoVolumeChange", volume => {
      volume = Math.round(volume * 100) / 100;
      this.setState({
        volume
      });
      storage.set('@griffith/history-volume', volume);
    });

    _defineProperty(this, "handleSeek", currentTime => {
      const {
        isPlaybackStarted,
        isNeverPlayed,
        currentTime: stateCurrentTime
      } = this.state;
      const isPlayEnded = !isPlaybackStarted && !isNeverPlayed && stateCurrentTime !== 0; // 播放结束，显示「重新播放」状态

      this.setState({
        currentTime
      }); // TODO 想办法去掉这个实例方法调用

      this.videoRef.current.seek(currentTime);

      if (isPlayEnded) {
        this.handlePlay();
      }
    });

    _defineProperty(this, "handleVideoWaiting", () => {
      if (this.showLoaderTimeout !== null) return;
      this.showLoaderTimeout = setTimeout(() => {
        this.setState({
          isLoading: true
        });
      }, 1000);
    });

    _defineProperty(this, "handleVideoPlaying", () => {
      if (this.showLoaderTimeout !== null) {
        clearTimeout(this.showLoaderTimeout);
        this.showLoaderTimeout = null;
      }

      this.setState({
        isLoading: false
      });
    });

    _defineProperty(this, "handleVideoSeeking", () => {
      this.isSeeking = true;
    });

    _defineProperty(this, "handleVideoSeeked", () => {
      this.isSeeking = false;
    });

    _defineProperty(this, "handleVideoProgress", buffered => {
      this.setState({
        buffered
      });
    });

    _defineProperty(this, "handleToggleFullScreen", () => {
      if (BigScreen.enabled) {
        const {
          onEvent
        } = this.props;

        const onEnter = () => onEvent(EVENTS.PLAYER.ENTER_FULLSCREEN);

        const onExit = () => onEvent(EVENTS.PLAYER.EXIT_FULLSCREEN);

        BigScreen.toggle(this.playerRef.current, onEnter, onExit);
      }
    });

    _defineProperty(this, "handleShowController", () => {
      if (!this.state.isControllerShown) {
        this.setState({
          isControllerShown: true
        });
      }

      if (this.hideControllerTimeout !== null) {
        clearTimeout(this.hideControllerTimeout);
      }

      this.hideControllerTimeout = setTimeout(() => {
        this.hideControllerTimeout = null;
        this.setState({
          isControllerShown: false
        });
      }, CONTROLLER_HIDE_DELAY);
    });

    _defineProperty(this, "handleHideController", () => {
      if (this.hideControllerTimeout !== null) {
        clearTimeout(this.hideControllerTimeout);
        this.hideControllerTimeout = null;
      }

      this.setState({
        isControllerShown: false
      });
    });

    _defineProperty(this, "handleControllerPointerEnter", () => {
      this.setState({
        isControllerHovered: true
      });
    });

    _defineProperty(this, "handleControllerPointerLeave", () => {
      this.setState({
        isControllerHovered: false
      });
    });

    _defineProperty(this, "handleControllerDragStart", () => {
      this.setState({
        isControllerDragging: true
      });
    });

    _defineProperty(this, "handleControllerDragEnd", () => {
      this.setState({
        isControllerDragging: false
      });
    });

    _defineProperty(this, "handleMouseEnter", () => {
      this.setState({
        hovered: true
      });
      this.handleShowController();
    });

    _defineProperty(this, "handleMouseLeave", () => {
      this.setState({
        hovered: false
      });
      this.handleHideController();
    });

    _defineProperty(this, "handleMouseDown", () => {
      this.setState({
        pressed: true
      });
      this.handleShowController();
    });

    _defineProperty(this, "handleMouseUp", () => {
      this.setState({
        pressed: false
      });
      this.handleShowController();
    });

    _defineProperty(this, "handleMouseMove", () => {
      if (!this.state.hovered) {
        this.setState({
          hovered: true
        });
      }

      this.handleShowController();
    });
  }

  componentDidMount() {
    this.setDocumentTitle();
    const historyVolume = storage.get('@griffith/history-volume');

    if (historyVolume) {
      this.setState({
        volume: historyVolume
      });
    }

    this.pauseActionSubscription = this.props.subscribeAction(ACTIONS.PLAYER.PAUSE, this.handlePauseAction);
    const {
      autoplay
    } = this.props;

    if (autoplay && this.videoRef.current.root) {
      if (!this.videoRef.current.root.muted) {
        // Muted autoplay is always allowed
        this.handleVideoVolumeChange(0);
      }

      this.handlePlay('video');
    }
  }

  componentDidUpdate() {
    this.setDocumentTitle();
  }

  componentWillUnmount() {
    this.pauseActionSubscription.unsubscribe();
  }

  render() {
    const {
      error,
      title,
      cover,
      standalone,
      onEvent,
      useMSE
    } = this.props;
    const {
      isPlaybackStarted,
      lastAction,
      isPlaying,
      isLoading,
      duration,
      isControllerShown,
      isControllerHovered,
      isControllerDragging,
      currentTime,
      isNeverPlayed,
      volume,
      buffered,
      type,
      hovered,
      pressed
    } = this.state;
    const isFullScreen = Boolean(BigScreen.element); // 未播放时不展示 Controller
    // 播放中暂停时展示 Controller
    // 播放中 Controller shown/hovered/dragging 时展示 Controller
    // 播放结束展示 Controller

    const showController = isPlaybackStarted && (!isPlaying || isControllerShown || isControllerHovered || isControllerDragging) || !isPlaybackStarted && currentTime !== 0;
    const bufferedTime = getBufferedTime(currentTime, buffered);
    return React.createElement("div", {
      className: css(styles$9.root, isFullScreen && styles$9.fullScreened),
      onMouseLeave: this.handleMouseLeave,
      onMouseEnter: this.handleMouseEnter,
      onMouseDown: this.handleMouseDown,
      onMouseUp: this.handleMouseUp,
      onMouseMove: this.handleShowController,
      ref: this.playerRef
    }, React.createElement("div", {
      className: css(styles$9.video)
    }, React.createElement(Video$1, {
      ref: this.videoRef,
      controls: isMobile$3 && isPlaybackStarted,
      paused: !isPlaying,
      volume: volume,
      onPlay: this.handleVideoPlay,
      onPause: this.handleVideoPause,
      onEnded: this.handleVideoEnded,
      onLoadedData: this.handleVideoLoadedData,
      onError: this.handleVideoError,
      onDurationChange: this.handleVideoDurationChange,
      onTimeUpdate: this.handleVideoTimeUpdate,
      onWaiting: this.handleVideoWaiting,
      onPlaying: this.handleVideoPlaying,
      onSeeking: this.handleVideoSeeking,
      onSeeked: this.handleVideoSeeked,
      onProgress: this.handleVideoProgress,
      onEvent: onEvent,
      useMSE: useMSE
    })), React.createElement("div", {
      className: css(styles$9.cover, !isPlaybackStarted && styles$9.coverShown),
      onClick: () => this.handlePlay()
    }, cover && React.createElement(ObjectFitContext.Consumer, null, ({
      objectFit
    }) => React.createElement("img", {
      className: css(styles$9.coverImage),
      src: cover,
      style: {
        objectFit
      }
    })), duration && currentTime === 0 && React.createElement("div", {
      className: css(styles$9.coverTime, isMobile$3 && styles$9.coverTimeMobile)
    }, React.createElement(Time, {
      value: duration
    })), isNeverPlayed && React.createElement("div", {
      className: css(styles$9.coverAction)
    }, React.createElement("div", {
      className: css(styles$9.actionButton)
    }, React.createElement(Icon, {
      icon: play,
      styles: styles$9.actionIcon
    }))), !isNeverPlayed && currentTime !== 0 && React.createElement("div", {
      className: css(styles$9.coverReplayAction)
    }, React.createElement("div", {
      className: css(styles$9.coverReplayButton, hovered && styles$9.coverReplayButtonHovered, pressed && styles$9.coverReplayButtonPressed)
    }, React.createElement(Icon, {
      icon: replay,
      styles: styles$9.replayIcon
    }), "\u91CD\u65B0\u64AD\u653E"))), !isMobile$3 && React.createElement("div", {
      className: css(styles$9.overlay, isNeverPlayed && styles$9.overlayMask)
    }, isPlaybackStarted && isLoading && React.createElement("div", {
      className: css(styles$9.loader)
    }, React.createElement(Loader, null)), lastAction && type !== 'button' && React.createElement("div", {
      className: css(styles$9.action),
      key: lastAction
    }, React.createElement("div", {
      className: css(styles$9.actionButton, styles$9.actionButtonAnimated)
    }, React.createElement(Icon, {
      icon: lastAction === 'play' ? play : pause,
      styles: styles$9.actionIcon
    }))), React.createElement("div", {
      className: css(styles$9.backdrop),
      onTouchStart: event => {
        // prevent touch to toggle
        event.preventDefault();
      },
      onClick: this.handleToggle
    }), title && isFullScreen && React.createElement("div", {
      className: css(styles$9.title, showController && styles$9.titleShown)
    }, title), isPlaying && (!isLoading || currentTime !== 0) && React.createElement("div", {
      className: css(hiddenOrShownStyle.base, showController ? hiddenOrShownStyle.hidden : hiddenOrShownStyle.shown)
    }, React.createElement(MinimalTimeline, {
      buffered: bufferedTime,
      duration: duration,
      currentTime: currentTime,
      show: !showController
    })), isPlaybackStarted && (!isLoading || currentTime !== 0) && React.createElement("div", {
      className: css(styles$9.controller, hiddenOrShownStyle.base, showController ? hiddenOrShownStyle.shown : hiddenOrShownStyle.hidden),
      onMouseEnter: this.handleControllerPointerEnter,
      onMouseLeave: this.handleControllerPointerLeave
    }, React.createElement(Controller, {
      standalone: standalone,
      isPlaying: isPlaying,
      duration: duration,
      currentTime: currentTime,
      volume: volume,
      buffered: bufferedTime,
      isFullScreen: isFullScreen,
      onDragStart: this.handleControllerDragStart,
      onDragEnd: this.handleControllerDragEnd,
      onPlay: this.handlePlay,
      onPause: this.handlePause,
      onSeek: this.handleSeek,
      onVolumeChange: this.handleVideoVolumeChange,
      onToggleFullScreen: this.handleToggleFullScreen,
      show: showController
    }))), error && React.createElement("div", {
      className: css(styles$9.error)
    }, React.createElement(Icon, {
      icon: alert,
      styles: styles$9.errorIcon
    }), error.message && React.createElement("div", {
      className: css(styles$9.errorMessage)
    }, error.message)));
  }

}

_defineProperty(Player, "propTypes", {
  standalone: PropTypes.bool,
  error: PropTypes.shape({
    message: PropTypes.string
  }),
  title: PropTypes.string,
  cover: PropTypes.string,
  duration: PropTypes.number,
  onEvent: PropTypes.func.isRequired,
  onBeforePlay: PropTypes.func.isRequired
});

_defineProperty(Player, "defaultProps", {
  standalone: false,
  duration: 0,
  autoplay: false
});

_defineProperty(Player, "getDerivedStateFromProps", (props, state) => {
  const {
    duration
  } = props;
  const shouldUpdateDuration = duration && !state.duration;
  const newDurationState = shouldUpdateDuration ? {
    duration
  } : null;
  return { ...newDurationState
  };
});

const PlayerContainer = ({
  standalone,
  id,
  title,
  cover,
  duration,
  sources,
  error,
  onBeforePlay = () => Promise.resolve(),
  shouldObserveResize,
  children,
  initialObjectFit = 'contain',
  useMSE,
  locale = 'en',
  autoplay
}) => React.createElement(ObjectFitProvider, {
  initialObjectFit: initialObjectFit
}, React.createElement(PositionProvider, {
  shouldObserveResize: shouldObserveResize
}, React.createElement(MessageProvider, {
  id: id,
  enableCrossWindow: standalone
}, React.createElement(InternalContext.Consumer, null, ({
  emitEvent,
  subscribeAction
}) => React.createElement(VideoSourceProvider, {
  onEvent: emitEvent,
  sources: sources,
  id: id
}, React.createElement(LocaleContext.Provider, {
  value: locale
}, React.createElement(VideoSourceContext.Consumer, null, ({
  currentSrc
}) => React.createElement(Player, {
  useMSE: useMSE,
  autoplay: autoplay,
  standalone: standalone,
  cover: cover,
  title: title,
  duration: duration,
  error: error,
  onEvent: emitEvent,
  subscribeAction: subscribeAction,
  onBeforePlay: () => onBeforePlay(currentSrc)
})), children))))));

PlayerContainer.propTypes = {
  standalone: PropTypes.bool,
  id: PropTypes.string.isRequired,
  title: PropTypes.string,
  cover: PropTypes.string.isRequired,
  duration: PropTypes.number.isRequired,
  sources: PropTypes.objectOf(PropTypes.shape({
    bitrate: PropTypes.number.isRequired,
    duration: PropTypes.number.isRequired,
    format: PropTypes.string.isRequired,
    height: PropTypes.number.isRequired,
    play_url: PropTypes.string.isRequired,
    size: PropTypes.number.isRequired,
    width: PropTypes.number.isRequired
  })).isRequired,
  error: PropTypes.shape({
    message: PropTypes.string
  }),
  onBeforePlay: PropTypes.func,
  initialObjectFit: PropTypes.oneOf(VALID_FIT),
  useMSE: PropTypes.bool
};

var styles$a = StyleSheet.create({
  container: {
    position: 'absolute',
    pointerEvents: 'none',
    overflow: 'hidden'
  },
  containerFullWidth: {
    width: '100%',
    height: 'auto',
    top: '50%',
    left: 0,
    transform: 'translate(0, -50%)'
  },
  containerFullHeight: {
    width: 'auto',
    height: '100%',
    top: 0,
    left: '50%',
    transform: 'translate(-50%)'
  },
  image: {
    display: 'block',
    visibility: 'hidden'
  },
  imageFullWidth: {
    width: '100%',
    height: 'auto'
  },
  imageFullHeight: {
    width: 'auto',
    height: '100%'
  },
  layer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    overflow: 'hidden',
    pointerEvents: 'none'
  }
});

const getContainerClassName = isFullWidth => css(styles$a.container, isFullWidth ? styles$a.containerFullWidth : styles$a.containerFullHeight);

const getImageClassName = isFullWidth => css(styles$a.image, isFullWidth ? styles$a.imageFullWidth : styles$a.imageFullHeight);

const Positioned = ({
  children
}) => React.createElement(PositionContext.Consumer, null, ({
  isFullWidth,
  helperImageSrc
}) => helperImageSrc && React.createElement("div", {
  className: getContainerClassName(isFullWidth)
}, React.createElement("img", {
  src: helperImageSrc,
  className: getImageClassName(isFullWidth)
}), children));

function Layer({
  children
}) {
  if (!children) return null;
  const layer = React.createElement("div", {
    className: css(styles$a.layer)
  }, children); // 暂时先只考虑 cover

  return React.createElement(ObjectFitContext.Consumer, null, ({
    objectFit
  }) => objectFit === 'cover' ? layer : React.createElement(Positioned, null, layer));
}

export default PlayerContainer;
export { Controller, Layer, ExternalContext as MessageContext, VideoSourceContext };
//# sourceMappingURL=index.js.map
