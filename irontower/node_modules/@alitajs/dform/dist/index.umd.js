(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('antd-mobile/es/wing-blank/style'), require('antd-mobile/es/wing-blank'), require('antd-mobile/es/list/style'), require('antd-mobile/es/list'), require('antd-mobile/es/card/style'), require('antd-mobile/es/card'), require('react'), require('antd-mobile/es/input-item/style'), require('antd-mobile/es/input-item'), require('antd-mobile/es/picker/style'), require('antd-mobile/es/picker'), require('antd-mobile/es/switch/style'), require('antd-mobile/es/switch'), require('antd-mobile/es/textarea-item/style'), require('antd-mobile/es/textarea-item'), require('antd-mobile/es/date-picker/style'), require('antd-mobile/es/date-picker'), require('antd-mobile/es/image-picker/style'), require('antd-mobile/es/image-picker'), require('antd-mobile/es/toast/style'), require('antd-mobile/es/toast'), require('antd-mobile/es/modal/style'), require('antd-mobile/es/modal'), require('antd-mobile/es/flex/style'), require('antd-mobile/es/flex'), require('antd-mobile/es/white-space/style'), require('antd-mobile/es/white-space'), require('antd-mobile/es/button/style'), require('antd-mobile/es/button')) :
  typeof define === 'function' && define.amd ? define(['exports', 'antd-mobile/es/wing-blank/style', 'antd-mobile/es/wing-blank', 'antd-mobile/es/list/style', 'antd-mobile/es/list', 'antd-mobile/es/card/style', 'antd-mobile/es/card', 'react', 'antd-mobile/es/input-item/style', 'antd-mobile/es/input-item', 'antd-mobile/es/picker/style', 'antd-mobile/es/picker', 'antd-mobile/es/switch/style', 'antd-mobile/es/switch', 'antd-mobile/es/textarea-item/style', 'antd-mobile/es/textarea-item', 'antd-mobile/es/date-picker/style', 'antd-mobile/es/date-picker', 'antd-mobile/es/image-picker/style', 'antd-mobile/es/image-picker', 'antd-mobile/es/toast/style', 'antd-mobile/es/toast', 'antd-mobile/es/modal/style', 'antd-mobile/es/modal', 'antd-mobile/es/flex/style', 'antd-mobile/es/flex', 'antd-mobile/es/white-space/style', 'antd-mobile/es/white-space', 'antd-mobile/es/button/style', 'antd-mobile/es/button'], factory) :
  (global = global || self, factory(global.DynamicForm = {}, null, global._WingBlank, null, global._List, null, global._Card, global.React, null, global._InputItem, null, global._Picker, null, global._Switch, null, global._TextareaItem, null, global._DatePicker, null, global._ImagePicker, null, global._Toast, null, global._Modal, null, global._Flex, null, global._WhiteSpace, null, global._Button));
}(this, (function (exports, style, _WingBlank, style$1, _List, style$2, _Card, React, style$3, _InputItem, style$4, _Picker, style$5, _Switch, style$6, _TextareaItem, style$7, _DatePicker, style$8, _ImagePicker, style$9, _Toast, style$a, _Modal, style$b, _Flex, style$c, _WhiteSpace, style$d, _Button) { 'use strict';

  _WingBlank = _WingBlank && _WingBlank.hasOwnProperty('default') ? _WingBlank['default'] : _WingBlank;
  _List = _List && _List.hasOwnProperty('default') ? _List['default'] : _List;
  _Card = _Card && _Card.hasOwnProperty('default') ? _Card['default'] : _Card;
  var React__default = 'default' in React ? React['default'] : React;
  _InputItem = _InputItem && _InputItem.hasOwnProperty('default') ? _InputItem['default'] : _InputItem;
  _Picker = _Picker && _Picker.hasOwnProperty('default') ? _Picker['default'] : _Picker;
  _Switch = _Switch && _Switch.hasOwnProperty('default') ? _Switch['default'] : _Switch;
  _TextareaItem = _TextareaItem && _TextareaItem.hasOwnProperty('default') ? _TextareaItem['default'] : _TextareaItem;
  _DatePicker = _DatePicker && _DatePicker.hasOwnProperty('default') ? _DatePicker['default'] : _DatePicker;
  _ImagePicker = _ImagePicker && _ImagePicker.hasOwnProperty('default') ? _ImagePicker['default'] : _ImagePicker;
  _Toast = _Toast && _Toast.hasOwnProperty('default') ? _Toast['default'] : _Toast;
  _Modal = _Modal && _Modal.hasOwnProperty('default') ? _Modal['default'] : _Modal;
  _Flex = _Flex && _Flex.hasOwnProperty('default') ? _Flex['default'] : _Flex;
  _WhiteSpace = _WhiteSpace && _WhiteSpace.hasOwnProperty('default') ? _WhiteSpace['default'] : _WhiteSpace;
  _Button = _Button && _Button.hasOwnProperty('default') ? _Button['default'] : _Button;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties$1(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose$1(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _arrayWithoutHoles$1(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }

  function _iterableToArray$1(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }

  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray$1(arr) {
    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var reactIs_development = createCommonjsModule(function (module, exports) {



  {
    (function() {

  // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
  // nor polyfill, then a plain number is used for performance.
  var hasSymbol = typeof Symbol === 'function' && Symbol.for;
  var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
  var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
  var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
  var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
  var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
  var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
  var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
  // (unstable) APIs that have been removed. Can we remove the symbols?

  var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
  var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
  var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
  var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
  var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
  var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
  var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
  var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
  var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
  var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
  var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

  function isValidElementType(type) {
    return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
    type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
  }

  function typeOf(object) {
    if (typeof object === 'object' && object !== null) {
      var $$typeof = object.$$typeof;

      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          var type = object.type;

          switch (type) {
            case REACT_ASYNC_MODE_TYPE:
            case REACT_CONCURRENT_MODE_TYPE:
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
              return type;

            default:
              var $$typeofType = type && type.$$typeof;

              switch ($$typeofType) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                case REACT_PROVIDER_TYPE:
                  return $$typeofType;

                default:
                  return $$typeof;
              }

          }

        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }

    return undefined;
  } // AsyncMode is deprecated along with isAsyncMode

  var AsyncMode = REACT_ASYNC_MODE_TYPE;
  var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
  var ContextConsumer = REACT_CONTEXT_TYPE;
  var ContextProvider = REACT_PROVIDER_TYPE;
  var Element = REACT_ELEMENT_TYPE;
  var ForwardRef = REACT_FORWARD_REF_TYPE;
  var Fragment = REACT_FRAGMENT_TYPE;
  var Lazy = REACT_LAZY_TYPE;
  var Memo = REACT_MEMO_TYPE;
  var Portal = REACT_PORTAL_TYPE;
  var Profiler = REACT_PROFILER_TYPE;
  var StrictMode = REACT_STRICT_MODE_TYPE;
  var Suspense = REACT_SUSPENSE_TYPE;
  var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

  function isAsyncMode(object) {
    {
      if (!hasWarnedAboutDeprecatedIsAsyncMode) {
        hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

        console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
      }
    }

    return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
  }
  function isConcurrentMode(object) {
    return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
  }
  function isContextConsumer(object) {
    return typeOf(object) === REACT_CONTEXT_TYPE;
  }
  function isContextProvider(object) {
    return typeOf(object) === REACT_PROVIDER_TYPE;
  }
  function isElement(object) {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
  function isForwardRef(object) {
    return typeOf(object) === REACT_FORWARD_REF_TYPE;
  }
  function isFragment(object) {
    return typeOf(object) === REACT_FRAGMENT_TYPE;
  }
  function isLazy(object) {
    return typeOf(object) === REACT_LAZY_TYPE;
  }
  function isMemo(object) {
    return typeOf(object) === REACT_MEMO_TYPE;
  }
  function isPortal(object) {
    return typeOf(object) === REACT_PORTAL_TYPE;
  }
  function isProfiler(object) {
    return typeOf(object) === REACT_PROFILER_TYPE;
  }
  function isStrictMode(object) {
    return typeOf(object) === REACT_STRICT_MODE_TYPE;
  }
  function isSuspense(object) {
    return typeOf(object) === REACT_SUSPENSE_TYPE;
  }

  exports.AsyncMode = AsyncMode;
  exports.ConcurrentMode = ConcurrentMode;
  exports.ContextConsumer = ContextConsumer;
  exports.ContextProvider = ContextProvider;
  exports.Element = Element;
  exports.ForwardRef = ForwardRef;
  exports.Fragment = Fragment;
  exports.Lazy = Lazy;
  exports.Memo = Memo;
  exports.Portal = Portal;
  exports.Profiler = Profiler;
  exports.StrictMode = StrictMode;
  exports.Suspense = Suspense;
  exports.isAsyncMode = isAsyncMode;
  exports.isConcurrentMode = isConcurrentMode;
  exports.isContextConsumer = isContextConsumer;
  exports.isContextProvider = isContextProvider;
  exports.isElement = isElement;
  exports.isForwardRef = isForwardRef;
  exports.isFragment = isFragment;
  exports.isLazy = isLazy;
  exports.isMemo = isMemo;
  exports.isPortal = isPortal;
  exports.isProfiler = isProfiler;
  exports.isStrictMode = isStrictMode;
  exports.isSuspense = isSuspense;
  exports.isValidElementType = isValidElementType;
  exports.typeOf = typeOf;
    })();
  }
  });
  var reactIs_development_1 = reactIs_development.AsyncMode;
  var reactIs_development_2 = reactIs_development.ConcurrentMode;
  var reactIs_development_3 = reactIs_development.ContextConsumer;
  var reactIs_development_4 = reactIs_development.ContextProvider;
  var reactIs_development_5 = reactIs_development.Element;
  var reactIs_development_6 = reactIs_development.ForwardRef;
  var reactIs_development_7 = reactIs_development.Fragment;
  var reactIs_development_8 = reactIs_development.Lazy;
  var reactIs_development_9 = reactIs_development.Memo;
  var reactIs_development_10 = reactIs_development.Portal;
  var reactIs_development_11 = reactIs_development.Profiler;
  var reactIs_development_12 = reactIs_development.StrictMode;
  var reactIs_development_13 = reactIs_development.Suspense;
  var reactIs_development_14 = reactIs_development.isAsyncMode;
  var reactIs_development_15 = reactIs_development.isConcurrentMode;
  var reactIs_development_16 = reactIs_development.isContextConsumer;
  var reactIs_development_17 = reactIs_development.isContextProvider;
  var reactIs_development_18 = reactIs_development.isElement;
  var reactIs_development_19 = reactIs_development.isForwardRef;
  var reactIs_development_20 = reactIs_development.isFragment;
  var reactIs_development_21 = reactIs_development.isLazy;
  var reactIs_development_22 = reactIs_development.isMemo;
  var reactIs_development_23 = reactIs_development.isPortal;
  var reactIs_development_24 = reactIs_development.isProfiler;
  var reactIs_development_25 = reactIs_development.isStrictMode;
  var reactIs_development_26 = reactIs_development.isSuspense;
  var reactIs_development_27 = reactIs_development.isValidElementType;
  var reactIs_development_28 = reactIs_development.typeOf;

  var reactIs = createCommonjsModule(function (module) {

  {
    module.exports = reactIs_development;
  }
  });
  var reactIs_1 = reactIs.isFragment;

  function toArray(children) {
    var ret = [];
    React__default.Children.forEach(children, function (child) {
      if (child === undefined || child === null) {
        return;
      }

      if (Array.isArray(child)) {
        ret = ret.concat(toArray(child));
      } else if (reactIs_1(child) && child.props) {
        ret = ret.concat(toArray(child.props.children));
      } else {
        ret.push(child);
      }
    });
    return ret;
  }

  /* eslint-disable no-console */
  var warned = {};
  function warning(valid, message) {
    // Support uglify
    if ( !valid && console !== undefined) {
      console.error("Warning: ".concat(message));
    }
  }
  function call(method, valid, message) {
    if (!valid && !warned[message]) {
      method(false, message);
      warned[message] = true;
    }
  }
  function warningOnce(valid, message) {
    call(warning, valid, message);
  }
  /* eslint-enable */

  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var warning$1 = function() {};

  {
    var printWarning = function printWarning(format, args) {
      var len = arguments.length;
      args = new Array(len > 1 ? len - 1 : 0);
      for (var key = 1; key < len; key++) {
        args[key - 1] = arguments[key];
      }
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning$1 = function(condition, format, args) {
      var len = arguments.length;
      args = new Array(len > 2 ? len - 2 : 0);
      for (var key = 2; key < len; key++) {
        args[key - 2] = arguments[key];
      }
      if (format === undefined) {
        throw new Error(
            '`warning(condition, format, ...args)` requires a warning ' +
            'message argument'
        );
      }
      if (!condition) {
        printWarning.apply(null, [format].concat(args));
      }
    };
  }

  var warning_1 = warning$1;

  var HOOK_MARK = 'RC_FORM_INTERNAL_HOOKS'; // eslint-disable-next-line @typescript-eslint/no-explicit-any

  var warningFunc = function warningFunc() {
    warning_1(false, 'Can not find FormContext. Please make sure you wrap Field under Form.');
  };

  var Context = React.createContext({
    getFieldValue: warningFunc,
    getFieldsValue: warningFunc,
    getFieldError: warningFunc,
    getFieldsError: warningFunc,
    isFieldsTouched: warningFunc,
    isFieldTouched: warningFunc,
    isFieldValidating: warningFunc,
    isFieldsValidating: warningFunc,
    resetFields: warningFunc,
    setFields: warningFunc,
    setFieldsValue: warningFunc,
    validateFields: warningFunc,
    submit: warningFunc,
    getInternalHooks: function getInternalHooks() {
      warningFunc();
      return {
        dispatch: warningFunc,
        registerField: warningFunc,
        useSubscribe: warningFunc,
        setInitialValues: warningFunc,
        setCallbacks: warningFunc,
        getFields: warningFunc,
        setValidateMessages: warningFunc
      };
    }
  });

  function toArray$1(value) {
    if (value === undefined || value === null) {
      return [];
    }

    return Array.isArray(value) ? value : [value];
  }

  var runtime_1 = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var runtime = (function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);

      return generator;
    }
    exports.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunctionPrototype[toStringTagSymbol] =
      GeneratorFunction.displayName = "GeneratorFunction";

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        prototype[method] = function(arg) {
          return this._invoke(method, arg);
        };
      });
    }

    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };

    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        if (!(toStringTagSymbol in genFun)) {
          genFun[toStringTagSymbol] = "GeneratorFunction";
        }
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    exports.awrap = function(arg) {
      return { __await: arg };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };
    exports.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;

      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList),
        PromiseImpl
      );

      return exports.isGeneratorFunction(outerFn)
        ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;

      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;

          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);

          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;

          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };

          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }

      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);

    Gp[toStringTagSymbol] = "Generator";

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function() {
      return this;
    };

    Gp.toString = function() {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;

            return next;
          };

          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return { next: doneResult };
    }
    exports.values = values;

    function doneResult() {
      return { value: undefined$1, done: true };
    }

    Context.prototype = {
      constructor: Context,

      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;

        this.method = "next";
        this.arg = undefined$1;

        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },

      stop: function() {
        this.done = true;

        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },

      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !! caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }

            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },

      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },

      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },

      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },

      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },

      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    };

    // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.
    return exports;

  }(
    // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
     module.exports 
  ));

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
  });

  var regenerator = runtime_1;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$1.apply(this, arguments);
  }

  /* eslint no-console:0 */
  var formatRegExp = /%[sdj%]/g;
  var warning$2 = function warning() {}; // don't print warning message when in production env or node runtime

  if (typeof process !== 'undefined' && process.env && "development" !== 'production' && typeof window !== 'undefined' && typeof document !== 'undefined') {
    warning$2 = function warning(type, errors) {
      if (typeof console !== 'undefined' && console.warn) {
        if (errors.every(function (e) {
          return typeof e === 'string';
        })) {
          console.warn(type, errors);
        }
      }
    };
  }

  function convertFieldsError(errors) {
    if (!errors || !errors.length) return null;
    var fields = {};
    errors.forEach(function (error) {
      var field = error.field;
      fields[field] = fields[field] || [];
      fields[field].push(error);
    });
    return fields;
  }
  function format() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var i = 1;
    var f = args[0];
    var len = args.length;

    if (typeof f === 'function') {
      return f.apply(null, args.slice(1));
    }

    if (typeof f === 'string') {
      var str = String(f).replace(formatRegExp, function (x) {
        if (x === '%%') {
          return '%';
        }

        if (i >= len) {
          return x;
        }

        switch (x) {
          case '%s':
            return String(args[i++]);

          case '%d':
            return Number(args[i++]);

          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }

            break;

          default:
            return x;
        }
      });

      for (var arg = args[i]; i < len; arg = args[++i]) {
        str += " " + arg;
      }

      return str;
    }

    return f;
  }

  function isNativeStringType(type) {
    return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'pattern';
  }

  function isEmptyValue(value, type) {
    if (value === undefined || value === null) {
      return true;
    }

    if (type === 'array' && Array.isArray(value) && !value.length) {
      return true;
    }

    if (isNativeStringType(type) && typeof value === 'string' && !value) {
      return true;
    }

    return false;
  }

  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;

    function count(errors) {
      results.push.apply(results, errors);
      total++;

      if (total === arrLength) {
        callback(results);
      }
    }

    arr.forEach(function (a) {
      func(a, count);
    });
  }

  function asyncSerialArray(arr, func, callback) {
    var index = 0;
    var arrLength = arr.length;

    function next(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }

      var original = index;
      index = index + 1;

      if (original < arrLength) {
        func(arr[original], next);
      } else {
        callback([]);
      }
    }

    next([]);
  }

  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function (k) {
      ret.push.apply(ret, objArr[k]);
    });
    return ret;
  }

  function asyncMap(objArr, option, func, callback) {
    if (option.first) {
      var _pending = new Promise(function (resolve, reject) {
        var next = function next(errors) {
          callback(errors);
          return errors.length ? reject({
            errors: errors,
            fields: convertFieldsError(errors)
          }) : resolve();
        };

        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next);
      });

      _pending["catch"](function (e) {
        return e;
      });

      return _pending;
    }

    var firstFields = option.firstFields || [];

    if (firstFields === true) {
      firstFields = Object.keys(objArr);
    }

    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function (resolve, reject) {
      var next = function next(errors) {
        results.push.apply(results, errors);
        total++;

        if (total === objArrLength) {
          callback(results);
          return results.length ? reject({
            errors: results,
            fields: convertFieldsError(results)
          }) : resolve();
        }
      };

      if (!objArrKeys.length) {
        callback(results);
        resolve();
      }

      objArrKeys.forEach(function (key) {
        var arr = objArr[key];

        if (firstFields.indexOf(key) !== -1) {
          asyncSerialArray(arr, func, next);
        } else {
          asyncParallelArray(arr, func, next);
        }
      });
    });
    pending["catch"](function (e) {
      return e;
    });
    return pending;
  }
  function complementError(rule) {
    return function (oe) {
      if (oe && oe.message) {
        oe.field = oe.field || rule.fullField;
        return oe;
      }

      return {
        message: typeof oe === 'function' ? oe() : oe,
        field: oe.field || rule.fullField
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s in source) {
        if (source.hasOwnProperty(s)) {
          var value = source[s];

          if (typeof value === 'object' && typeof target[s] === 'object') {
            target[s] = _extends$1({}, target[s], {}, value);
          } else {
            target[s] = value;
          }
        }
      }
    }

    return target;
  }

  /**
   *  Rule for validating required fields.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function required(rule, value, source, errors, options, type) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
      errors.push(format(options.messages.required, rule.fullField));
    }
  }

  /**
   *  Rule for validating whitespace.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function whitespace(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === '') {
      errors.push(format(options.messages.whitespace, rule.fullField));
    }
  }

  /* eslint max-len:0 */

  var pattern = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
    url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", 'i'),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };
  var types = {
    integer: function integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    "float": function float(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
      return Array.isArray(value);
    },
    regexp: function regexp(value) {
      if (value instanceof RegExp) {
        return true;
      }

      try {
        return !!new RegExp(value);
      } catch (e) {
        return false;
      }
    },
    date: function date(value) {
      return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function';
    },
    number: function number(value) {
      if (isNaN(value)) {
        return false;
      }

      return typeof value === 'number';
    },
    object: function object(value) {
      return typeof value === 'object' && !types.array(value);
    },
    method: function method(value) {
      return typeof value === 'function';
    },
    email: function email(value) {
      return typeof value === 'string' && !!value.match(pattern.email) && value.length < 255;
    },
    url: function url(value) {
      return typeof value === 'string' && !!value.match(pattern.url);
    },
    hex: function hex(value) {
      return typeof value === 'string' && !!value.match(pattern.hex);
    }
  };
  /**
   *  Rule for validating the type of a value.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function type(rule, value, source, errors, options) {
    if (rule.required && value === undefined) {
      required(rule, value, source, errors, options);
      return;
    }

    var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
    var ruleType = rule.type;

    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      } // straight typeof check

    } else if (ruleType && typeof value !== rule.type) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  }

  /**
   *  Rule for validating minimum and maximum allowed values.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function range(rule, value, source, errors, options) {
    var len = typeof rule.len === 'number';
    var min = typeof rule.min === 'number';
    var max = typeof rule.max === 'number'; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）

    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key = null;
    var num = typeof value === 'number';
    var str = typeof value === 'string';
    var arr = Array.isArray(value);

    if (num) {
      key = 'number';
    } else if (str) {
      key = 'string';
    } else if (arr) {
      key = 'array';
    } // if the value is not of a supported type for range validation
    // the validation rule rule should use the
    // type property to also test for a particular type


    if (!key) {
      return false;
    }

    if (arr) {
      val = value.length;
    }

    if (str) {
      // 处理码点大于U+010000的文字length属性不准确的bug，如"𠮷𠮷𠮷".lenght !== 3
      val = value.replace(spRegexp, '_').length;
    }

    if (len) {
      if (val !== rule.len) {
        errors.push(format(options.messages[key].len, rule.fullField, rule.len));
      }
    } else if (min && !max && val < rule.min) {
      errors.push(format(options.messages[key].min, rule.fullField, rule.min));
    } else if (max && !min && val > rule.max) {
      errors.push(format(options.messages[key].max, rule.fullField, rule.max));
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
    }
  }

  var ENUM = 'enum';
  /**
   *  Rule for validating a value exists in an enumerable list.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function enumerable(rule, value, source, errors, options) {
    rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];

    if (rule[ENUM].indexOf(value) === -1) {
      errors.push(format(options.messages[ENUM], rule.fullField, rule[ENUM].join(', ')));
    }
  }

  /**
   *  Rule for validating a regular expression pattern.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function pattern$1(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        // if a RegExp instance is passed, reset `lastIndex` in case its `global`
        // flag is accidentally set to `true`, which in a validation scenario
        // is not necessary and the result might be misleading
        rule.pattern.lastIndex = 0;

        if (!rule.pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      } else if (typeof rule.pattern === 'string') {
        var _pattern = new RegExp(rule.pattern);

        if (!_pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      }
    }
  }

  var rules = {
    required: required,
    whitespace: whitespace,
    type: type,
    range: range,
    "enum": enumerable,
    pattern: pattern$1
  };

  /**
   *  Performs validation for string types.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function string(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value, 'string') && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options, 'string');

      if (!isEmptyValue(value, 'string')) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
        rules.pattern(rule, value, source, errors, options);

        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options);
        }
      }
    }

    callback(errors);
  }

  /**
   *  Validates a function.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function method(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates a number.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function number(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (value === '') {
        value = undefined;
      }

      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates a boolean.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function _boolean(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates the regular expression type.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function regexp(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates a number is an integer.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function integer(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates a number is a floating point number.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function floatFn(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates an array.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function array(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value, 'array') && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options, 'array');

      if (!isEmptyValue(value, 'array')) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates an object.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function object(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  var ENUM$1 = 'enum';
  /**
   *  Validates an enumerable list.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function enumerable$1(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules[ENUM$1](rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates a regular expression pattern.
   *
   *  Performs validation when a rule only contains
   *  a pattern property but is not declared as a string type.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function pattern$2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value, 'string') && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (!isEmptyValue(value, 'string')) {
        rules.pattern(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  function date(rule, value, callback, source, options) {
    // console.log('integer rule called %j', rule);
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (!isEmptyValue(value)) {
        var dateObject;

        if (typeof value === 'number') {
          dateObject = new Date(value);
        } else {
          dateObject = value;
        }

        rules.type(rule, dateObject, source, errors, options);

        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options);
        }
      }
    }

    callback(errors);
  }

  function required$1(rule, value, callback, source, options) {
    var errors = [];
    var type = Array.isArray(value) ? 'array' : typeof value;
    rules.required(rule, value, source, errors, options, type);
    callback(errors);
  }

  function type$1(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options, ruleType);

      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Performs validation for any type.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function any(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);
    }

    callback(errors);
  }

  var validators = {
    string: string,
    method: method,
    number: number,
    "boolean": _boolean,
    regexp: regexp,
    integer: integer,
    "float": floatFn,
    array: array,
    object: object,
    "enum": enumerable$1,
    pattern: pattern$2,
    date: date,
    url: type$1,
    hex: type$1,
    email: type$1,
    required: required$1,
    any: any
  };

  function newMessages() {
    return {
      "default": 'Validation error on field %s',
      required: '%s is required',
      "enum": '%s must be one of %s',
      whitespace: '%s cannot be empty',
      date: {
        format: '%s date %s is invalid for format %s',
        parse: '%s date could not be parsed, %s is invalid ',
        invalid: '%s date %s is invalid'
      },
      types: {
        string: '%s is not a %s',
        method: '%s is not a %s (function)',
        array: '%s is not an %s',
        object: '%s is not an %s',
        number: '%s is not a %s',
        date: '%s is not a %s',
        "boolean": '%s is not a %s',
        integer: '%s is not an %s',
        "float": '%s is not a %s',
        regexp: '%s is not a valid %s',
        email: '%s is not a valid %s',
        url: '%s is not a valid %s',
        hex: '%s is not a valid %s'
      },
      string: {
        len: '%s must be exactly %s characters',
        min: '%s must be at least %s characters',
        max: '%s cannot be longer than %s characters',
        range: '%s must be between %s and %s characters'
      },
      number: {
        len: '%s must equal %s',
        min: '%s cannot be less than %s',
        max: '%s cannot be greater than %s',
        range: '%s must be between %s and %s'
      },
      array: {
        len: '%s must be exactly %s in length',
        min: '%s cannot be less than %s in length',
        max: '%s cannot be greater than %s in length',
        range: '%s must be between %s and %s in length'
      },
      pattern: {
        mismatch: '%s value %s does not match pattern %s'
      },
      clone: function clone() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }
  var messages = newMessages();

  /**
   *  Encapsulates a validation schema.
   *
   *  @param descriptor An object declaring validation rules
   *  for this schema.
   */

  function Schema(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }

  Schema.prototype = {
    messages: function messages(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }

      return this._messages;
    },
    define: function define(rules) {
      if (!rules) {
        throw new Error('Cannot configure a schema with no rules');
      }

      if (typeof rules !== 'object' || Array.isArray(rules)) {
        throw new Error('Rules must be an object');
      }

      this.rules = {};
      var z;
      var item;

      for (z in rules) {
        if (rules.hasOwnProperty(z)) {
          item = rules[z];
          this.rules[z] = Array.isArray(item) ? item : [item];
        }
      }
    },
    validate: function validate(source_, o, oc) {
      var _this = this;

      if (o === void 0) {
        o = {};
      }

      if (oc === void 0) {
        oc = function oc() {};
      }

      var source = source_;
      var options = o;
      var callback = oc;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback();
        }

        return Promise.resolve();
      }

      function complete(results) {
        var i;
        var errors = [];
        var fields = {};

        function add(e) {
          if (Array.isArray(e)) {
            var _errors;

            errors = (_errors = errors).concat.apply(_errors, e);
          } else {
            errors.push(e);
          }
        }

        for (i = 0; i < results.length; i++) {
          add(results[i]);
        }

        if (!errors.length) {
          errors = null;
          fields = null;
        } else {
          fields = convertFieldsError(errors);
        }

        callback(errors, fields);
      }

      if (options.messages) {
        var messages$1 = this.messages();

        if (messages$1 === messages) {
          messages$1 = newMessages();
        }

        deepMerge(messages$1, options.messages);
        options.messages = messages$1;
      } else {
        options.messages = this.messages();
      }

      var arr;
      var value;
      var series = {};
      var keys = options.keys || Object.keys(this.rules);
      keys.forEach(function (z) {
        arr = _this.rules[z];
        value = source[z];
        arr.forEach(function (r) {
          var rule = r;

          if (typeof rule.transform === 'function') {
            if (source === source_) {
              source = _extends$1({}, source);
            }

            value = source[z] = rule.transform(value);
          }

          if (typeof rule === 'function') {
            rule = {
              validator: rule
            };
          } else {
            rule = _extends$1({}, rule);
          }

          rule.validator = _this.getValidationMethod(rule);
          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = _this.getType(rule);

          if (!rule.validator) {
            return;
          }

          series[z] = series[z] || [];
          series[z].push({
            rule: rule,
            value: value,
            source: source,
            field: z
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options, function (data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField === 'object');
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;

        function addFullfield(key, schema) {
          return _extends$1({}, schema, {
            fullField: rule.fullField + "." + key
          });
        }

        function cb(e) {
          if (e === void 0) {
            e = [];
          }

          var errors = e;

          if (!Array.isArray(errors)) {
            errors = [errors];
          }

          if (!options.suppressWarning && errors.length) {
            Schema.warning('async-validator:', errors);
          }

          if (errors.length && rule.message) {
            errors = [].concat(rule.message);
          }

          errors = errors.map(complementError(rule));

          if (options.first && errors.length) {
            errorFields[rule.field] = 1;
            return doIt(errors);
          }

          if (!deep) {
            doIt(errors);
          } else {
            // if rule is required but the target object
            // does not exist fail at the rule level and don't
            // go deeper
            if (rule.required && !data.value) {
              if (rule.message) {
                errors = [].concat(rule.message).map(complementError(rule));
              } else if (options.error) {
                errors = [options.error(rule, format(options.messages.required, rule.field))];
              } else {
                errors = [];
              }

              return doIt(errors);
            }

            var fieldsSchema = {};

            if (rule.defaultField) {
              for (var k in data.value) {
                if (data.value.hasOwnProperty(k)) {
                  fieldsSchema[k] = rule.defaultField;
                }
              }
            }

            fieldsSchema = _extends$1({}, fieldsSchema, {}, data.rule.fields);

            for (var f in fieldsSchema) {
              if (fieldsSchema.hasOwnProperty(f)) {
                var fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];
                fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));
              }
            }

            var schema = new Schema(fieldsSchema);
            schema.messages(options.messages);

            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }

            schema.validate(data.value, data.rule.options || options, function (errs) {
              var finalErrors = [];

              if (errors && errors.length) {
                finalErrors.push.apply(finalErrors, errors);
              }

              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, errs);
              }

              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }

        var res;

        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data.value, cb, data.source, options);
        } else if (rule.validator) {
          res = rule.validator(rule, data.value, cb, data.source, options);

          if (res === true) {
            cb();
          } else if (res === false) {
            cb(rule.message || rule.field + " fails");
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }

        if (res && res.then) {
          res.then(function () {
            return cb();
          }, function (e) {
            return cb(e);
          });
        }
      }, function (results) {
        complete(results);
      });
    },
    getType: function getType(rule) {
      if (rule.type === undefined && rule.pattern instanceof RegExp) {
        rule.type = 'pattern';
      }

      if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {
        throw new Error(format('Unknown rule type %s', rule.type));
      }

      return rule.type || 'string';
    },
    getValidationMethod: function getValidationMethod(rule) {
      if (typeof rule.validator === 'function') {
        return rule.validator;
      }

      var keys = Object.keys(rule);
      var messageIndex = keys.indexOf('message');

      if (messageIndex !== -1) {
        keys.splice(messageIndex, 1);
      }

      if (keys.length === 1 && keys[0] === 'required') {
        return validators.required;
      }

      return validators[this.getType(rule)] || false;
    }
  };

  Schema.register = function register(type, validator) {
    if (typeof validator !== 'function') {
      throw new Error('Cannot register a validator by type, validator is not a function');
    }

    validators[type] = validator;
  };

  Schema.warning = warning$2;
  Schema.messages = messages;

  function get(entity, path) {
    var current = entity;

    for (var i = 0; i < path.length; i += 1) {
      if (current === null || current === undefined) {
        return undefined;
      }

      current = current[path[i]];
    }

    return current;
  }

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _toConsumableArray$2(arr) { return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _nonIterableSpread$2(); }

  function _nonIterableSpread$2() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _arrayWithoutHoles$2(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _toArray(arr) { return _arrayWithHoles$1(arr) || _iterableToArray$2(arr) || _nonIterableRest$1(); }

  function _nonIterableRest$1() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArray$2(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithHoles$1(arr) { if (Array.isArray(arr)) return arr; }

  function set(entity, paths, value) {
    if (!paths.length) {
      return value;
    }

    var _paths = _toArray(paths),
        path = _paths[0],
        restPath = _paths.slice(1);

    var clone;

    if (!entity && typeof path === 'number') {
      clone = [];
    } else if (Array.isArray(entity)) {
      clone = _toConsumableArray$2(entity);
    } else {
      clone = _objectSpread({}, entity);
    }

    clone[path] = set(clone[path], restPath, value);
    return clone;
  }

  function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Convert name to internal supported format.
   * This function should keep since we still thinking if need support like `a.b.c` format.
   * 'a' => ['a']
   * 123 => [123]
   * ['a', 123] => ['a', 123]
   */

  function getNamePath(path) {
    return toArray$1(path);
  }
  function getValue(store, namePath) {
    var value = get(store, namePath);
    return value;
  }
  function setValue(store, namePath, value) {
    var newStore = set(store, namePath, value);
    return newStore;
  }
  function cloneByNamePathList(store, namePathList) {
    var newStore = {};
    namePathList.forEach(function (namePath) {
      var value = getValue(store, namePath);
      newStore = setValue(newStore, namePath, value);
    });
    return newStore;
  }
  function containsNamePath(namePathList, namePath) {
    return namePathList && namePathList.some(function (path) {
      return matchNamePath(path, namePath);
    });
  }

  function isObject(obj) {
    return _typeof(obj) === 'object' && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
  }
  /**
   * Copy values into store and return a new values object
   * ({ a: 1, b: { c: 2 } }, { a: 4, b: { d: 5 } }) => { a: 4, b: { c: 2, d: 5 } }
   */


  function internalSetValues(store, values) {
    var newStore = Array.isArray(store) ? _toConsumableArray$1(store) : _objectSpread$1({}, store);

    if (!values) {
      return newStore;
    }

    Object.keys(values).forEach(function (key) {
      var prevValue = newStore[key];
      var value = values[key]; // If both are object (but target is not array), we use recursion to set deep value

      var recursive = isObject(prevValue) && isObject(value);
      newStore[key] = recursive ? internalSetValues(prevValue, value || {}) : value;
    });
    return newStore;
  }

  function setValues(store) {
    for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      restValues[_key - 1] = arguments[_key];
    }

    return restValues.reduce(function (current, newStore) {
      return internalSetValues(current, newStore);
    }, store);
  }
  function matchNamePath(namePath, changedNamePath) {
    if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
      return false;
    }

    return namePath.every(function (nameUnit, i) {
      return changedNamePath[i] === nameUnit;
    });
  }
  function isSimilar(source, target) {
    if (source === target) {
      return true;
    }

    if (!source && target || source && !target) {
      return false;
    }

    if (!source || !target || _typeof(source) !== 'object' || _typeof(target) !== 'object') {
      return false;
    }

    var sourceKeys = Object.keys(source);
    var targetKeys = Object.keys(target);
    var keys = new Set([].concat(_toConsumableArray$1(sourceKeys), _toConsumableArray$1(targetKeys)));
    return _toConsumableArray$1(keys).every(function (key) {
      var sourceValue = source[key];
      var targetValue = target[key];

      if (typeof sourceValue === 'function' && typeof targetValue === 'function') {
        return true;
      }

      return sourceValue === targetValue;
    });
  }
  function defaultGetValueFromEvent(valuePropName) {
    var event = arguments.length <= 1 ? undefined : arguments[1];

    if (event && event.target && valuePropName in event.target) {
      return event.target[valuePropName];
    }

    return event;
  }
  /**
   * Moves an array item from one position in an array to another.
   *
   * Note: This is a pure function so a new array will be returned, instead
   * of altering the array argument.
   *
   * @param array         Array in which to move an item.         (required)
   * @param moveIndex     The index of the item to move.          (required)
   * @param toIndex       The index to move item at moveIndex to. (required)
   */

  function move(array, moveIndex, toIndex) {
    var length = array.length;

    if (moveIndex < 0 || moveIndex >= length || toIndex < 0 || toIndex >= length) {
      return array;
    }

    var item = array[moveIndex];
    var diff = moveIndex - toIndex;

    if (diff > 0) {
      // move left
      return [].concat(_toConsumableArray$1(array.slice(0, toIndex)), [item], _toConsumableArray$1(array.slice(toIndex, moveIndex)), _toConsumableArray$1(array.slice(moveIndex + 1, length)));
    }

    if (diff < 0) {
      // move right
      return [].concat(_toConsumableArray$1(array.slice(0, moveIndex)), _toConsumableArray$1(array.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray$1(array.slice(toIndex + 1, length)));
    }

    return array;
  }

  var typeTemplate = "'${name}' is not a valid ${type}";
  var defaultValidateMessages = {
    default: "Validation error on field '${name}'",
    required: "'${name}' is required",
    enum: "'${name}' must be one of [${enum}]",
    whitespace: "'${name}' cannot be empty",
    date: {
      format: "'${name}' is invalid for format date",
      parse: "'${name}' could not be parsed as date",
      invalid: "'${name}' is invalid date"
    },
    types: {
      string: typeTemplate,
      method: typeTemplate,
      array: typeTemplate,
      object: typeTemplate,
      number: typeTemplate,
      date: typeTemplate,
      boolean: typeTemplate,
      integer: typeTemplate,
      float: typeTemplate,
      regexp: typeTemplate,
      email: typeTemplate,
      url: typeTemplate,
      hex: typeTemplate
    },
    string: {
      len: "'${name}' must be exactly ${len} characters",
      min: "'${name}' must be at least ${min} characters",
      max: "'${name}' cannot be longer than ${max} characters",
      range: "'${name}' must be between ${min} and ${max} characters"
    },
    number: {
      len: "'${name}' must equal ${len}",
      min: "'${name}' cannot be less than ${min}",
      max: "'${name}' cannot be greater than ${max}",
      range: "'${name}' must be between ${min} and ${max}"
    },
    array: {
      len: "'${name}' must be exactly ${len} in length",
      min: "'${name}' cannot be less than ${min} in length",
      max: "'${name}' cannot be greater than ${max} in length",
      range: "'${name}' must be between ${min} and ${max} in length"
    },
    pattern: {
      mismatch: "'${name}' does not match pattern ${pattern}"
    }
  };

  function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  var AsyncValidator = Schema;
  /**
   * Replace with template.
   *   `I'm ${name}` + { name: 'bamboo' } = I'm bamboo
   */

  function replaceMessage(template, kv) {
    return template.replace(/\$\{\w+\}/g, function (str) {
      var key = str.slice(2, -1);
      return kv[key];
    });
  }
  /**
   * We use `async-validator` to validate rules. So have to hot replace the message with validator.
   * { required: '${name} is required' } => { required: () => 'field is required' }
   */


  function convertMessages(messages, name, rule, messageVariables) {
    var kv = _objectSpread$2({}, rule, {
      name: name,
      enum: (rule.enum || []).join(', ')
    });

    var replaceFunc = function replaceFunc(template, additionalKV) {
      return function () {
        return replaceMessage(template, _objectSpread$2({}, kv, {}, additionalKV));
      };
    };
    /* eslint-disable no-param-reassign */


    function fillTemplate(source) {
      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      Object.keys(source).forEach(function (ruleName) {
        var value = source[ruleName];

        if (typeof value === 'string') {
          target[ruleName] = replaceFunc(value, messageVariables);
        } else if (value && _typeof(value) === 'object') {
          target[ruleName] = {};
          fillTemplate(value, target[ruleName]);
        } else {
          target[ruleName] = value;
        }
      });
      return target;
    }
    /* eslint-enable */


    return fillTemplate(setValues({}, defaultValidateMessages, messages));
  }

  function validateRule(_x, _x2, _x3, _x4, _x5) {
    return _validateRule.apply(this, arguments);
  }
  /**
   * We use `async-validator` to validate the value.
   * But only check one value in a time to avoid namePath validate issue.
   */


  function _validateRule() {
    _validateRule = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(name, value, rule, options, messageVariables) {
      var cloneRule, subRuleField, validator, messages, result, subResults;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              cloneRule = _objectSpread$2({}, rule); // We should special handle array validate

              subRuleField = null;

              if (cloneRule && cloneRule.type === 'array' && cloneRule.defaultField) {
                subRuleField = cloneRule.defaultField;
                delete cloneRule.defaultField;
              }

              validator = new AsyncValidator(_defineProperty$1({}, name, [cloneRule]));
              messages = convertMessages(options.validateMessages, name, cloneRule, messageVariables);
              validator.messages(messages);
              result = [];
              _context.prev = 7;
              _context.next = 10;
              return Promise.resolve(validator.validate(_defineProperty$1({}, name, value), _objectSpread$2({}, options)));

            case 10:
              _context.next = 15;
              break;

            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](7);

              if (_context.t0.errors) {
                result = _context.t0.errors.map(function (_ref2, index) {
                  var message = _ref2.message;
                  return (// Wrap ReactNode with `key`
                    React.isValidElement(message) ? React.cloneElement(message, {
                      key: "error_".concat(index)
                    }) : message
                  );
                });
              } else {
                console.error(_context.t0);
                result = [messages.default()];
              }

            case 15:
              if (!(!result.length && subRuleField)) {
                _context.next = 20;
                break;
              }

              _context.next = 18;
              return Promise.all(value.map(function (subValue, i) {
                return validateRule("".concat(name, ".").concat(i), subValue, subRuleField, options, messageVariables);
              }));

            case 18:
              subResults = _context.sent;
              return _context.abrupt("return", subResults.reduce(function (prev, errors) {
                return [].concat(_toConsumableArray$1(prev), _toConsumableArray$1(errors));
              }, []));

            case 20:
              return _context.abrupt("return", result);

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[7, 12]]);
    }));
    return _validateRule.apply(this, arguments);
  }

  function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {
    var name = namePath.join('.'); // Fill rule with context

    var filledRules = rules.map(function (currentRule) {
      var originValidatorFunc = currentRule.validator;

      if (!originValidatorFunc) {
        return currentRule;
      }

      return _objectSpread$2({}, currentRule, {
        validator: function validator(rule, val, callback) {
          var hasPromise = false; // Wrap callback only accept when promise not provided

          var wrappedCallback = function wrappedCallback() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            // Wait a tick to make sure return type is a promise
            Promise.resolve().then(function () {
              warning_1(!hasPromise, 'Your validator function has already return a promise. `callback` will be ignored.');

              if (!hasPromise) {
                callback.apply(void 0, args);
              }
            });
          }; // Get promise


          var promise = originValidatorFunc(rule, val, wrappedCallback);
          hasPromise = promise && typeof promise.then === 'function' && typeof promise.catch === 'function';
          /**
           * 1. Use promise as the first priority.
           * 2. If promise not exist, use callback with warning instead
           */

          warning_1(hasPromise, '`callback` is deprecated. Please return a promise instead.');

          if (hasPromise) {
            promise.then(function () {
              callback();
            }).catch(function (err) {
              callback(err);
            });
          }
        }
      });
    });
    var rulePromises = filledRules.map(function (rule) {
      return validateRule(name, value, rule, options, messageVariables);
    });
    var summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function (errors) {
      if (!errors.length) {
        return [];
      }

      return Promise.reject(errors);
    }); // Internal catch error to avoid console error log.

    summaryPromise.catch(function (e) {
      return e;
    });
    return summaryPromise;
  }

  function finishOnAllFailed(_x6) {
    return _finishOnAllFailed.apply(this, arguments);
  }

  function _finishOnAllFailed() {
    _finishOnAllFailed = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(rulePromises) {
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", Promise.all(rulePromises).then(function (errorsList) {
                var _ref3;

                var errors = (_ref3 = []).concat.apply(_ref3, _toConsumableArray$1(errorsList));

                return errors;
              }));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _finishOnAllFailed.apply(this, arguments);
  }

  function finishOnFirstFailed(_x7) {
    return _finishOnFirstFailed.apply(this, arguments);
  }

  function _finishOnFirstFailed() {
    _finishOnFirstFailed = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(rulePromises) {
      var count;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              count = 0;
              return _context3.abrupt("return", new Promise(function (resolve) {
                rulePromises.forEach(function (promise) {
                  promise.then(function (errors) {
                    if (errors.length) {
                      resolve(errors);
                    }

                    count += 1;

                    if (count === rulePromises.length) {
                      resolve([]);
                    }
                  });
                });
              }));

            case 2:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _finishOnFirstFailed.apply(this, arguments);
  }

  function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {
    if (typeof shouldUpdate === 'function') {
      return shouldUpdate(prev, next, 'source' in info ? {
        source: info.source
      } : {});
    }

    return prevValue !== nextValue;
  } // We use Class instead of Hooks here since it will cost much code by using Hooks.


  var Field = /*#__PURE__*/function (_React$Component) {
    _inherits(Field, _React$Component);

    function Field() {
      var _this;

      _classCallCheck(this, Field);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Field).apply(this, arguments));
      _this.state = {
        resetCount: 0
      };
      _this.cancelRegisterFunc = null;
      _this.destroy = false;
      /**
       * Follow state should not management in State since it will async update by React.
       * This makes first render of form can not get correct state value.
       */

      _this.touched = false;
      _this.validatePromise = null;
      _this.errors = [];

      _this.cancelRegister = function () {
        if (_this.cancelRegisterFunc) {
          _this.cancelRegisterFunc();
        }

        _this.cancelRegisterFunc = null;
      }; // ================================== Utils ==================================


      _this.getNamePath = function () {
        var name = _this.props.name;
        var _this$context$prefixN = _this.context.prefixName,
            prefixName = _this$context$prefixN === void 0 ? [] : _this$context$prefixN;
        return name !== undefined ? [].concat(_toConsumableArray$1(prefixName), _toConsumableArray$1(name)) : [];
      };

      _this.getRules = function () {
        var _this$props$rules = _this.props.rules,
            rules = _this$props$rules === void 0 ? [] : _this$props$rules;
        return rules.map(function (rule) {
          if (typeof rule === 'function') {
            return rule(_this.context);
          }

          return rule;
        });
      };

      _this.refresh = function () {
        if (_this.destroy) return;
        /**
         * Clean up current node.
         */

        _this.setState(function (_ref) {
          var resetCount = _ref.resetCount;
          return {
            resetCount: resetCount + 1
          };
        });
      }; // ========================= Field Entity Interfaces =========================
      // Trigger by store update. Check if need update the component


      _this.onStoreChange = function (prevStore, namePathList, info) {
        var _this$props = _this.props,
            shouldUpdate = _this$props.shouldUpdate,
            _this$props$dependenc = _this$props.dependencies,
            dependencies = _this$props$dependenc === void 0 ? [] : _this$props$dependenc,
            onReset = _this$props.onReset;
        var getFieldsValue = _this.context.getFieldsValue;
        var values = getFieldsValue(true);

        var namePath = _this.getNamePath();

        var prevValue = _this.getValue(prevStore);

        var curValue = _this.getValue();

        var namePathMatch = namePathList && containsNamePath(namePathList, namePath); // `setFieldsValue` is a quick access to update related status

        if (info.type === 'valueUpdate' && info.source === 'external' && prevValue !== curValue) {
          _this.touched = true;
          _this.validatePromise = null;
          _this.errors = [];
        }

        switch (info.type) {
          case 'reset':
            if (!namePathList || namePathMatch) {
              // Clean up state
              _this.touched = false;
              _this.validatePromise = null;
              _this.errors = [];

              if (onReset) {
                onReset();
              }

              _this.refresh();

              return;
            }

            break;

          case 'setField':
            {
              if (namePathMatch) {
                var data = info.data;

                if ('touched' in data) {
                  _this.touched = data.touched;
                }

                if ('validating' in data) {
                  _this.validatePromise = data.validating ? Promise.resolve([]) : null;
                }

                if ('errors' in data) {
                  _this.errors = data.errors || [];
                }

                _this.reRender();

                return;
              } // Handle update by `setField` with `shouldUpdate`


              if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, values, prevValue, curValue, info)) {
                _this.reRender();

                return;
              }

              break;
            }

          case 'dependenciesUpdate':
            {
              /**
               * Trigger when marked `dependencies` updated. Related fields will all update
               */
              var dependencyList = dependencies.map(getNamePath);

              if (namePathMatch || dependencyList.some(function (dependency) {
                return containsNamePath(info.relatedFields, dependency);
              })) {
                _this.reRender();

                return;
              }

              break;
            }

          default:
            /**
             * - If `namePath` exists in `namePathList`, means it's related value and should update.
             * - If `dependencies` exists in `namePathList`, means upstream trigger update.
             * - If `shouldUpdate` provided, use customize logic to update the field
             *   - else to check if value changed
             */
            if (namePathMatch || dependencies.some(function (dependency) {
              return containsNamePath(namePathList, getNamePath(dependency));
            }) || requireUpdate(shouldUpdate, prevStore, values, prevValue, curValue, info)) {
              _this.reRender();

              return;
            }

            break;
        }

        if (shouldUpdate === true) {
          _this.reRender();
        }
      };

      _this.validateRules = function (options) {
        var _this$props2 = _this.props,
            _this$props2$validate = _this$props2.validateFirst,
            validateFirst = _this$props2$validate === void 0 ? false : _this$props2$validate,
            messageVariables = _this$props2.messageVariables;

        var _ref2 = options || {},
            triggerName = _ref2.triggerName;

        var namePath = _this.getNamePath();

        var filteredRules = _this.getRules();

        if (triggerName) {
          filteredRules = filteredRules.filter(function (rule) {
            var validateTrigger = rule.validateTrigger;

            if (!validateTrigger) {
              return true;
            }

            var triggerList = toArray$1(validateTrigger);
            return triggerList.includes(triggerName);
          });
        }

        var promise = validateRules(namePath, _this.getValue(), filteredRules, options, validateFirst, messageVariables);
        _this.validatePromise = promise;
        _this.errors = [];
        promise.catch(function (e) {
          return e;
        }).then(function () {
          var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          if (_this.validatePromise === promise) {
            _this.validatePromise = null;
            _this.errors = errors;

            _this.reRender();
          }
        });
        return promise;
      };

      _this.isFieldValidating = function () {
        return !!_this.validatePromise;
      };

      _this.isFieldTouched = function () {
        return _this.touched;
      };

      _this.getErrors = function () {
        return _this.errors;
      }; // ============================= Child Component =============================


      _this.getMeta = function () {
        // Make error & validating in cache to save perf
        _this.prevValidating = _this.isFieldValidating();
        var meta = {
          touched: _this.isFieldTouched(),
          validating: _this.prevValidating,
          errors: _this.errors,
          name: _this.getNamePath()
        };
        return meta;
      }; // Only return validate child node. If invalidate, will do nothing about field.


      _this.getOnlyChild = function (children) {
        // Support render props
        if (typeof children === 'function') {
          var meta = _this.getMeta();

          return _objectSpread$3({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.context)), {
            isFunction: true
          });
        } // Filed element only


        var childList = toArray(children);

        if (childList.length !== 1 || !React.isValidElement(childList[0])) {
          return {
            child: childList,
            isFunction: false
          };
        }

        return {
          child: childList[0],
          isFunction: false
        };
      }; // ============================== Field Control ==============================


      _this.getValue = function (store) {
        var getFieldsValue = _this.context.getFieldsValue;

        var namePath = _this.getNamePath();

        return getValue(store || getFieldsValue(true), namePath);
      };

      _this.getControlled = function () {
        var childProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var _this$props3 = _this.props,
            trigger = _this$props3.trigger,
            validateTrigger = _this$props3.validateTrigger,
            getValueFromEvent = _this$props3.getValueFromEvent,
            normalize = _this$props3.normalize,
            valuePropName = _this$props3.valuePropName;

        var namePath = _this.getNamePath();

        var _this$context = _this.context,
            getInternalHooks = _this$context.getInternalHooks,
            getFieldsValue = _this$context.getFieldsValue;

        var _getInternalHooks = getInternalHooks(HOOK_MARK),
            dispatch = _getInternalHooks.dispatch;

        var value = _this.getValue(); // eslint-disable-next-line @typescript-eslint/no-explicit-any


        var originTriggerFunc = childProps[trigger];

        var control = _objectSpread$3({}, childProps, _defineProperty$1({}, valuePropName, value)); // Add trigger


        control[trigger] = function () {
          // Mark as touched
          _this.touched = true;
          var newValue;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (getValueFromEvent) {
            newValue = getValueFromEvent.apply(void 0, args);
          } else {
            newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
          }

          if (normalize) {
            newValue = normalize(newValue, value, getFieldsValue(true));
          }

          dispatch({
            type: 'updateValue',
            namePath: namePath,
            value: newValue
          });

          if (originTriggerFunc) {
            originTriggerFunc.apply(void 0, args);
          }
        }; // Add validateTrigger


        var validateTriggerList = toArray$1(validateTrigger || []);
        validateTriggerList.forEach(function (triggerName) {
          // Wrap additional function of component, so that we can get latest value from store
          var originTrigger = control[triggerName];

          control[triggerName] = function () {
            if (originTrigger) {
              originTrigger.apply(void 0, arguments);
            } // Always use latest rules


            var rules = _this.props.rules;

            if (rules && rules.length) {
              // We dispatch validate to root,
              // since it will update related data with other field with same name
              dispatch({
                type: 'validateField',
                namePath: namePath,
                triggerName: triggerName
              });
            }
          };
        });
        return control;
      };

      return _this;
    } // ============================== Subscriptions ==============================


    _createClass(Field, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var getInternalHooks = this.context.getInternalHooks;

        var _getInternalHooks2 = getInternalHooks(HOOK_MARK),
            registerField = _getInternalHooks2.registerField;

        this.cancelRegisterFunc = registerField(this);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.cancelRegister();
        this.destroy = true;
      }
    }, {
      key: "reRender",
      value: function reRender() {
        if (this.destroy) return;
        this.forceUpdate();
      }
    }, {
      key: "render",
      value: function render() {
        var resetCount = this.state.resetCount;
        var children = this.props.children;

        var _this$getOnlyChild = this.getOnlyChild(children),
            child = _this$getOnlyChild.child,
            isFunction = _this$getOnlyChild.isFunction; // Not need to `cloneElement` since user can handle this in render function self


        var returnChildNode;

        if (isFunction) {
          returnChildNode = child;
        } else if (React.isValidElement(child)) {
          returnChildNode = React.cloneElement(child, this.getControlled(child.props));
        } else {
          warningOnce(!child, '`children` of Field is not validate ReactElement.');
          returnChildNode = child;
        }

        return React.createElement(React.Fragment, {
          key: resetCount
        }, returnChildNode);
      }
    }]);

    return Field;
  }(React.Component);

  Field.contextType = Context;
  Field.defaultProps = {
    trigger: 'onChange',
    validateTrigger: 'onChange',
    valuePropName: 'value'
  };

  var WrapperField = function WrapperField(_ref3) {
    var name = _ref3.name,
        restProps = _objectWithoutProperties$1(_ref3, ["name"]);

    var namePath = name !== undefined ? getNamePath(name) : undefined;
    return React.createElement(Field, Object.assign({
      key: "_".concat((namePath || []).join('_')),
      name: namePath
    }, restProps));
  };

  function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  var List = function List(_ref) {
    var name = _ref.name,
        children = _ref.children;
    var context = React.useContext(Context);
    var keyRef = React.useRef({
      keys: [],
      id: 0
    });
    var keyManager = keyRef.current; // User should not pass `children` as other type.

    if (typeof children !== 'function') {
      warning_1(false, 'Form.List only accepts function as children.');
      return null;
    }

    var parentPrefixName = getNamePath(context.prefixName) || [];
    var prefixName = [].concat(_toConsumableArray$1(parentPrefixName), _toConsumableArray$1(getNamePath(name)));

    var shouldUpdate = function shouldUpdate(prevValue, nextValue, _ref2) {
      var source = _ref2.source;

      if (source === 'internal') {
        return false;
      }

      return prevValue !== nextValue;
    };

    return React.createElement(Context.Provider, {
      value: _objectSpread$4({}, context, {
        prefixName: prefixName
      })
    }, React.createElement(WrapperField, {
      name: [],
      shouldUpdate: shouldUpdate
    }, function (_ref3) {
      var _ref3$value = _ref3.value,
          value = _ref3$value === void 0 ? [] : _ref3$value,
          onChange = _ref3.onChange;
      var getFieldValue = context.getFieldValue;

      var getNewValue = function getNewValue() {
        var values = getFieldValue(prefixName || []);
        return values || [];
      };
      /**
       * Always get latest value in case user update fields by `form` api.
       */


      var operations = {
        add: function add(defaultValue) {
          // Mapping keys
          keyManager.keys = [].concat(_toConsumableArray$1(keyManager.keys), [keyManager.id]);
          keyManager.id += 1;
          var newValue = getNewValue();
          onChange([].concat(_toConsumableArray$1(newValue), [defaultValue]));
        },
        remove: function remove(index) {
          var newValue = getNewValue(); // Do not handle out of range

          if (index < 0 || index >= newValue.length) {
            return;
          } // Update key mapping


          var newKeys = keyManager.keys.map(function (key, id) {
            if (id < index) {
              return key;
            }

            return keyManager.keys[id + 1];
          });
          keyManager.keys = newKeys.slice(0, -1); // Trigger store change

          onChange(newValue.filter(function (_, id) {
            return id !== index;
          }));
        },
        move: function move$1(from, to) {
          if (from === to) {
            return;
          }

          var newValue = getNewValue(); // Do not handle out of range

          if (from < 0 || from >= newValue.length || to < 0 || to >= newValue.length) {
            return;
          }

          keyManager.keys = move(keyManager.keys, from, to); // Trigger store change

          onChange(move(newValue, from, to));
        }
      };
      return children(value.map(function (__, index) {
        var key = keyManager.keys[index];

        if (key === undefined) {
          keyManager.keys[index] = keyManager.id;
          key = keyManager.keys[index];
          keyManager.id += 1;
        }

        return {
          name: index,
          key: key
        };
      }), operations);
    }));
  };

  function _arrayWithHoles$2(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit$1(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest$2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray$1(arr, i) {
    return _arrayWithHoles$2(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest$2();
  }

  function allPromiseFinish(promiseList) {
    var hasError = false;
    var count = promiseList.length;
    var results = [];

    if (!promiseList.length) {
      return Promise.resolve([]);
    }

    return new Promise(function (resolve, reject) {
      promiseList.forEach(function (promise, index) {
        promise.catch(function (e) {
          hasError = true;
          return e;
        }).then(function (result) {
          count -= 1;
          results[index] = result;

          if (count > 0) {
            return;
          }

          if (hasError) {
            reject(results);
          }

          resolve(results);
        });
      });
    });
  }

  /**
   * NameMap like a `Map` but accepts `string[]` as key.
   */

  var NameMap = /*#__PURE__*/function () {
    function NameMap() {
      _classCallCheck(this, NameMap);

      this.list = [];
    }

    _createClass(NameMap, [{
      key: "set",
      value: function set(key, value) {
        var index = this.list.findIndex(function (item) {
          return matchNamePath(item.key, key);
        });

        if (index !== -1) {
          this.list[index].value = value;
        } else {
          this.list.push({
            key: key,
            value: value
          });
        }
      }
    }, {
      key: "get",
      value: function get(key) {
        var result = this.list.find(function (item) {
          return matchNamePath(item.key, key);
        });
        return result && result.value;
      }
    }, {
      key: "update",
      value: function update(key, updater) {
        var origin = this.get(key);
        var next = updater(origin);

        if (!next) {
          this.delete(key);
        } else {
          this.set(key, next);
        }
      }
    }, {
      key: "delete",
      value: function _delete(key) {
        this.list = this.list.filter(function (item) {
          return !matchNamePath(item.key, key);
        });
      }
    }, {
      key: "map",
      value: function map(callback) {
        return this.list.map(callback);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var json = {};
        this.map(function (_ref) {
          var key = _ref.key,
              value = _ref.value;
          json[key.join('.')] = value;
          return null;
        });
        return json;
      }
    }]);

    return NameMap;
  }();

  function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var FormStore = function FormStore(forceRootUpdate) {
    var _this = this;

    _classCallCheck(this, FormStore);

    this.formHooked = false;
    this.subscribable = true;
    this.store = {};
    this.fieldEntities = [];
    this.initialValues = {};
    this.callbacks = {};
    this.validateMessages = null;
    this.lastValidatePromise = null;

    this.getForm = function () {
      return {
        getFieldValue: _this.getFieldValue,
        getFieldsValue: _this.getFieldsValue,
        getFieldError: _this.getFieldError,
        getFieldsError: _this.getFieldsError,
        isFieldsTouched: _this.isFieldsTouched,
        isFieldTouched: _this.isFieldTouched,
        isFieldValidating: _this.isFieldValidating,
        isFieldsValidating: _this.isFieldsValidating,
        resetFields: _this.resetFields,
        setFields: _this.setFields,
        setFieldsValue: _this.setFieldsValue,
        validateFields: _this.validateFields,
        submit: _this.submit,
        getInternalHooks: _this.getInternalHooks
      };
    }; // ======================== Internal Hooks ========================


    this.getInternalHooks = function (key) {
      if (key === HOOK_MARK) {
        _this.formHooked = true;
        return {
          dispatch: _this.dispatch,
          registerField: _this.registerField,
          useSubscribe: _this.useSubscribe,
          setInitialValues: _this.setInitialValues,
          setCallbacks: _this.setCallbacks,
          setValidateMessages: _this.setValidateMessages,
          getFields: _this.getFields
        };
      }

      warning_1(false, '`getInternalHooks` is internal usage. Should not call directly.');
      return null;
    };

    this.useSubscribe = function (subscribable) {
      _this.subscribable = subscribable;
    };
    /**
     * First time `setInitialValues` should update store with initial value
     */


    this.setInitialValues = function (initialValues, init) {
      _this.initialValues = initialValues || {};

      if (init) {
        _this.store = setValues({}, initialValues, _this.store);
      }
    };

    this.getInitialValue = function (namePath) {
      return getValue(_this.initialValues, namePath);
    };

    this.setCallbacks = function (callbacks) {
      _this.callbacks = callbacks;
    };

    this.setValidateMessages = function (validateMessages) {
      _this.validateMessages = validateMessages;
    };

    this.warningUnhooked = function () {
      if ( !_this.formHooked) {
        warning_1(false, 'Instance created by `useForm` is not connect to any Form element. Forget to pass `form` prop?');
      }
    }; // ============================ Fields ============================

    /**
     * Get registered field entities.
     * @param pure Only return field which has a `name`. Default: false
     */


    this.getFieldEntities = function () {
      var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!pure) {
        return _this.fieldEntities;
      }

      return _this.fieldEntities.filter(function (field) {
        return field.getNamePath().length;
      });
    };

    this.getFieldsMap = function () {
      var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var cache = new NameMap();

      _this.getFieldEntities(pure).forEach(function (field) {
        var namePath = field.getNamePath();
        cache.set(namePath, field);
      });

      return cache;
    };

    this.getFieldEntitiesForNamePathList = function (nameList) {
      if (!nameList) {
        return _this.getFieldEntities(true);
      }

      var cache = _this.getFieldsMap(true);

      return nameList.map(function (name) {
        var namePath = getNamePath(name);
        return cache.get(namePath) || {
          INVALIDATE_NAME_PATH: getNamePath(name)
        };
      });
    };

    this.getFieldsValue = function (nameList, filterFunc) {
      _this.warningUnhooked();

      if (nameList === true && !filterFunc) {
        return _this.store;
      }

      var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);

      var filteredNameList = [];
      fieldEntities.forEach(function (entity) {
        var namePath = 'INVALIDATE_NAME_PATH' in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();

        if (!filterFunc) {
          filteredNameList.push(namePath);
        } else {
          var meta = 'getMeta' in entity ? entity.getMeta() : null;

          if (filterFunc(meta)) {
            filteredNameList.push(namePath);
          }
        }
      });
      return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
    };

    this.getFieldValue = function (name) {
      _this.warningUnhooked();

      var namePath = getNamePath(name);
      return getValue(_this.store, namePath);
    };

    this.getFieldsError = function (nameList) {
      _this.warningUnhooked();

      var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);

      return fieldEntities.map(function (entity, index) {
        if (entity && !('INVALIDATE_NAME_PATH' in entity)) {
          return {
            name: entity.getNamePath(),
            errors: entity.getErrors()
          };
        }

        return {
          name: getNamePath(nameList[index]),
          errors: []
        };
      });
    };

    this.getFieldError = function (name) {
      _this.warningUnhooked();

      var namePath = getNamePath(name);

      var fieldError = _this.getFieldsError([namePath])[0];

      return fieldError.errors;
    };

    this.isFieldsTouched = function () {
      _this.warningUnhooked();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var arg0 = args[0],
          arg1 = args[1];
      var namePathList;
      var isAllFieldsTouched = false;

      if (args.length === 0) {
        namePathList = null;
      } else if (args.length === 1) {
        if (Array.isArray(arg0)) {
          namePathList = arg0.map(getNamePath);
          isAllFieldsTouched = false;
        } else {
          namePathList = null;
          isAllFieldsTouched = arg0;
        }
      } else {
        namePathList = arg0.map(getNamePath);
        isAllFieldsTouched = arg1;
      }

      var testTouched = function testTouched(field) {
        // Not provide `nameList` will check all the fields
        if (!namePathList) {
          return field.isFieldTouched();
        }

        var fieldNamePath = field.getNamePath();

        if (containsNamePath(namePathList, fieldNamePath)) {
          return field.isFieldTouched();
        }

        return isAllFieldsTouched;
      };

      return isAllFieldsTouched ? _this.getFieldEntities(true).every(testTouched) : _this.getFieldEntities(true).some(testTouched);
    };

    this.isFieldTouched = function (name) {
      _this.warningUnhooked();

      return _this.isFieldsTouched([name]);
    };

    this.isFieldsValidating = function (nameList) {
      _this.warningUnhooked();

      var fieldEntities = _this.getFieldEntities();

      if (!nameList) {
        return fieldEntities.some(function (testField) {
          return testField.isFieldValidating();
        });
      }

      var namePathList = nameList.map(getNamePath);
      return fieldEntities.some(function (testField) {
        var fieldNamePath = testField.getNamePath();
        return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
      });
    };

    this.isFieldValidating = function (name) {
      _this.warningUnhooked();

      return _this.isFieldsValidating([name]);
    };

    this.resetFields = function (nameList) {
      _this.warningUnhooked();

      var prevStore = _this.store;

      if (!nameList) {
        _this.store = setValues({}, _this.initialValues);

        _this.notifyObservers(prevStore, null, {
          type: 'reset'
        });

        return;
      } // Reset by `nameList`


      var namePathList = nameList.map(getNamePath);
      namePathList.forEach(function (namePath) {
        var initialValue = _this.getInitialValue(namePath);

        _this.store = setValue(_this.store, namePath, initialValue);
      });

      _this.notifyObservers(prevStore, namePathList, {
        type: 'reset'
      });
    };

    this.setFields = function (fields) {
      _this.warningUnhooked();

      var prevStore = _this.store;
      fields.forEach(function (fieldData) {
        var name = fieldData.name,
            errors = fieldData.errors,
            data = _objectWithoutProperties$1(fieldData, ["name", "errors"]);

        var namePath = getNamePath(name); // Value

        if ('value' in data) {
          _this.store = setValue(_this.store, namePath, data.value);
        }

        _this.notifyObservers(prevStore, [namePath], {
          type: 'setField',
          data: fieldData
        });
      });
    };

    this.getFields = function () {
      return _this.getFieldEntities(true).map(function (field) {
        var namePath = field.getNamePath();
        var meta = field.getMeta();
        return _objectSpread$5({}, meta, {
          name: namePath,
          value: _this.getFieldValue(namePath)
        });
      });
    }; // =========================== Observer ===========================


    this.registerField = function (entity) {
      _this.fieldEntities.push(entity);

      return function () {
        _this.fieldEntities = _this.fieldEntities.filter(function (item) {
          return item !== entity;
        });
      };
    };

    this.dispatch = function (action) {
      switch (action.type) {
        case 'updateValue':
          {
            var namePath = action.namePath,
                value = action.value;

            _this.updateValue(namePath, value);

            break;
          }

        case 'validateField':
          {
            var _namePath = action.namePath,
                triggerName = action.triggerName;

            _this.validateFields([_namePath], {
              triggerName: triggerName
            });

            break;
          }

      }
    };

    this.notifyObservers = function (prevStore, namePathList, info) {
      if (_this.subscribable) {
        _this.getFieldEntities().forEach(function (_ref) {
          var onStoreChange = _ref.onStoreChange;
          onStoreChange(prevStore, namePathList, info);
        });
      } else {
        _this.forceRootUpdate();
      }
    };

    this.updateValue = function (name, value) {
      var namePath = getNamePath(name);
      var prevStore = _this.store;
      _this.store = setValue(_this.store, namePath, value);

      _this.notifyObservers(prevStore, [namePath], {
        type: 'valueUpdate',
        source: 'internal'
      }); // Notify dependencies children with parent update


      var childrenFields = _this.getDependencyChildrenFields(namePath);

      _this.validateFields(childrenFields);

      _this.notifyObservers(prevStore, childrenFields, {
        type: 'dependenciesUpdate',
        relatedFields: [namePath].concat(_toConsumableArray$1(childrenFields))
      }); // trigger callback function


      var onValuesChange = _this.callbacks.onValuesChange;

      if (onValuesChange) {
        var changedValues = cloneByNamePathList(_this.store, [namePath]);
        onValuesChange(changedValues, _this.store);
      }

      _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray$1(childrenFields)));
    }; // Let all child Field get update.


    this.setFieldsValue = function (store) {
      _this.warningUnhooked();

      var prevStore = _this.store;

      if (store) {
        _this.store = setValues(_this.store, store);
      }

      _this.notifyObservers(prevStore, null, {
        type: 'valueUpdate',
        source: 'external'
      });
    };

    this.getDependencyChildrenFields = function (rootNamePath) {
      var children = new Set();
      var childrenFields = [];
      var dependencies2fields = new NameMap();
      /**
       * Generate maps
       * Can use cache to save perf if user report performance issue with this
       */

      _this.getFieldEntities().forEach(function (field) {
        var dependencies = field.props.dependencies;
        (dependencies || []).forEach(function (dependency) {
          var dependencyNamePath = getNamePath(dependency);
          dependencies2fields.update(dependencyNamePath, function () {
            var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();
            fields.add(field);
            return fields;
          });
        });
      });

      var fillChildren = function fillChildren(namePath) {
        var fields = dependencies2fields.get(namePath) || new Set();
        fields.forEach(function (field) {
          if (!children.has(field)) {
            children.add(field);
            var fieldNamePath = field.getNamePath();

            if (field.isFieldTouched() && fieldNamePath.length) {
              childrenFields.push(fieldNamePath);
              fillChildren(fieldNamePath);
            }
          }
        });
      };

      fillChildren(rootNamePath);
      return childrenFields;
    };

    this.triggerOnFieldsChange = function (namePathList) {
      var onFieldsChange = _this.callbacks.onFieldsChange;

      if (onFieldsChange) {
        var fields = _this.getFields();

        var changedFields = fields.filter(function (_ref2) {
          var fieldName = _ref2.name;
          return containsNamePath(namePathList, fieldName);
        });
        onFieldsChange(changedFields, fields);
      }
    }; // =========================== Validate ===========================


    this.validateFields = function (nameList, options) {
      _this.warningUnhooked();

      var provideNameList = !!nameList;
      var namePathList = provideNameList ? nameList.map(getNamePath) : []; // Collect result in promise list

      var promiseList = [];

      _this.getFieldEntities(true).forEach(function (field) {
        // Add field if not provide `nameList`
        if (!provideNameList) {
          namePathList.push(field.getNamePath());
        } // Skip if without rule


        if (!field.props.rules || !field.props.rules.length) {
          return;
        }

        var fieldNamePath = field.getNamePath(); // Add field validate rule in to promise list

        if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
          var promise = field.validateRules(_objectSpread$5({
            validateMessages: _objectSpread$5({}, defaultValidateMessages, {}, _this.validateMessages)
          }, options)); // Wrap promise with field

          promiseList.push(promise.then(function () {
            return {
              name: fieldNamePath,
              errors: []
            };
          }).catch(function (errors) {
            return Promise.reject({
              name: fieldNamePath,
              errors: errors
            });
          }));
        }
      });

      var summaryPromise = allPromiseFinish(promiseList);
      _this.lastValidatePromise = summaryPromise; // Notify fields with rule that validate has finished and need update

      summaryPromise.catch(function (results) {
        return results;
      }).then(function (results) {
        var resultNamePathList = results.map(function (_ref3) {
          var name = _ref3.name;
          return name;
        });

        _this.notifyObservers(_this.store, resultNamePathList, {
          type: 'validateFinish'
        });

        _this.triggerOnFieldsChange(resultNamePathList);
      });
      var returnPromise = summaryPromise.then(function () {
        if (_this.lastValidatePromise === summaryPromise) {
          return Promise.resolve(_this.getFieldsValue(namePathList));
        }

        return Promise.reject([]);
      }).catch(function (results) {
        var errorList = results.filter(function (result) {
          return result && result.errors.length;
        });
        return Promise.reject({
          values: _this.getFieldsValue(namePathList),
          errorFields: errorList,
          outOfDate: _this.lastValidatePromise !== summaryPromise
        });
      }); // Do not throw in console

      returnPromise.catch(function (e) {
        return e;
      });
      return returnPromise;
    }; // ============================ Submit ============================


    this.submit = function () {
      _this.warningUnhooked();

      _this.validateFields().then(function (values) {
        var onFinish = _this.callbacks.onFinish;

        if (onFinish) {
          try {
            onFinish(values);
          } catch (err) {
            // Should print error if user `onFinish` callback failed
            console.error(err);
          }
        }
      }).catch(function (e) {
        var onFinishFailed = _this.callbacks.onFinishFailed;

        if (onFinishFailed) {
          onFinishFailed(e);
        }
      });
    };

    this.forceRootUpdate = forceRootUpdate;
  };

  function useForm(form) {
    var formRef = React.useRef();

    var _React$useState = React.useState(),
        _React$useState2 = _slicedToArray$1(_React$useState, 2),
        forceUpdate = _React$useState2[1];

    if (!formRef.current) {
      if (form) {
        formRef.current = form;
      } else {
        // Create a new FormStore if not provided
        var forceReRender = function forceReRender() {
          forceUpdate({});
        };

        var formStore = new FormStore(forceReRender);
        formRef.current = formStore.getForm();
      }
    }

    return [formRef.current];
  }

  function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var FormContext = React.createContext({
    triggerFormChange: function triggerFormChange() {},
    triggerFormFinish: function triggerFormFinish() {},
    registerForm: function registerForm() {},
    unregisterForm: function unregisterForm() {}
  });

  var FormProvider = function FormProvider(_ref) {
    var validateMessages = _ref.validateMessages,
        onFormChange = _ref.onFormChange,
        onFormFinish = _ref.onFormFinish,
        children = _ref.children;
    var formContext = React.useContext(FormContext);
    var formsRef = React.useRef({});
    return React.createElement(FormContext.Provider, {
      value: _objectSpread$6({}, formContext, {
        validateMessages: _objectSpread$6({}, formContext.validateMessages, {}, validateMessages),
        // =========================================================
        // =                  Global Form Control                  =
        // =========================================================
        triggerFormChange: function triggerFormChange(name, changedFields) {
          if (onFormChange) {
            onFormChange(name, {
              changedFields: changedFields,
              forms: formsRef.current
            });
          }

          formContext.triggerFormChange(name, changedFields);
        },
        triggerFormFinish: function triggerFormFinish(name, values) {
          if (onFormFinish) {
            onFormFinish(name, {
              values: values,
              forms: formsRef.current
            });
          }

          formContext.triggerFormFinish(name, values);
        },
        registerForm: function registerForm(name, form) {
          if (name) {
            formsRef.current = _objectSpread$6({}, formsRef.current, _defineProperty$1({}, name, form));
          }

          formContext.registerForm(name, form);
        },
        unregisterForm: function unregisterForm(name) {
          var newForms = _objectSpread$6({}, formsRef.current);

          delete newForms[name];
          formsRef.current = newForms;
          formContext.unregisterForm(name);
        }
      })
    }, children);
  };

  function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  var Form = function Form(_ref, ref) {
    var name = _ref.name,
        initialValues = _ref.initialValues,
        fields = _ref.fields,
        form = _ref.form,
        children = _ref.children,
        _ref$component = _ref.component,
        Component = _ref$component === void 0 ? 'form' : _ref$component,
        validateMessages = _ref.validateMessages,
        onValuesChange = _ref.onValuesChange,
        _onFieldsChange = _ref.onFieldsChange,
        _onFinish = _ref.onFinish,
        onFinishFailed = _ref.onFinishFailed,
        restProps = _objectWithoutProperties$1(_ref, ["name", "initialValues", "fields", "form", "children", "component", "validateMessages", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"]);

    var formContext = React.useContext(FormContext); // We customize handle event since Context will makes all the consumer re-render:
    // https://reactjs.org/docs/context.html#contextprovider

    var _useForm = useForm(form),
        _useForm2 = _slicedToArray$1(_useForm, 1),
        formInstance = _useForm2[0];

    var _formInstance$getInte = formInstance.getInternalHooks(HOOK_MARK),
        useSubscribe = _formInstance$getInte.useSubscribe,
        setInitialValues = _formInstance$getInte.setInitialValues,
        setCallbacks = _formInstance$getInte.setCallbacks,
        setValidateMessages = _formInstance$getInte.setValidateMessages; // Pass ref with form instance


    React.useImperativeHandle(ref, function () {
      return formInstance;
    }); // Register form into Context

    React.useEffect(function () {
      formContext.registerForm(name, formInstance);
      return function () {
        formContext.unregisterForm(name);
      };
    }, [formContext, formInstance, name]); // Pass props to store

    setValidateMessages(_objectSpread$7({}, formContext.validateMessages, {}, validateMessages));
    setCallbacks({
      onValuesChange: onValuesChange,
      onFieldsChange: function onFieldsChange(changedFields) {
        formContext.triggerFormChange(name, changedFields);

        if (_onFieldsChange) {
          for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            rest[_key - 1] = arguments[_key];
          }

          _onFieldsChange.apply(void 0, [changedFields].concat(rest));
        }
      },
      onFinish: function onFinish(values) {
        formContext.triggerFormFinish(name, values);

        if (_onFinish) {
          _onFinish(values);
        }
      },
      onFinishFailed: onFinishFailed
    }); // Set initial value, init store value when first mount

    var mountRef = React.useRef(null);
    setInitialValues(initialValues, !mountRef.current);

    if (!mountRef.current) {
      mountRef.current = true;
    } // Prepare children by `children` type


    var childrenNode = children;
    var childrenRenderProps = typeof children === 'function';

    if (childrenRenderProps) {
      var values = formInstance.getFieldsValue(true);
      childrenNode = children(values, formInstance);
    } // Not use subscribe when using render props


    useSubscribe(!childrenRenderProps); // Listen if fields provided. We use ref to save prev data here to avoid additional render

    var prevFieldsRef = React.useRef();
    React.useEffect(function () {
      if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
        formInstance.setFields(fields || []);
      }

      prevFieldsRef.current = fields;
    }, [fields, formInstance]);
    var wrapperNode = React.createElement(Context.Provider, {
      value: formInstance
    }, childrenNode);

    if (Component === false) {
      return wrapperNode;
    }

    return React.createElement(Component, Object.assign({}, restProps, {
      onSubmit: function onSubmit(event) {
        event.preventDefault();
        event.stopPropagation();
        formInstance.submit();
      }
    }), wrapperNode);
  };

  var InternalForm = React.forwardRef(Form);
  var RefForm = InternalForm;
  RefForm.FormProvider = FormProvider;
  RefForm.Field = WrapperField;
  RefForm.List = List;
  RefForm.useForm = useForm;

  var hookCallback;

  function hooks () {
      return hookCallback.apply(null, arguments);
  }

  // This is done to register the method called with moment()
  // without creating circular dependencies.
  function setHookCallback (callback) {
      hookCallback = callback;
  }

  function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
  }

  function isObject$1(input) {
      // IE8 will treat undefined and null as object if it wasn't for
      // input != null
      return input != null && Object.prototype.toString.call(input) === '[object Object]';
  }

  function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
          return (Object.getOwnPropertyNames(obj).length === 0);
      } else {
          var k;
          for (k in obj) {
              if (obj.hasOwnProperty(k)) {
                  return false;
              }
          }
          return true;
      }
  }

  function isUndefined(input) {
      return input === void 0;
  }

  function isNumber(input) {
      return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
  }

  function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
  }

  function map(arr, fn) {
      var res = [], i;
      for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i));
      }
      return res;
  }

  function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
  }

  function extend(a, b) {
      for (var i in b) {
          if (hasOwnProp(b, i)) {
              a[i] = b[i];
          }
      }

      if (hasOwnProp(b, 'toString')) {
          a.toString = b.toString;
      }

      if (hasOwnProp(b, 'valueOf')) {
          a.valueOf = b.valueOf;
      }

      return a;
  }

  function createUTC (input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, true).utc();
  }

  function defaultParsingFlags() {
      // We need to deep clone this object.
      return {
          empty           : false,
          unusedTokens    : [],
          unusedInput     : [],
          overflow        : -2,
          charsLeftOver   : 0,
          nullInput       : false,
          invalidMonth    : null,
          invalidFormat   : false,
          userInvalidated : false,
          iso             : false,
          parsedDateParts : [],
          meridiem        : null,
          rfc2822         : false,
          weekdayMismatch : false
      };
  }

  function getParsingFlags(m) {
      if (m._pf == null) {
          m._pf = defaultParsingFlags();
      }
      return m._pf;
  }

  var some;
  if (Array.prototype.some) {
      some = Array.prototype.some;
  } else {
      some = function (fun) {
          var t = Object(this);
          var len = t.length >>> 0;

          for (var i = 0; i < len; i++) {
              if (i in t && fun.call(this, t[i], i, t)) {
                  return true;
              }
          }

          return false;
      };
  }

  function isValid(m) {
      if (m._isValid == null) {
          var flags = getParsingFlags(m);
          var parsedParts = some.call(flags.parsedDateParts, function (i) {
              return i != null;
          });
          var isNowValid = !isNaN(m._d.getTime()) &&
              flags.overflow < 0 &&
              !flags.empty &&
              !flags.invalidMonth &&
              !flags.invalidWeekday &&
              !flags.weekdayMismatch &&
              !flags.nullInput &&
              !flags.invalidFormat &&
              !flags.userInvalidated &&
              (!flags.meridiem || (flags.meridiem && parsedParts));

          if (m._strict) {
              isNowValid = isNowValid &&
                  flags.charsLeftOver === 0 &&
                  flags.unusedTokens.length === 0 &&
                  flags.bigHour === undefined;
          }

          if (Object.isFrozen == null || !Object.isFrozen(m)) {
              m._isValid = isNowValid;
          }
          else {
              return isNowValid;
          }
      }
      return m._isValid;
  }

  function createInvalid (flags) {
      var m = createUTC(NaN);
      if (flags != null) {
          extend(getParsingFlags(m), flags);
      }
      else {
          getParsingFlags(m).userInvalidated = true;
      }

      return m;
  }

  // Plugins that add properties should also add the key here (null value),
  // so we can properly clone ourselves.
  var momentProperties = hooks.momentProperties = [];

  function copyConfig(to, from) {
      var i, prop, val;

      if (!isUndefined(from._isAMomentObject)) {
          to._isAMomentObject = from._isAMomentObject;
      }
      if (!isUndefined(from._i)) {
          to._i = from._i;
      }
      if (!isUndefined(from._f)) {
          to._f = from._f;
      }
      if (!isUndefined(from._l)) {
          to._l = from._l;
      }
      if (!isUndefined(from._strict)) {
          to._strict = from._strict;
      }
      if (!isUndefined(from._tzm)) {
          to._tzm = from._tzm;
      }
      if (!isUndefined(from._isUTC)) {
          to._isUTC = from._isUTC;
      }
      if (!isUndefined(from._offset)) {
          to._offset = from._offset;
      }
      if (!isUndefined(from._pf)) {
          to._pf = getParsingFlags(from);
      }
      if (!isUndefined(from._locale)) {
          to._locale = from._locale;
      }

      if (momentProperties.length > 0) {
          for (i = 0; i < momentProperties.length; i++) {
              prop = momentProperties[i];
              val = from[prop];
              if (!isUndefined(val)) {
                  to[prop] = val;
              }
          }
      }

      return to;
  }

  var updateInProgress = false;

  // Moment prototype object
  function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (!this.isValid()) {
          this._d = new Date(NaN);
      }
      // Prevent infinite loop in case updateOffset creates new moment
      // objects.
      if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
      }
  }

  function isMoment (obj) {
      return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
  }

  function absFloor (number) {
      if (number < 0) {
          // -0 -> 0
          return Math.ceil(number) || 0;
      } else {
          return Math.floor(number);
      }
  }

  function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion,
          value = 0;

      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
      }

      return value;
  }

  // compare two arrays, return the number of differences
  function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length),
          lengthDiff = Math.abs(array1.length - array2.length),
          diffs = 0,
          i;
      for (i = 0; i < len; i++) {
          if ((dontConvert && array1[i] !== array2[i]) ||
              (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
              diffs++;
          }
      }
      return diffs + lengthDiff;
  }

  function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false &&
              (typeof console !==  'undefined') && console.warn) {
          console.warn('Deprecation warning: ' + msg);
      }
  }

  function deprecate(msg, fn) {
      var firstTime = true;

      return extend(function () {
          if (hooks.deprecationHandler != null) {
              hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
              var args = [];
              var arg;
              for (var i = 0; i < arguments.length; i++) {
                  arg = '';
                  if (typeof arguments[i] === 'object') {
                      arg += '\n[' + i + '] ';
                      for (var key in arguments[0]) {
                          arg += key + ': ' + arguments[0][key] + ', ';
                      }
                      arg = arg.slice(0, -2); // Remove trailing comma and space
                  } else {
                      arg = arguments[i];
                  }
                  args.push(arg);
              }
              warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
              firstTime = false;
          }
          return fn.apply(this, arguments);
      }, fn);
  }

  var deprecations = {};

  function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
      }
      if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
      }
  }

  hooks.suppressDeprecationWarnings = false;
  hooks.deprecationHandler = null;

  function isFunction(input) {
      return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }

  function set$1 (config) {
      var prop, i;
      for (i in config) {
          prop = config[i];
          if (isFunction(prop)) {
              this[i] = prop;
          } else {
              this['_' + i] = prop;
          }
      }
      this._config = config;
      // Lenient ordinal parsing accepts just a number in addition to
      // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
      // TODO: Remove "ordinalParse" fallback in next major release.
      this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
              '|' + (/\d{1,2}/).source);
  }

  function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig), prop;
      for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
              if (isObject$1(parentConfig[prop]) && isObject$1(childConfig[prop])) {
                  res[prop] = {};
                  extend(res[prop], parentConfig[prop]);
                  extend(res[prop], childConfig[prop]);
              } else if (childConfig[prop] != null) {
                  res[prop] = childConfig[prop];
              } else {
                  delete res[prop];
              }
          }
      }
      for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) &&
                  !hasOwnProp(childConfig, prop) &&
                  isObject$1(parentConfig[prop])) {
              // make sure changes to properties don't modify parent config
              res[prop] = extend({}, res[prop]);
          }
      }
      return res;
  }

  function Locale(config) {
      if (config != null) {
          this.set(config);
      }
  }

  var keys;

  if (Object.keys) {
      keys = Object.keys;
  } else {
      keys = function (obj) {
          var i, res = [];
          for (i in obj) {
              if (hasOwnProp(obj, i)) {
                  res.push(i);
              }
          }
          return res;
      };
  }

  var defaultCalendar = {
      sameDay : '[Today at] LT',
      nextDay : '[Tomorrow at] LT',
      nextWeek : 'dddd [at] LT',
      lastDay : '[Yesterday at] LT',
      lastWeek : '[Last] dddd [at] LT',
      sameElse : 'L'
  };

  function calendar (key, mom, now) {
      var output = this._calendar[key] || this._calendar['sameElse'];
      return isFunction(output) ? output.call(mom, now) : output;
  }

  var defaultLongDateFormat = {
      LTS  : 'h:mm:ss A',
      LT   : 'h:mm A',
      L    : 'MM/DD/YYYY',
      LL   : 'MMMM D, YYYY',
      LLL  : 'MMMM D, YYYY h:mm A',
      LLLL : 'dddd, MMMM D, YYYY h:mm A'
  };

  function longDateFormat (key) {
      var format = this._longDateFormat[key],
          formatUpper = this._longDateFormat[key.toUpperCase()];

      if (format || !formatUpper) {
          return format;
      }

      this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
          return val.slice(1);
      });

      return this._longDateFormat[key];
  }

  var defaultInvalidDate = 'Invalid date';

  function invalidDate () {
      return this._invalidDate;
  }

  var defaultOrdinal = '%d';
  var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

  function ordinal (number) {
      return this._ordinal.replace('%d', number);
  }

  var defaultRelativeTime = {
      future : 'in %s',
      past   : '%s ago',
      s  : 'a few seconds',
      ss : '%d seconds',
      m  : 'a minute',
      mm : '%d minutes',
      h  : 'an hour',
      hh : '%d hours',
      d  : 'a day',
      dd : '%d days',
      M  : 'a month',
      MM : '%d months',
      y  : 'a year',
      yy : '%d years'
  };

  function relativeTime (number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return (isFunction(output)) ?
          output(number, withoutSuffix, string, isFuture) :
          output.replace(/%d/i, number);
  }

  function pastFuture (diff, output) {
      var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
      return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  }

  var aliases = {};

  function addUnitAlias (unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
  }

  function normalizeUnits(units) {
      return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
  }

  function normalizeObjectUnits(inputObject) {
      var normalizedInput = {},
          normalizedProp,
          prop;

      for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
              normalizedProp = normalizeUnits(prop);
              if (normalizedProp) {
                  normalizedInput[normalizedProp] = inputObject[prop];
              }
          }
      }

      return normalizedInput;
  }

  var priorities = {};

  function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
  }

  function getPrioritizedUnits(unitsObj) {
      var units = [];
      for (var u in unitsObj) {
          units.push({unit: u, priority: priorities[u]});
      }
      units.sort(function (a, b) {
          return a.priority - b.priority;
      });
      return units;
  }

  function zeroFill(number, targetLength, forceSign) {
      var absNumber = '' + Math.abs(number),
          zerosToFill = targetLength - absNumber.length,
          sign = number >= 0;
      return (sign ? (forceSign ? '+' : '') : '-') +
          Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }

  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

  var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

  var formatFunctions = {};

  var formatTokenFunctions = {};

  // token:    'M'
  // padded:   ['MM', 2]
  // ordinal:  'Mo'
  // callback: function () { this.month() + 1 }
  function addFormatToken (token, padded, ordinal, callback) {
      var func = callback;
      if (typeof callback === 'string') {
          func = function () {
              return this[callback]();
          };
      }
      if (token) {
          formatTokenFunctions[token] = func;
      }
      if (padded) {
          formatTokenFunctions[padded[0]] = function () {
              return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
      }
      if (ordinal) {
          formatTokenFunctions[ordinal] = function () {
              return this.localeData().ordinal(func.apply(this, arguments), token);
          };
      }
  }

  function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, '');
      }
      return input.replace(/\\/g, '');
  }

  function makeFormatFunction(format) {
      var array = format.match(formattingTokens), i, length;

      for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
              array[i] = formatTokenFunctions[array[i]];
          } else {
              array[i] = removeFormattingTokens(array[i]);
          }
      }

      return function (mom) {
          var output = '', i;
          for (i = 0; i < length; i++) {
              output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
          }
          return output;
      };
  }

  // format date using native date object
  function formatMoment(m, format) {
      if (!m.isValid()) {
          return m.localeData().invalidDate();
      }

      format = expandFormat(format, m.localeData());
      formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

      return formatFunctions[format](m);
  }

  function expandFormat(format, locale) {
      var i = 5;

      function replaceLongDateFormatTokens(input) {
          return locale.longDateFormat(input) || input;
      }

      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format)) {
          format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i -= 1;
      }

      return format;
  }

  var match1         = /\d/;            //       0 - 9
  var match2         = /\d\d/;          //      00 - 99
  var match3         = /\d{3}/;         //     000 - 999
  var match4         = /\d{4}/;         //    0000 - 9999
  var match6         = /[+-]?\d{6}/;    // -999999 - 999999
  var match1to2      = /\d\d?/;         //       0 - 99
  var match3to4      = /\d\d\d\d?/;     //     999 - 9999
  var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
  var match1to3      = /\d{1,3}/;       //       0 - 999
  var match1to4      = /\d{1,4}/;       //       0 - 9999
  var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

  var matchUnsigned  = /\d+/;           //       0 - inf
  var matchSigned    = /[+-]?\d+/;      //    -inf - inf

  var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
  var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

  var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

  // any word (or two) characters or numbers including two/three word month in arabic.
  // includes scottish gaelic two word and hyphenated months
  var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

  var regexes = {};

  function addRegexToken (token, regex, strictRegex) {
      regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
          return (isStrict && strictRegex) ? strictRegex : regex;
      };
  }

  function getParseRegexForToken (token, config) {
      if (!hasOwnProp(regexes, token)) {
          return new RegExp(unescapeFormat(token));
      }

      return regexes[token](config._strict, config._locale);
  }

  // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
  function unescapeFormat(s) {
      return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
      }));
  }

  function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }

  var tokens = {};

  function addParseToken (token, callback) {
      var i, func = callback;
      if (typeof token === 'string') {
          token = [token];
      }
      if (isNumber(callback)) {
          func = function (input, array) {
              array[callback] = toInt(input);
          };
      }
      for (i = 0; i < token.length; i++) {
          tokens[token[i]] = func;
      }
  }

  function addWeekParseToken (token, callback) {
      addParseToken(token, function (input, array, config, token) {
          config._w = config._w || {};
          callback(input, config._w, config, token);
      });
  }

  function addTimeToArrayFromToken(token, input, config) {
      if (input != null && hasOwnProp(tokens, token)) {
          tokens[token](input, config._a, config, token);
      }
  }

  var YEAR = 0;
  var MONTH = 1;
  var DATE = 2;
  var HOUR = 3;
  var MINUTE = 4;
  var SECOND = 5;
  var MILLISECOND = 6;
  var WEEK = 7;
  var WEEKDAY = 8;

  // FORMATTING

  addFormatToken('Y', 0, 0, function () {
      var y = this.year();
      return y <= 9999 ? '' + y : '+' + y;
  });

  addFormatToken(0, ['YY', 2], 0, function () {
      return this.year() % 100;
  });

  addFormatToken(0, ['YYYY',   4],       0, 'year');
  addFormatToken(0, ['YYYYY',  5],       0, 'year');
  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

  // ALIASES

  addUnitAlias('year', 'y');

  // PRIORITIES

  addUnitPriority('year', 1);

  // PARSING

  addRegexToken('Y',      matchSigned);
  addRegexToken('YY',     match1to2, match2);
  addRegexToken('YYYY',   match1to4, match4);
  addRegexToken('YYYYY',  match1to6, match6);
  addRegexToken('YYYYYY', match1to6, match6);

  addParseToken(['YYYYY', 'YYYYYY'], YEAR);
  addParseToken('YYYY', function (input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken('YY', function (input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken('Y', function (input, array) {
      array[YEAR] = parseInt(input, 10);
  });

  // HELPERS

  function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
  }

  function isLeapYear(year) {
      return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
  }

  // HOOKS

  hooks.parseTwoDigitYear = function (input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  };

  // MOMENTS

  var getSetYear = makeGetSet('FullYear', true);

  function getIsLeapYear () {
      return isLeapYear(this.year());
  }

  function makeGetSet (unit, keepTime) {
      return function (value) {
          if (value != null) {
              set$2(this, unit, value);
              hooks.updateOffset(this, keepTime);
              return this;
          } else {
              return get$1(this, unit);
          }
      };
  }

  function get$1 (mom, unit) {
      return mom.isValid() ?
          mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
  }

  function set$2 (mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
          if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
          }
          else {
              mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
          }
      }
  }

  // MOMENTS

  function stringGet (units) {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
          return this[units]();
      }
      return this;
  }


  function stringSet (units, value) {
      if (typeof units === 'object') {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units);
          for (var i = 0; i < prioritized.length; i++) {
              this[prioritized[i].unit](units[prioritized[i].unit]);
          }
      } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
              return this[units](value);
          }
      }
      return this;
  }

  function mod(n, x) {
      return ((n % x) + x) % x;
  }

  var indexOf;

  if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
  } else {
      indexOf = function (o) {
          // I know
          var i;
          for (i = 0; i < this.length; ++i) {
              if (this[i] === o) {
                  return i;
              }
          }
          return -1;
      };
  }

  function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
          return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
  }

  // FORMATTING

  addFormatToken('M', ['MM', 2], 'Mo', function () {
      return this.month() + 1;
  });

  addFormatToken('MMM', 0, 0, function (format) {
      return this.localeData().monthsShort(this, format);
  });

  addFormatToken('MMMM', 0, 0, function (format) {
      return this.localeData().months(this, format);
  });

  // ALIASES

  addUnitAlias('month', 'M');

  // PRIORITY

  addUnitPriority('month', 8);

  // PARSING

  addRegexToken('M',    match1to2);
  addRegexToken('MM',   match1to2, match2);
  addRegexToken('MMM',  function (isStrict, locale) {
      return locale.monthsShortRegex(isStrict);
  });
  addRegexToken('MMMM', function (isStrict, locale) {
      return locale.monthsRegex(isStrict);
  });

  addParseToken(['M', 'MM'], function (input, array) {
      array[MONTH] = toInt(input) - 1;
  });

  addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
      var month = config._locale.monthsParse(input, token, config._strict);
      // if we didn't find a month name, mark the date as invalid.
      if (month != null) {
          array[MONTH] = month;
      } else {
          getParsingFlags(config).invalidMonth = input;
      }
  });

  // LOCALES

  var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
  function localeMonths (m, format) {
      if (!m) {
          return isArray(this._months) ? this._months :
              this._months['standalone'];
      }
      return isArray(this._months) ? this._months[m.month()] :
          this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
  }

  var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
  function localeMonthsShort (m, format) {
      if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort :
              this._monthsShort['standalone'];
      }
      return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
          this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
  }

  function handleStrictParse(monthName, format, strict) {
      var i, ii, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
          // this is not used
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
              mom = createUTC([2000, i]);
              this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
              this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
          }
      }

      if (strict) {
          if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
          } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
          }
      } else {
          if (format === 'MMM') {
              ii = indexOf.call(this._shortMonthsParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._longMonthsParse, llc);
              return ii !== -1 ? ii : null;
          } else {
              ii = indexOf.call(this._longMonthsParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._shortMonthsParse, llc);
              return ii !== -1 ? ii : null;
          }
      }
  }

  function localeMonthsParse (monthName, format, strict) {
      var i, mom, regex;

      if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format, strict);
      }

      if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
      }

      // TODO: add sorting
      // Sorting makes sure if one month (or abbr) is a prefix of another
      // see sorting in computeMonthsParse
      for (i = 0; i < 12; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, i]);
          if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
              this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
          }
          if (!strict && !this._monthsParse[i]) {
              regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
              this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
          }
          // test the regex
          if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
              return i;
          } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
              return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
          }
      }
  }

  // MOMENTS

  function setMonth (mom, value) {
      var dayOfMonth;

      if (!mom.isValid()) {
          // No op
          return mom;
      }

      if (typeof value === 'string') {
          if (/^\d+$/.test(value)) {
              value = toInt(value);
          } else {
              value = mom.localeData().monthsParse(value);
              // TODO: Another silent failure?
              if (!isNumber(value)) {
                  return mom;
              }
          }
      }

      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
      mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
      return mom;
  }

  function getSetMonth (value) {
      if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
      } else {
          return get$1(this, 'Month');
      }
  }

  function getDaysInMonth () {
      return daysInMonth(this.year(), this.month());
  }

  var defaultMonthsShortRegex = matchWord;
  function monthsShortRegex (isStrict) {
      if (this._monthsParseExact) {
          if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
          }
          if (isStrict) {
              return this._monthsShortStrictRegex;
          } else {
              return this._monthsShortRegex;
          }
      } else {
          if (!hasOwnProp(this, '_monthsShortRegex')) {
              this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ?
              this._monthsShortStrictRegex : this._monthsShortRegex;
      }
  }

  var defaultMonthsRegex = matchWord;
  function monthsRegex (isStrict) {
      if (this._monthsParseExact) {
          if (!hasOwnProp(this, '_monthsRegex')) {
              computeMonthsParse.call(this);
          }
          if (isStrict) {
              return this._monthsStrictRegex;
          } else {
              return this._monthsRegex;
          }
      } else {
          if (!hasOwnProp(this, '_monthsRegex')) {
              this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ?
              this._monthsStrictRegex : this._monthsRegex;
      }
  }

  function computeMonthsParse () {
      function cmpLenRev(a, b) {
          return b.length - a.length;
      }

      var shortPieces = [], longPieces = [], mixedPieces = [],
          i, mom;
      for (i = 0; i < 12; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, i]);
          shortPieces.push(this.monthsShort(mom, ''));
          longPieces.push(this.months(mom, ''));
          mixedPieces.push(this.months(mom, ''));
          mixedPieces.push(this.monthsShort(mom, ''));
      }
      // Sorting makes sure if one month (or abbr) is a prefix of another it
      // will match the longer piece.
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
      }
      for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
  }

  function createDate (y, m, d, h, M, s, ms) {
      // can't just apply() to create a date:
      // https://stackoverflow.com/q/181348
      var date;
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
              date.setFullYear(y);
          }
      } else {
          date = new Date(y, m, d, h, M, s, ms);
      }

      return date;
  }

  function createUTCDate (y) {
      var date;
      // the Date.UTC function remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
          var args = Array.prototype.slice.call(arguments);
          // preserve leap years using a full 400 year cycle, then reset
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
              date.setUTCFullYear(y);
          }
      } else {
          date = new Date(Date.UTC.apply(null, arguments));
      }

      return date;
  }

  // start-of-first-week - start-of-year
  function firstWeekOffset(year, dow, doy) {
      var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
          fwd = 7 + dow - doy,
          // first-week day local weekday -- which local weekday is fwd
          fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

      return -fwdlw + fwd - 1;
  }

  // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7,
          weekOffset = firstWeekOffset(year, dow, doy),
          dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
          resYear, resDayOfYear;

      if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
      } else {
          resYear = year;
          resDayOfYear = dayOfYear;
      }

      return {
          year: resYear,
          dayOfYear: resDayOfYear
      };
  }

  function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy),
          week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
          resWeek, resYear;

      if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
      } else {
          resYear = mom.year();
          resWeek = week;
      }

      return {
          week: resWeek,
          year: resYear
      };
  }

  function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy),
          weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  }

  // FORMATTING

  addFormatToken('w', ['ww', 2], 'wo', 'week');
  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

  // ALIASES

  addUnitAlias('week', 'w');
  addUnitAlias('isoWeek', 'W');

  // PRIORITIES

  addUnitPriority('week', 5);
  addUnitPriority('isoWeek', 5);

  // PARSING

  addRegexToken('w',  match1to2);
  addRegexToken('ww', match1to2, match2);
  addRegexToken('W',  match1to2);
  addRegexToken('WW', match1to2, match2);

  addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
      week[token.substr(0, 1)] = toInt(input);
  });

  // HELPERS

  // LOCALES

  function localeWeek (mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }

  var defaultLocaleWeek = {
      dow : 0, // Sunday is the first day of the week.
      doy : 6  // The week that contains Jan 6th is the first week of the year.
  };

  function localeFirstDayOfWeek () {
      return this._week.dow;
  }

  function localeFirstDayOfYear () {
      return this._week.doy;
  }

  // MOMENTS

  function getSetWeek (input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, 'd');
  }

  function getSetISOWeek (input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, 'd');
  }

  // FORMATTING

  addFormatToken('d', 0, 'do', 'day');

  addFormatToken('dd', 0, 0, function (format) {
      return this.localeData().weekdaysMin(this, format);
  });

  addFormatToken('ddd', 0, 0, function (format) {
      return this.localeData().weekdaysShort(this, format);
  });

  addFormatToken('dddd', 0, 0, function (format) {
      return this.localeData().weekdays(this, format);
  });

  addFormatToken('e', 0, 0, 'weekday');
  addFormatToken('E', 0, 0, 'isoWeekday');

  // ALIASES

  addUnitAlias('day', 'd');
  addUnitAlias('weekday', 'e');
  addUnitAlias('isoWeekday', 'E');

  // PRIORITY
  addUnitPriority('day', 11);
  addUnitPriority('weekday', 11);
  addUnitPriority('isoWeekday', 11);

  // PARSING

  addRegexToken('d',    match1to2);
  addRegexToken('e',    match1to2);
  addRegexToken('E',    match1to2);
  addRegexToken('dd',   function (isStrict, locale) {
      return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken('ddd',   function (isStrict, locale) {
      return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken('dddd',   function (isStrict, locale) {
      return locale.weekdaysRegex(isStrict);
  });

  addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
      var weekday = config._locale.weekdaysParse(input, token, config._strict);
      // if we didn't get a weekday name, mark the date as invalid
      if (weekday != null) {
          week.d = weekday;
      } else {
          getParsingFlags(config).invalidWeekday = input;
      }
  });

  addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
      week[token] = toInt(input);
  });

  // HELPERS

  function parseWeekday(input, locale) {
      if (typeof input !== 'string') {
          return input;
      }

      if (!isNaN(input)) {
          return parseInt(input, 10);
      }

      input = locale.weekdaysParse(input);
      if (typeof input === 'number') {
          return input;
      }

      return null;
  }

  function parseIsoWeekday(input, locale) {
      if (typeof input === 'string') {
          return locale.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
  }

  // LOCALES
  function shiftWeekdays (ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
  }

  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
  function localeWeekdays (m, format) {
      var weekdays = isArray(this._weekdays) ? this._weekdays :
          this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
      return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
          : (m) ? weekdays[m.day()] : weekdays;
  }

  var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
  function localeWeekdaysShort (m) {
      return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
          : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
  }

  var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
  function localeWeekdaysMin (m) {
      return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
          : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
  }

  function handleStrictParse$1(weekdayName, format, strict) {
      var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];

          for (i = 0; i < 7; ++i) {
              mom = createUTC([2000, 1]).day(i);
              this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
              this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
              this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
          }
      }

      if (strict) {
          if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              return ii !== -1 ? ii : null;
          } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
          } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
          }
      } else {
          if (format === 'dddd') {
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
          } else if (format === 'ddd') {
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._minWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
          } else {
              ii = indexOf.call(this._minWeekdaysParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._weekdaysParse, llc);
              if (ii !== -1) {
                  return ii;
              }
              ii = indexOf.call(this._shortWeekdaysParse, llc);
              return ii !== -1 ? ii : null;
          }
      }
  }

  function localeWeekdaysParse (weekdayName, format, strict) {
      var i, mom, regex;

      if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format, strict);
      }

      if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
      }

      for (i = 0; i < 7; i++) {
          // make the regex if we don't have it already

          mom = createUTC([2000, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
              this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
              this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
              this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
          }
          if (!this._weekdaysParse[i]) {
              regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
              this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
          }
          // test the regex
          if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
              return i;
          } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
              return i;
          } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
              return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
              return i;
          }
      }
  }

  // MOMENTS

  function getSetDayOfWeek (input) {
      if (!this.isValid()) {
          return input != null ? this : NaN;
      }
      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, 'd');
      } else {
          return day;
      }
  }

  function getSetLocaleDayOfWeek (input) {
      if (!this.isValid()) {
          return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, 'd');
  }

  function getSetISODayOfWeek (input) {
      if (!this.isValid()) {
          return input != null ? this : NaN;
      }

      // behaves the same as moment#day except
      // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
      // as a setter, sunday should belong to the previous week.

      if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
          return this.day() || 7;
      }
  }

  var defaultWeekdaysRegex = matchWord;
  function weekdaysRegex (isStrict) {
      if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
          }
          if (isStrict) {
              return this._weekdaysStrictRegex;
          } else {
              return this._weekdaysRegex;
          }
      } else {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
              this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ?
              this._weekdaysStrictRegex : this._weekdaysRegex;
      }
  }

  var defaultWeekdaysShortRegex = matchWord;
  function weekdaysShortRegex (isStrict) {
      if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
          }
          if (isStrict) {
              return this._weekdaysShortStrictRegex;
          } else {
              return this._weekdaysShortRegex;
          }
      } else {
          if (!hasOwnProp(this, '_weekdaysShortRegex')) {
              this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ?
              this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
  }

  var defaultWeekdaysMinRegex = matchWord;
  function weekdaysMinRegex (isStrict) {
      if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
              computeWeekdaysParse.call(this);
          }
          if (isStrict) {
              return this._weekdaysMinStrictRegex;
          } else {
              return this._weekdaysMinRegex;
          }
      } else {
          if (!hasOwnProp(this, '_weekdaysMinRegex')) {
              this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ?
              this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
  }


  function computeWeekdaysParse () {
      function cmpLenRev(a, b) {
          return b.length - a.length;
      }

      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
          i, mom, minp, shortp, longp;
      for (i = 0; i < 7; i++) {
          // make the regex if we don't have it already
          mom = createUTC([2000, 1]).day(i);
          minp = this.weekdaysMin(mom, '');
          shortp = this.weekdaysShort(mom, '');
          longp = this.weekdays(mom, '');
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
      }
      // Sorting makes sure if one weekday (or abbr) is a prefix of another it
      // will match the longer piece.
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      for (i = 0; i < 7; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
          mixedPieces[i] = regexEscape(mixedPieces[i]);
      }

      this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;

      this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
      this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
  }

  // FORMATTING

  function hFormat() {
      return this.hours() % 12 || 12;
  }

  function kFormat() {
      return this.hours() || 24;
  }

  addFormatToken('H', ['HH', 2], 0, 'hour');
  addFormatToken('h', ['hh', 2], 0, hFormat);
  addFormatToken('k', ['kk', 2], 0, kFormat);

  addFormatToken('hmm', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });

  addFormatToken('hmmss', 0, 0, function () {
      return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
          zeroFill(this.seconds(), 2);
  });

  addFormatToken('Hmm', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2);
  });

  addFormatToken('Hmmss', 0, 0, function () {
      return '' + this.hours() + zeroFill(this.minutes(), 2) +
          zeroFill(this.seconds(), 2);
  });

  function meridiem (token, lowercase) {
      addFormatToken(token, 0, 0, function () {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
      });
  }

  meridiem('a', true);
  meridiem('A', false);

  // ALIASES

  addUnitAlias('hour', 'h');

  // PRIORITY
  addUnitPriority('hour', 13);

  // PARSING

  function matchMeridiem (isStrict, locale) {
      return locale._meridiemParse;
  }

  addRegexToken('a',  matchMeridiem);
  addRegexToken('A',  matchMeridiem);
  addRegexToken('H',  match1to2);
  addRegexToken('h',  match1to2);
  addRegexToken('k',  match1to2);
  addRegexToken('HH', match1to2, match2);
  addRegexToken('hh', match1to2, match2);
  addRegexToken('kk', match1to2, match2);

  addRegexToken('hmm', match3to4);
  addRegexToken('hmmss', match5to6);
  addRegexToken('Hmm', match3to4);
  addRegexToken('Hmmss', match5to6);

  addParseToken(['H', 'HH'], HOUR);
  addParseToken(['k', 'kk'], function (input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
  });
  addParseToken(['a', 'A'], function (input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
  });
  addParseToken(['h', 'hh'], function (input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
  });
  addParseToken('Hmm', function (input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken('Hmmss', function (input, array, config) {
      var pos1 = input.length - 4;
      var pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
  });

  // LOCALES

  function localeIsPM (input) {
      // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
      // Using charAt should be more compatible.
      return ((input + '').toLowerCase().charAt(0) === 'p');
  }

  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
  function localeMeridiem (hours, minutes, isLower) {
      if (hours > 11) {
          return isLower ? 'pm' : 'PM';
      } else {
          return isLower ? 'am' : 'AM';
      }
  }


  // MOMENTS

  // Setting the hour should keep the time, because the user explicitly
  // specified which hour they want. So trying to maintain the same hour (in
  // a new timezone) makes sense. Adding/subtracting hours does not follow
  // this rule.
  var getSetHour = makeGetSet('Hours', true);

  var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,

      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,

      week: defaultLocaleWeek,

      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,

      meridiemParse: defaultLocaleMeridiemParse
  };

  // internal storage for locale config files
  var locales = {};
  var localeFamilies = {};
  var globalLocale;

  function normalizeLocale(key) {
      return key ? key.toLowerCase().replace('_', '-') : key;
  }

  // pick the locale from the array
  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
  function chooseLocale(names) {
      var i = 0, j, next, locale, split;

      while (i < names.length) {
          split = normalizeLocale(names[i]).split('-');
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split('-') : null;
          while (j > 0) {
              locale = loadLocale(split.slice(0, j).join('-'));
              if (locale) {
                  return locale;
              }
              if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                  //the next array item is better than a shallower substring of this one
                  break;
              }
              j--;
          }
          i++;
      }
      return globalLocale;
  }

  function loadLocale(name) {
      var oldLocale = null;
      // TODO: Find a better way to register and load all the locales in Node
      if (!locales[name] && (typeof module !== 'undefined') &&
              module && module.exports) {
          try {
              oldLocale = globalLocale._abbr;
              var aliasedRequire = require;
              aliasedRequire('./locale/' + name);
              getSetGlobalLocale(oldLocale);
          } catch (e) {}
      }
      return locales[name];
  }

  // This function will load locale and then set the global locale.  If
  // no arguments are passed in, it will simply return the current global
  // locale key.
  function getSetGlobalLocale (key, values) {
      var data;
      if (key) {
          if (isUndefined(values)) {
              data = getLocale(key);
          }
          else {
              data = defineLocale(key, values);
          }

          if (data) {
              // moment.duration._locale = moment._locale = data;
              globalLocale = data;
          }
          else {
              if ((typeof console !==  'undefined') && console.warn) {
                  //warn user if arguments are passed but the locale could not be set
                  console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
              }
          }
      }

      return globalLocale._abbr;
  }

  function defineLocale (name, config) {
      if (config !== null) {
          var locale, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
              deprecateSimple('defineLocaleOverride',
                      'use moment.updateLocale(localeName, config) to change ' +
                      'an existing locale. moment.defineLocale(localeName, ' +
                      'config) should only be used for creating a new locale ' +
                      'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
              parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
              if (locales[config.parentLocale] != null) {
                  parentConfig = locales[config.parentLocale]._config;
              } else {
                  locale = loadLocale(config.parentLocale);
                  if (locale != null) {
                      parentConfig = locale._config;
                  } else {
                      if (!localeFamilies[config.parentLocale]) {
                          localeFamilies[config.parentLocale] = [];
                      }
                      localeFamilies[config.parentLocale].push({
                          name: name,
                          config: config
                      });
                      return null;
                  }
              }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));

          if (localeFamilies[name]) {
              localeFamilies[name].forEach(function (x) {
                  defineLocale(x.name, x.config);
              });
          }

          // backwards compat for now: also set the locale
          // make sure we set the locale AFTER all child locales have been
          // created, so we won't end up with the child locale set.
          getSetGlobalLocale(name);


          return locales[name];
      } else {
          // useful for testing
          delete locales[name];
          return null;
      }
  }

  function updateLocale(name, config) {
      if (config != null) {
          var locale, tmpLocale, parentConfig = baseConfig;
          // MERGE
          tmpLocale = loadLocale(name);
          if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          locale = new Locale(config);
          locale.parentLocale = locales[name];
          locales[name] = locale;

          // backwards compat for now: also set the locale
          getSetGlobalLocale(name);
      } else {
          // pass null for config to unupdate, useful for tests
          if (locales[name] != null) {
              if (locales[name].parentLocale != null) {
                  locales[name] = locales[name].parentLocale;
              } else if (locales[name] != null) {
                  delete locales[name];
              }
          }
      }
      return locales[name];
  }

  // returns locale data
  function getLocale (key) {
      var locale;

      if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
      }

      if (!key) {
          return globalLocale;
      }

      if (!isArray(key)) {
          //short-circuit everything else
          locale = loadLocale(key);
          if (locale) {
              return locale;
          }
          key = [key];
      }

      return chooseLocale(key);
  }

  function listLocales() {
      return keys(locales);
  }

  function checkOverflow (m) {
      var overflow;
      var a = m._a;

      if (a && getParsingFlags(m).overflow === -2) {
          overflow =
              a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
              a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
              a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
              a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
              a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
              a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
              -1;

          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
              overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
              overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
              overflow = WEEKDAY;
          }

          getParsingFlags(m).overflow = overflow;
      }

      return m;
  }

  // Pick the first defined of two or three arguments.
  function defaults(a, b, c) {
      if (a != null) {
          return a;
      }
      if (b != null) {
          return b;
      }
      return c;
  }

  function currentDateArray(config) {
      // hooks is actually the exported moment object
      var nowValue = new Date(hooks.now());
      if (config._useUTC) {
          return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  }

  // convert an array to a date.
  // the array should mirror the parameters below
  // note: all values past the year are optional and will default to the lowest possible value.
  // [year, month, day , hour, minute, second, millisecond]
  function configFromArray (config) {
      var i, date, input = [], currentDate, expectedWeekday, yearToUse;

      if (config._d) {
          return;
      }

      currentDate = currentDateArray(config);

      //compute day of the year from weeks and weekdays
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
      }

      //if the day of the year is set, figure out what it is
      if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
              getParsingFlags(config)._overflowDayOfYear = true;
          }

          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
      }

      // Default to current date.
      // * if no year, month, day of month are given, default to today
      // * if day of month is given, default month and year
      // * if month is given, default only year
      // * if year is given, don't default anything
      for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
      }

      // Zero out whatever was not defaulted, including time
      for (; i < 7; i++) {
          config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
      }

      // Check for 24:00:00.000
      if (config._a[HOUR] === 24 &&
              config._a[MINUTE] === 0 &&
              config._a[SECOND] === 0 &&
              config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
      }

      config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

      // Apply timezone offset from input. The actual utcOffset can be changed
      // with parseZone.
      if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }

      if (config._nextDay) {
          config._a[HOUR] = 24;
      }

      // check for mismatching day of week
      if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
      }
  }

  function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

      w = config._w;
      if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;

          // TODO: We need to take the current isoWeekYear, but that depends on
          // how we interpret now (local, utc, fixed offset). So create
          // a now version of current config (take local/utc/offset flags, and
          // create now).
          weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
              weekdayOverflow = true;
          }
      } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;

          var curWeek = weekOfYear(createLocal(), dow, doy);

          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

          // Default to current week.
          week = defaults(w.w, curWeek.week);

          if (w.d != null) {
              // weekday -- low day numbers are considered next week
              weekday = w.d;
              if (weekday < 0 || weekday > 6) {
                  weekdayOverflow = true;
              }
          } else if (w.e != null) {
              // local weekday -- counting starts from beginning of week
              weekday = w.e + dow;
              if (w.e < 0 || w.e > 6) {
                  weekdayOverflow = true;
              }
          } else {
              // default to beginning of week
              weekday = dow;
          }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
      } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
      }
  }

  // iso 8601 regex
  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
  var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

  var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

  var isoDates = [
      ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
      ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
      ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
      ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
      ['YYYY-DDD', /\d{4}-\d{3}/],
      ['YYYY-MM', /\d{4}-\d\d/, false],
      ['YYYYYYMMDD', /[+-]\d{10}/],
      ['YYYYMMDD', /\d{8}/],
      // YYYYMM is NOT allowed by the standard
      ['GGGG[W]WWE', /\d{4}W\d{3}/],
      ['GGGG[W]WW', /\d{4}W\d{2}/, false],
      ['YYYYDDD', /\d{7}/]
  ];

  // iso time formats and regexes
  var isoTimes = [
      ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
      ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
      ['HH:mm:ss', /\d\d:\d\d:\d\d/],
      ['HH:mm', /\d\d:\d\d/],
      ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
      ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
      ['HHmmss', /\d\d\d\d\d\d/],
      ['HHmm', /\d\d\d\d/],
      ['HH', /\d\d/]
  ];

  var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

  // date from iso format
  function configFromISO(config) {
      var i, l,
          string = config._i,
          match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
          allowTime, dateFormat, timeFormat, tzFormat;

      if (match) {
          getParsingFlags(config).iso = true;

          for (i = 0, l = isoDates.length; i < l; i++) {
              if (isoDates[i][1].exec(match[1])) {
                  dateFormat = isoDates[i][0];
                  allowTime = isoDates[i][2] !== false;
                  break;
              }
          }
          if (dateFormat == null) {
              config._isValid = false;
              return;
          }
          if (match[3]) {
              for (i = 0, l = isoTimes.length; i < l; i++) {
                  if (isoTimes[i][1].exec(match[3])) {
                      // match[2] should be 'T' or space
                      timeFormat = (match[2] || ' ') + isoTimes[i][0];
                      break;
                  }
              }
              if (timeFormat == null) {
                  config._isValid = false;
                  return;
              }
          }
          if (!allowTime && timeFormat != null) {
              config._isValid = false;
              return;
          }
          if (match[4]) {
              if (tzRegex.exec(match[4])) {
                  tzFormat = 'Z';
              } else {
                  config._isValid = false;
                  return;
              }
          }
          config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
          configFromStringAndFormat(config);
      } else {
          config._isValid = false;
      }
  }

  // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
      ];

      if (secondStr) {
          result.push(parseInt(secondStr, 10));
      }

      return result;
  }

  function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
          return 2000 + year;
      } else if (year <= 999) {
          return 1900 + year;
      }
      return year;
  }

  function preprocessRFC2822(s) {
      // Remove comments and folding whitespace and replace multiple-spaces with a single space
      return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  }

  function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
          // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
              weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
          if (weekdayProvided !== weekdayActual) {
              getParsingFlags(config).weekdayMismatch = true;
              config._isValid = false;
              return false;
          }
      }
      return true;
  }

  var obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
  };

  function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
          return obsOffsets[obsOffset];
      } else if (militaryOffset) {
          // the only allowed military tz is Z
          return 0;
      } else {
          var hm = parseInt(numOffset, 10);
          var m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
      }
  }

  // date and time from ref 2822 format
  function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i));
      if (match) {
          var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
          if (!checkWeekday(match[1], parsedArray, config)) {
              return;
          }

          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);

          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

          getParsingFlags(config).rfc2822 = true;
      } else {
          config._isValid = false;
      }
  }

  // date from iso format or fallback
  function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);

      if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
      }

      configFromISO(config);
      if (config._isValid === false) {
          delete config._isValid;
      } else {
          return;
      }

      configFromRFC2822(config);
      if (config._isValid === false) {
          delete config._isValid;
      } else {
          return;
      }

      // Final attempt, use Input Fallback
      hooks.createFromInputFallback(config);
  }

  hooks.createFromInputFallback = deprecate(
      'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
      'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
      'discouraged and will be removed in an upcoming major release. Please refer to ' +
      'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
      function (config) {
          config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
      }
  );

  // constant that refers to the ISO standard
  hooks.ISO_8601 = function () {};

  // constant that refers to the RFC 2822 form
  hooks.RFC_2822 = function () {};

  // date from string and format string
  function configFromStringAndFormat(config) {
      // TODO: Move this to another part of the creation flow to prevent circular deps
      if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
      }
      if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;

      // This array is used to make a Date, either with `new Date` or `Date.UTC`
      var string = '' + config._i,
          i, parsedInput, tokens, token, skipped,
          stringLength = string.length,
          totalParsedInputLength = 0;

      tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

      for (i = 0; i < tokens.length; i++) {
          token = tokens[i];
          parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
          // console.log('token', token, 'parsedInput', parsedInput,
          //         'regex', getParseRegexForToken(token, config));
          if (parsedInput) {
              skipped = string.substr(0, string.indexOf(parsedInput));
              if (skipped.length > 0) {
                  getParsingFlags(config).unusedInput.push(skipped);
              }
              string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
              totalParsedInputLength += parsedInput.length;
          }
          // don't parse if it's not a known token
          if (formatTokenFunctions[token]) {
              if (parsedInput) {
                  getParsingFlags(config).empty = false;
              }
              else {
                  getParsingFlags(config).unusedTokens.push(token);
              }
              addTimeToArrayFromToken(token, parsedInput, config);
          }
          else if (config._strict && !parsedInput) {
              getParsingFlags(config).unusedTokens.push(token);
          }
      }

      // add remaining unparsed input length to the string
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
      }

      // clear _12h flag if hour is <= 12
      if (config._a[HOUR] <= 12 &&
          getParsingFlags(config).bigHour === true &&
          config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = undefined;
      }

      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem;
      // handle meridiem
      config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

      configFromArray(config);
      checkOverflow(config);
  }


  function meridiemFixWrap (locale, hour, meridiem) {
      var isPm;

      if (meridiem == null) {
          // nothing to do
          return hour;
      }
      if (locale.meridiemHour != null) {
          return locale.meridiemHour(hour, meridiem);
      } else if (locale.isPM != null) {
          // Fallback
          isPm = locale.isPM(meridiem);
          if (isPm && hour < 12) {
              hour += 12;
          }
          if (!isPm && hour === 12) {
              hour = 0;
          }
          return hour;
      } else {
          // this is not supposed to happen
          return hour;
      }
  }

  // date from string and array of format strings
  function configFromStringAndArray(config) {
      var tempConfig,
          bestMoment,

          scoreToBeat,
          i,
          currentScore;

      if (config._f.length === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
      }

      for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
              tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);

          if (!isValid(tempConfig)) {
              continue;
          }

          // if there is any input that was not parsed add a penalty for that format
          currentScore += getParsingFlags(tempConfig).charsLeftOver;

          //or tokens
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

          getParsingFlags(tempConfig).score = currentScore;

          if (scoreToBeat == null || currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
          }
      }

      extend(config, bestMoment || tempConfig);
  }

  function configFromObject(config) {
      if (config._d) {
          return;
      }

      var i = normalizeObjectUnits(config._i);
      config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
          return obj && parseInt(obj, 10);
      });

      configFromArray(config);
  }

  function createFromConfig (config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
          // Adding is smart enough around DST
          res.add(1, 'd');
          res._nextDay = undefined;
      }

      return res;
  }

  function prepareConfig (config) {
      var input = config._i,
          format = config._f;

      config._locale = config._locale || getLocale(config._l);

      if (input === null || (format === undefined && input === '')) {
          return createInvalid({nullInput: true});
      }

      if (typeof input === 'string') {
          config._i = input = config._locale.preparse(input);
      }

      if (isMoment(input)) {
          return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
          config._d = input;
      } else if (isArray(format)) {
          configFromStringAndArray(config);
      } else if (format) {
          configFromStringAndFormat(config);
      }  else {
          configFromInput(config);
      }

      if (!isValid(config)) {
          config._d = null;
      }

      return config;
  }

  function configFromInput(config) {
      var input = config._i;
      if (isUndefined(input)) {
          config._d = new Date(hooks.now());
      } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
      } else if (typeof input === 'string') {
          configFromString(config);
      } else if (isArray(input)) {
          config._a = map(input.slice(0), function (obj) {
              return parseInt(obj, 10);
          });
          configFromArray(config);
      } else if (isObject$1(input)) {
          configFromObject(config);
      } else if (isNumber(input)) {
          // from milliseconds
          config._d = new Date(input);
      } else {
          hooks.createFromInputFallback(config);
      }
  }

  function createLocalOrUTC (input, format, locale, strict, isUTC) {
      var c = {};

      if (locale === true || locale === false) {
          strict = locale;
          locale = undefined;
      }

      if ((isObject$1(input) && isObjectEmpty(input)) ||
              (isArray(input) && input.length === 0)) {
          input = undefined;
      }
      // object construction must be done this way.
      // https://github.com/moment/moment/issues/1423
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale;
      c._i = input;
      c._f = format;
      c._strict = strict;

      return createFromConfig(c);
  }

  function createLocal (input, format, locale, strict) {
      return createLocalOrUTC(input, format, locale, strict, false);
  }

  var prototypeMin = deprecate(
      'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
      function () {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
              return other < this ? this : other;
          } else {
              return createInvalid();
          }
      }
  );

  var prototypeMax = deprecate(
      'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
      function () {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
              return other > this ? this : other;
          } else {
              return createInvalid();
          }
      }
  );

  // Pick a moment m from moments so that m[fn](other) is true for all
  // other. This relies on the function fn to be transitive.
  //
  // moments should either be an array of moment objects or an array, whose
  // first element is an array of moment objects.
  function pickBy(fn, moments) {
      var res, i;
      if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
      }
      if (!moments.length) {
          return createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
              res = moments[i];
          }
      }
      return res;
  }

  // TODO: Use [].sort instead?
  function min () {
      var args = [].slice.call(arguments, 0);

      return pickBy('isBefore', args);
  }

  function max () {
      var args = [].slice.call(arguments, 0);

      return pickBy('isAfter', args);
  }

  var now = function () {
      return Date.now ? Date.now() : +(new Date());
  };

  var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

  function isDurationValid(m) {
      for (var key in m) {
          if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
              return false;
          }
      }

      var unitHasDecimal = false;
      for (var i = 0; i < ordering.length; ++i) {
          if (m[ordering[i]]) {
              if (unitHasDecimal) {
                  return false; // only allow non-integers for smallest unit
              }
              if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                  unitHasDecimal = true;
              }
          }
      }

      return true;
  }

  function isValid$1() {
      return this._isValid;
  }

  function createInvalid$1() {
      return createDuration(NaN);
  }

  function Duration (duration) {
      var normalizedInput = normalizeObjectUnits(duration),
          years = normalizedInput.year || 0,
          quarters = normalizedInput.quarter || 0,
          months = normalizedInput.month || 0,
          weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
          days = normalizedInput.day || 0,
          hours = normalizedInput.hour || 0,
          minutes = normalizedInput.minute || 0,
          seconds = normalizedInput.second || 0,
          milliseconds = normalizedInput.millisecond || 0;

      this._isValid = isDurationValid(normalizedInput);

      // representation for dateAddRemove
      this._milliseconds = +milliseconds +
          seconds * 1e3 + // 1000
          minutes * 6e4 + // 1000 * 60
          hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
      // Because of dateAddRemove treats 24 hours as different from a
      // day when working around DST, we need to store them separately
      this._days = +days +
          weeks * 7;
      // It is impossible to translate months into days without knowing
      // which months you are are talking about, so we have to store
      // it separately.
      this._months = +months +
          quarters * 3 +
          years * 12;

      this._data = {};

      this._locale = getLocale();

      this._bubble();
  }

  function isDuration (obj) {
      return obj instanceof Duration;
  }

  function absRound (number) {
      if (number < 0) {
          return Math.round(-1 * number) * -1;
      } else {
          return Math.round(number);
      }
  }

  // FORMATTING

  function offset (token, separator) {
      addFormatToken(token, 0, 0, function () {
          var offset = this.utcOffset();
          var sign = '+';
          if (offset < 0) {
              offset = -offset;
              sign = '-';
          }
          return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
      });
  }

  offset('Z', ':');
  offset('ZZ', '');

  // PARSING

  addRegexToken('Z',  matchShortOffset);
  addRegexToken('ZZ', matchShortOffset);
  addParseToken(['Z', 'ZZ'], function (input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
  });

  // HELPERS

  // timezone chunker
  // '+10:00' > ['10',  '00']
  // '-1530'  > ['-15', '30']
  var chunkOffset = /([\+\-]|\d\d)/gi;

  function offsetFromString(matcher, string) {
      var matches = (string || '').match(matcher);

      if (matches === null) {
          return null;
      }

      var chunk   = matches[matches.length - 1] || [];
      var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
      var minutes = +(parts[1] * 60) + toInt(parts[2]);

      return minutes === 0 ?
        0 :
        parts[0] === '+' ? minutes : -minutes;
  }

  // Return a moment from input, that is local/utc/zone equivalent to model.
  function cloneWithOffset(input, model) {
      var res, diff;
      if (model._isUTC) {
          res = model.clone();
          diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          // Use low-level api, because this fn is low-level api.
          res._d.setTime(res._d.valueOf() + diff);
          hooks.updateOffset(res, false);
          return res;
      } else {
          return createLocal(input).local();
      }
  }

  function getDateOffset (m) {
      // On Firefox.24 Date#getTimezoneOffset returns a floating point.
      // https://github.com/moment/moment/pull/1871
      return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
  }

  // HOOKS

  // This function will be called whenever a moment is mutated.
  // It is intended to keep the offset in sync with the timezone.
  hooks.updateOffset = function () {};

  // MOMENTS

  // keepLocalTime = true means only change the timezone, without
  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
  // +0200, so we adjust the time as needed, to be valid.
  //
  // Keeping the time actually adds/subtracts (one hour)
  // from the actual represented time. That is why we call updateOffset
  // a second time. In case it wants us to change the offset again
  // _changeInProgress == true case, then we have to adjust, because
  // there is no such time in the given timezone.
  function getSetOffset (input, keepLocalTime, keepMinutes) {
      var offset = this._offset || 0,
          localAdjust;
      if (!this.isValid()) {
          return input != null ? this : NaN;
      }
      if (input != null) {
          if (typeof input === 'string') {
              input = offsetFromString(matchShortOffset, input);
              if (input === null) {
                  return this;
              }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
              input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
              localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
              this.add(localAdjust, 'm');
          }
          if (offset !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                  addSubtract(this, createDuration(input - offset, 'm'), 1, false);
              } else if (!this._changeInProgress) {
                  this._changeInProgress = true;
                  hooks.updateOffset(this, true);
                  this._changeInProgress = null;
              }
          }
          return this;
      } else {
          return this._isUTC ? offset : getDateOffset(this);
      }
  }

  function getSetZone (input, keepLocalTime) {
      if (input != null) {
          if (typeof input !== 'string') {
              input = -input;
          }

          this.utcOffset(input, keepLocalTime);

          return this;
      } else {
          return -this.utcOffset();
      }
  }

  function setOffsetToUTC (keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
  }

  function setOffsetToLocal (keepLocalTime) {
      if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;

          if (keepLocalTime) {
              this.subtract(getDateOffset(this), 'm');
          }
      }
      return this;
  }

  function setOffsetToParsedOffset () {
      if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === 'string') {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
              this.utcOffset(tZone);
          }
          else {
              this.utcOffset(0, true);
          }
      }
      return this;
  }

  function hasAlignedHourOffset (input) {
      if (!this.isValid()) {
          return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;

      return (this.utcOffset() - input) % 60 === 0;
  }

  function isDaylightSavingTime () {
      return (
          this.utcOffset() > this.clone().month(0).utcOffset() ||
          this.utcOffset() > this.clone().month(5).utcOffset()
      );
  }

  function isDaylightSavingTimeShifted () {
      if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
      }

      var c = {};

      copyConfig(c, this);
      c = prepareConfig(c);

      if (c._a) {
          var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() &&
              compareArrays(c._a, other.toArray()) > 0;
      } else {
          this._isDSTShifted = false;
      }

      return this._isDSTShifted;
  }

  function isLocal () {
      return this.isValid() ? !this._isUTC : false;
  }

  function isUtcOffset () {
      return this.isValid() ? this._isUTC : false;
  }

  function isUtc () {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
  }

  // ASP.NET json date format regex
  var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

  // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
  // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
  // and further modified to allow for strings containing both week and day
  var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

  function createDuration (input, key) {
      var duration = input,
          // matching against regexp is expensive, do it on demand
          match = null,
          sign,
          ret,
          diffRes;

      if (isDuration(input)) {
          duration = {
              ms : input._milliseconds,
              d  : input._days,
              M  : input._months
          };
      } else if (isNumber(input)) {
          duration = {};
          if (key) {
              duration[key] = input;
          } else {
              duration.milliseconds = input;
          }
      } else if (!!(match = aspNetRegex.exec(input))) {
          sign = (match[1] === '-') ? -1 : 1;
          duration = {
              y  : 0,
              d  : toInt(match[DATE])                         * sign,
              h  : toInt(match[HOUR])                         * sign,
              m  : toInt(match[MINUTE])                       * sign,
              s  : toInt(match[SECOND])                       * sign,
              ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
          };
      } else if (!!(match = isoRegex.exec(input))) {
          sign = (match[1] === '-') ? -1 : 1;
          duration = {
              y : parseIso(match[2], sign),
              M : parseIso(match[3], sign),
              w : parseIso(match[4], sign),
              d : parseIso(match[5], sign),
              h : parseIso(match[6], sign),
              m : parseIso(match[7], sign),
              s : parseIso(match[8], sign)
          };
      } else if (duration == null) {// checks for null or undefined
          duration = {};
      } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
          diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
      }

      ret = new Duration(duration);

      if (isDuration(input) && hasOwnProp(input, '_locale')) {
          ret._locale = input._locale;
      }

      return ret;
  }

  createDuration.fn = Duration.prototype;
  createDuration.invalid = createInvalid$1;

  function parseIso (inp, sign) {
      // We'd normally use ~~inp for this, but unfortunately it also
      // converts floats to ints.
      // inp may be undefined, so careful calling replace on it.
      var res = inp && parseFloat(inp.replace(',', '.'));
      // apply sign while we're at it
      return (isNaN(res) ? 0 : res) * sign;
  }

  function positiveMomentsDifference(base, other) {
      var res = {};

      res.months = other.month() - base.month() +
          (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, 'M').isAfter(other)) {
          --res.months;
      }

      res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

      return res;
  }

  function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
          return {milliseconds: 0, months: 0};
      }

      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
      } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
      }

      return res;
  }

  // TODO: remove 'name' arg after deprecation is removed
  function createAdder(direction, name) {
      return function (val, period) {
          var dur, tmp;
          //invert the arguments, but complain about it
          if (period !== null && !isNaN(+period)) {
              deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
              'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
              tmp = val; val = period; period = tmp;
          }

          val = typeof val === 'string' ? +val : val;
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
      };
  }

  function addSubtract (mom, duration, isAdding, updateOffset) {
      var milliseconds = duration._milliseconds,
          days = absRound(duration._days),
          months = absRound(duration._months);

      if (!mom.isValid()) {
          // No op
          return;
      }

      updateOffset = updateOffset == null ? true : updateOffset;

      if (months) {
          setMonth(mom, get$1(mom, 'Month') + months * isAdding);
      }
      if (days) {
          set$2(mom, 'Date', get$1(mom, 'Date') + days * isAdding);
      }
      if (milliseconds) {
          mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
      }
      if (updateOffset) {
          hooks.updateOffset(mom, days || months);
      }
  }

  var add      = createAdder(1, 'add');
  var subtract = createAdder(-1, 'subtract');

  function getCalendarFormat(myMoment, now) {
      var diff = myMoment.diff(now, 'days', true);
      return diff < -6 ? 'sameElse' :
              diff < -1 ? 'lastWeek' :
              diff < 0 ? 'lastDay' :
              diff < 1 ? 'sameDay' :
              diff < 2 ? 'nextDay' :
              diff < 7 ? 'nextWeek' : 'sameElse';
  }

  function calendar$1 (time, formats) {
      // We want to compare the start of today, vs this.
      // Getting start-of-today depends on whether we're local/utc/offset or not.
      var now = time || createLocal(),
          sod = cloneWithOffset(now, this).startOf('day'),
          format = hooks.calendarFormat(this, sod) || 'sameElse';

      var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

      return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
  }

  function clone () {
      return new Moment(this);
  }

  function isAfter (input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
          return false;
      }
      units = normalizeUnits(units) || 'millisecond';
      if (units === 'millisecond') {
          return this.valueOf() > localInput.valueOf();
      } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
  }

  function isBefore (input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
          return false;
      }
      units = normalizeUnits(units) || 'millisecond';
      if (units === 'millisecond') {
          return this.valueOf() < localInput.valueOf();
      } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
  }

  function isBetween (from, to, units, inclusivity) {
      var localFrom = isMoment(from) ? from : createLocal(from),
          localTo = isMoment(to) ? to : createLocal(to);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
      }
      inclusivity = inclusivity || '()';
      return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
          (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
  }

  function isSame (input, units) {
      var localInput = isMoment(input) ? input : createLocal(input),
          inputMs;
      if (!(this.isValid() && localInput.isValid())) {
          return false;
      }
      units = normalizeUnits(units) || 'millisecond';
      if (units === 'millisecond') {
          return this.valueOf() === localInput.valueOf();
      } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
  }

  function isSameOrAfter (input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
  }

  function isSameOrBefore (input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
  }

  function diff (input, units, asFloat) {
      var that,
          zoneDelta,
          output;

      if (!this.isValid()) {
          return NaN;
      }

      that = cloneWithOffset(input, this);

      if (!that.isValid()) {
          return NaN;
      }

      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

      units = normalizeUnits(units);

      switch (units) {
          case 'year': output = monthDiff(this, that) / 12; break;
          case 'month': output = monthDiff(this, that); break;
          case 'quarter': output = monthDiff(this, that) / 3; break;
          case 'second': output = (this - that) / 1e3; break; // 1000
          case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
          case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
          case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
          case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
          default: output = this - that;
      }

      return asFloat ? output : absFloor(output);
  }

  function monthDiff (a, b) {
      // difference in months
      var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
          // b is in (anchor - 1 month, anchor + 1 month)
          anchor = a.clone().add(wholeMonthDiff, 'months'),
          anchor2, adjust;

      if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
          // linear across the month
          adjust = (b - anchor) / (anchor - anchor2);
      } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
          // linear across the month
          adjust = (b - anchor) / (anchor2 - anchor);
      }

      //check for negative zero, return zero if negative zero
      return -(wholeMonthDiff + adjust) || 0;
  }

  hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
  hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

  function toString () {
      return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
  }

  function toISOString(keepOffset) {
      if (!this.isValid()) {
          return null;
      }
      var utc = keepOffset !== true;
      var m = utc ? this.clone().utc() : this;
      if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
      }
      if (isFunction(Date.prototype.toISOString)) {
          // native implementation is ~50x faster, use it when we can
          if (utc) {
              return this.toDate().toISOString();
          } else {
              return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
          }
      }
      return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
  }

  /**
   * Return a human readable representation of a moment that can
   * also be evaluated to get a new moment which is the same
   *
   * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
   */
  function inspect () {
      if (!this.isValid()) {
          return 'moment.invalid(/* ' + this._i + ' */)';
      }
      var func = 'moment';
      var zone = '';
      if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
          zone = 'Z';
      }
      var prefix = '[' + func + '("]';
      var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
      var datetime = '-MM-DD[T]HH:mm:ss.SSS';
      var suffix = zone + '[")]';

      return this.format(prefix + year + datetime + suffix);
  }

  function format$1 (inputString) {
      if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
  }

  function from (time, withoutSuffix) {
      if (this.isValid() &&
              ((isMoment(time) && time.isValid()) ||
               createLocal(time).isValid())) {
          return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
      } else {
          return this.localeData().invalidDate();
      }
  }

  function fromNow (withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
  }

  function to (time, withoutSuffix) {
      if (this.isValid() &&
              ((isMoment(time) && time.isValid()) ||
               createLocal(time).isValid())) {
          return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
      } else {
          return this.localeData().invalidDate();
      }
  }

  function toNow (withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
  }

  // If passed a locale key, it will set the locale for this
  // instance.  Otherwise, it will return the locale configuration
  // variables for this instance.
  function locale (key) {
      var newLocaleData;

      if (key === undefined) {
          return this._locale._abbr;
      } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
              this._locale = newLocaleData;
          }
          return this;
      }
  }

  var lang = deprecate(
      'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
      function (key) {
          if (key === undefined) {
              return this.localeData();
          } else {
              return this.locale(key);
          }
      }
  );

  function localeData () {
      return this._locale;
  }

  var MS_PER_SECOND = 1000;
  var MS_PER_MINUTE = 60 * MS_PER_SECOND;
  var MS_PER_HOUR = 60 * MS_PER_MINUTE;
  var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

  // actual modulo - handles negative numbers (for dates before 1970):
  function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
  }

  function localStartOfDate(y, m, d) {
      // the date constructor remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
          return new Date(y, m, d).valueOf();
      }
  }

  function utcStartOfDate(y, m, d) {
      // Date.UTC remaps years 0-99 to 1900-1999
      if (y < 100 && y >= 0) {
          // preserve leap years using a full 400 year cycle, then reset
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
          return Date.UTC(y, m, d);
      }
  }

  function startOf (units) {
      var time;
      units = normalizeUnits(units);
      if (units === undefined || units === 'millisecond' || !this.isValid()) {
          return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
          case 'year':
              time = startOfDate(this.year(), 0, 1);
              break;
          case 'quarter':
              time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
              break;
          case 'month':
              time = startOfDate(this.year(), this.month(), 1);
              break;
          case 'week':
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
              break;
          case 'isoWeek':
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
              break;
          case 'day':
          case 'date':
              time = startOfDate(this.year(), this.month(), this.date());
              break;
          case 'hour':
              time = this._d.valueOf();
              time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
              break;
          case 'minute':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_MINUTE);
              break;
          case 'second':
              time = this._d.valueOf();
              time -= mod$1(time, MS_PER_SECOND);
              break;
      }

      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
  }

  function endOf (units) {
      var time;
      units = normalizeUnits(units);
      if (units === undefined || units === 'millisecond' || !this.isValid()) {
          return this;
      }

      var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

      switch (units) {
          case 'year':
              time = startOfDate(this.year() + 1, 0, 1) - 1;
              break;
          case 'quarter':
              time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
              break;
          case 'month':
              time = startOfDate(this.year(), this.month() + 1, 1) - 1;
              break;
          case 'week':
              time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
              break;
          case 'isoWeek':
              time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
              break;
          case 'day':
          case 'date':
              time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
              break;
          case 'hour':
              time = this._d.valueOf();
              time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
              break;
          case 'minute':
              time = this._d.valueOf();
              time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
              break;
          case 'second':
              time = this._d.valueOf();
              time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
              break;
      }

      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
  }

  function valueOf () {
      return this._d.valueOf() - ((this._offset || 0) * 60000);
  }

  function unix () {
      return Math.floor(this.valueOf() / 1000);
  }

  function toDate () {
      return new Date(this.valueOf());
  }

  function toArray$2 () {
      var m = this;
      return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
  }

  function toObject () {
      var m = this;
      return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
      };
  }

  function toJSON () {
      // new Date(NaN).toJSON() === null
      return this.isValid() ? this.toISOString() : null;
  }

  function isValid$2 () {
      return isValid(this);
  }

  function parsingFlags () {
      return extend({}, getParsingFlags(this));
  }

  function invalidAt () {
      return getParsingFlags(this).overflow;
  }

  function creationData() {
      return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
      };
  }

  // FORMATTING

  addFormatToken(0, ['gg', 2], 0, function () {
      return this.weekYear() % 100;
  });

  addFormatToken(0, ['GG', 2], 0, function () {
      return this.isoWeekYear() % 100;
  });

  function addWeekYearFormatToken (token, getter) {
      addFormatToken(0, [token, token.length], 0, getter);
  }

  addWeekYearFormatToken('gggg',     'weekYear');
  addWeekYearFormatToken('ggggg',    'weekYear');
  addWeekYearFormatToken('GGGG',  'isoWeekYear');
  addWeekYearFormatToken('GGGGG', 'isoWeekYear');

  // ALIASES

  addUnitAlias('weekYear', 'gg');
  addUnitAlias('isoWeekYear', 'GG');

  // PRIORITY

  addUnitPriority('weekYear', 1);
  addUnitPriority('isoWeekYear', 1);


  // PARSING

  addRegexToken('G',      matchSigned);
  addRegexToken('g',      matchSigned);
  addRegexToken('GG',     match1to2, match2);
  addRegexToken('gg',     match1to2, match2);
  addRegexToken('GGGG',   match1to4, match4);
  addRegexToken('gggg',   match1to4, match4);
  addRegexToken('GGGGG',  match1to6, match6);
  addRegexToken('ggggg',  match1to6, match6);

  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
      week[token.substr(0, 2)] = toInt(input);
  });

  addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
      week[token] = hooks.parseTwoDigitYear(input);
  });

  // MOMENTS

  function getSetWeekYear (input) {
      return getSetWeekYearHelper.call(this,
              input,
              this.week(),
              this.weekday(),
              this.localeData()._week.dow,
              this.localeData()._week.doy);
  }

  function getSetISOWeekYear (input) {
      return getSetWeekYearHelper.call(this,
              input, this.isoWeek(), this.isoWeekday(), 1, 4);
  }

  function getISOWeeksInYear () {
      return weeksInYear(this.year(), 1, 4);
  }

  function getWeeksInYear () {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }

  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
          return weekOfYear(this, dow, doy).year;
      } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
              week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
  }

  function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
          date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
  }

  // FORMATTING

  addFormatToken('Q', 0, 'Qo', 'quarter');

  // ALIASES

  addUnitAlias('quarter', 'Q');

  // PRIORITY

  addUnitPriority('quarter', 7);

  // PARSING

  addRegexToken('Q', match1);
  addParseToken('Q', function (input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
  });

  // MOMENTS

  function getSetQuarter (input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  }

  // FORMATTING

  addFormatToken('D', ['DD', 2], 'Do', 'date');

  // ALIASES

  addUnitAlias('date', 'D');

  // PRIORITY
  addUnitPriority('date', 9);

  // PARSING

  addRegexToken('D',  match1to2);
  addRegexToken('DD', match1to2, match2);
  addRegexToken('Do', function (isStrict, locale) {
      // TODO: Remove "ordinalParse" fallback in next major release.
      return isStrict ?
        (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
        locale._dayOfMonthOrdinalParseLenient;
  });

  addParseToken(['D', 'DD'], DATE);
  addParseToken('Do', function (input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
  });

  // MOMENTS

  var getSetDayOfMonth = makeGetSet('Date', true);

  // FORMATTING

  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

  // ALIASES

  addUnitAlias('dayOfYear', 'DDD');

  // PRIORITY
  addUnitPriority('dayOfYear', 4);

  // PARSING

  addRegexToken('DDD',  match1to3);
  addRegexToken('DDDD', match3);
  addParseToken(['DDD', 'DDDD'], function (input, array, config) {
      config._dayOfYear = toInt(input);
  });

  // HELPERS

  // MOMENTS

  function getSetDayOfYear (input) {
      var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
      return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
  }

  // FORMATTING

  addFormatToken('m', ['mm', 2], 0, 'minute');

  // ALIASES

  addUnitAlias('minute', 'm');

  // PRIORITY

  addUnitPriority('minute', 14);

  // PARSING

  addRegexToken('m',  match1to2);
  addRegexToken('mm', match1to2, match2);
  addParseToken(['m', 'mm'], MINUTE);

  // MOMENTS

  var getSetMinute = makeGetSet('Minutes', false);

  // FORMATTING

  addFormatToken('s', ['ss', 2], 0, 'second');

  // ALIASES

  addUnitAlias('second', 's');

  // PRIORITY

  addUnitPriority('second', 15);

  // PARSING

  addRegexToken('s',  match1to2);
  addRegexToken('ss', match1to2, match2);
  addParseToken(['s', 'ss'], SECOND);

  // MOMENTS

  var getSetSecond = makeGetSet('Seconds', false);

  // FORMATTING

  addFormatToken('S', 0, 0, function () {
      return ~~(this.millisecond() / 100);
  });

  addFormatToken(0, ['SS', 2], 0, function () {
      return ~~(this.millisecond() / 10);
  });

  addFormatToken(0, ['SSS', 3], 0, 'millisecond');
  addFormatToken(0, ['SSSS', 4], 0, function () {
      return this.millisecond() * 10;
  });
  addFormatToken(0, ['SSSSS', 5], 0, function () {
      return this.millisecond() * 100;
  });
  addFormatToken(0, ['SSSSSS', 6], 0, function () {
      return this.millisecond() * 1000;
  });
  addFormatToken(0, ['SSSSSSS', 7], 0, function () {
      return this.millisecond() * 10000;
  });
  addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
      return this.millisecond() * 100000;
  });
  addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
      return this.millisecond() * 1000000;
  });


  // ALIASES

  addUnitAlias('millisecond', 'ms');

  // PRIORITY

  addUnitPriority('millisecond', 16);

  // PARSING

  addRegexToken('S',    match1to3, match1);
  addRegexToken('SS',   match1to3, match2);
  addRegexToken('SSS',  match1to3, match3);

  var token;
  for (token = 'SSSS'; token.length <= 9; token += 'S') {
      addRegexToken(token, matchUnsigned);
  }

  function parseMs(input, array) {
      array[MILLISECOND] = toInt(('0.' + input) * 1000);
  }

  for (token = 'S'; token.length <= 9; token += 'S') {
      addParseToken(token, parseMs);
  }
  // MOMENTS

  var getSetMillisecond = makeGetSet('Milliseconds', false);

  // FORMATTING

  addFormatToken('z',  0, 0, 'zoneAbbr');
  addFormatToken('zz', 0, 0, 'zoneName');

  // MOMENTS

  function getZoneAbbr () {
      return this._isUTC ? 'UTC' : '';
  }

  function getZoneName () {
      return this._isUTC ? 'Coordinated Universal Time' : '';
  }

  var proto = Moment.prototype;

  proto.add               = add;
  proto.calendar          = calendar$1;
  proto.clone             = clone;
  proto.diff              = diff;
  proto.endOf             = endOf;
  proto.format            = format$1;
  proto.from              = from;
  proto.fromNow           = fromNow;
  proto.to                = to;
  proto.toNow             = toNow;
  proto.get               = stringGet;
  proto.invalidAt         = invalidAt;
  proto.isAfter           = isAfter;
  proto.isBefore          = isBefore;
  proto.isBetween         = isBetween;
  proto.isSame            = isSame;
  proto.isSameOrAfter     = isSameOrAfter;
  proto.isSameOrBefore    = isSameOrBefore;
  proto.isValid           = isValid$2;
  proto.lang              = lang;
  proto.locale            = locale;
  proto.localeData        = localeData;
  proto.max               = prototypeMax;
  proto.min               = prototypeMin;
  proto.parsingFlags      = parsingFlags;
  proto.set               = stringSet;
  proto.startOf           = startOf;
  proto.subtract          = subtract;
  proto.toArray           = toArray$2;
  proto.toObject          = toObject;
  proto.toDate            = toDate;
  proto.toISOString       = toISOString;
  proto.inspect           = inspect;
  proto.toJSON            = toJSON;
  proto.toString          = toString;
  proto.unix              = unix;
  proto.valueOf           = valueOf;
  proto.creationData      = creationData;
  proto.year       = getSetYear;
  proto.isLeapYear = getIsLeapYear;
  proto.weekYear    = getSetWeekYear;
  proto.isoWeekYear = getSetISOWeekYear;
  proto.quarter = proto.quarters = getSetQuarter;
  proto.month       = getSetMonth;
  proto.daysInMonth = getDaysInMonth;
  proto.week           = proto.weeks        = getSetWeek;
  proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
  proto.weeksInYear    = getWeeksInYear;
  proto.isoWeeksInYear = getISOWeeksInYear;
  proto.date       = getSetDayOfMonth;
  proto.day        = proto.days             = getSetDayOfWeek;
  proto.weekday    = getSetLocaleDayOfWeek;
  proto.isoWeekday = getSetISODayOfWeek;
  proto.dayOfYear  = getSetDayOfYear;
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  proto.utcOffset            = getSetOffset;
  proto.utc                  = setOffsetToUTC;
  proto.local                = setOffsetToLocal;
  proto.parseZone            = setOffsetToParsedOffset;
  proto.hasAlignedHourOffset = hasAlignedHourOffset;
  proto.isDST                = isDaylightSavingTime;
  proto.isLocal              = isLocal;
  proto.isUtcOffset          = isUtcOffset;
  proto.isUtc                = isUtc;
  proto.isUTC                = isUtc;
  proto.zoneAbbr = getZoneAbbr;
  proto.zoneName = getZoneName;
  proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
  proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
  proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
  proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
  proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

  function createUnix (input) {
      return createLocal(input * 1000);
  }

  function createInZone () {
      return createLocal.apply(null, arguments).parseZone();
  }

  function preParsePostFormat (string) {
      return string;
  }

  var proto$1 = Locale.prototype;

  proto$1.calendar        = calendar;
  proto$1.longDateFormat  = longDateFormat;
  proto$1.invalidDate     = invalidDate;
  proto$1.ordinal         = ordinal;
  proto$1.preparse        = preParsePostFormat;
  proto$1.postformat      = preParsePostFormat;
  proto$1.relativeTime    = relativeTime;
  proto$1.pastFuture      = pastFuture;
  proto$1.set             = set$1;

  proto$1.months            =        localeMonths;
  proto$1.monthsShort       =        localeMonthsShort;
  proto$1.monthsParse       =        localeMonthsParse;
  proto$1.monthsRegex       = monthsRegex;
  proto$1.monthsShortRegex  = monthsShortRegex;
  proto$1.week = localeWeek;
  proto$1.firstDayOfYear = localeFirstDayOfYear;
  proto$1.firstDayOfWeek = localeFirstDayOfWeek;

  proto$1.weekdays       =        localeWeekdays;
  proto$1.weekdaysMin    =        localeWeekdaysMin;
  proto$1.weekdaysShort  =        localeWeekdaysShort;
  proto$1.weekdaysParse  =        localeWeekdaysParse;

  proto$1.weekdaysRegex       =        weekdaysRegex;
  proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
  proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

  proto$1.isPM = localeIsPM;
  proto$1.meridiem = localeMeridiem;

  function get$2 (format, index, field, setter) {
      var locale = getLocale();
      var utc = createUTC().set(setter, index);
      return locale[field](utc, format);
  }

  function listMonthsImpl (format, index, field) {
      if (isNumber(format)) {
          index = format;
          format = undefined;
      }

      format = format || '';

      if (index != null) {
          return get$2(format, index, field, 'month');
      }

      var i;
      var out = [];
      for (i = 0; i < 12; i++) {
          out[i] = get$2(format, i, field, 'month');
      }
      return out;
  }

  // ()
  // (5)
  // (fmt, 5)
  // (fmt)
  // (true)
  // (true, 5)
  // (true, fmt, 5)
  // (true, fmt)
  function listWeekdaysImpl (localeSorted, format, index, field) {
      if (typeof localeSorted === 'boolean') {
          if (isNumber(format)) {
              index = format;
              format = undefined;
          }

          format = format || '';
      } else {
          format = localeSorted;
          index = format;
          localeSorted = false;

          if (isNumber(format)) {
              index = format;
              format = undefined;
          }

          format = format || '';
      }

      var locale = getLocale(),
          shift = localeSorted ? locale._week.dow : 0;

      if (index != null) {
          return get$2(format, (index + shift) % 7, field, 'day');
      }

      var i;
      var out = [];
      for (i = 0; i < 7; i++) {
          out[i] = get$2(format, (i + shift) % 7, field, 'day');
      }
      return out;
  }

  function listMonths (format, index) {
      return listMonthsImpl(format, index, 'months');
  }

  function listMonthsShort (format, index) {
      return listMonthsImpl(format, index, 'monthsShort');
  }

  function listWeekdays (localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
  }

  function listWeekdaysShort (localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
  }

  function listWeekdaysMin (localeSorted, format, index) {
      return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
  }

  getSetGlobalLocale('en', {
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal : function (number) {
          var b = number % 10,
              output = (toInt(number % 100 / 10) === 1) ? 'th' :
              (b === 1) ? 'st' :
              (b === 2) ? 'nd' :
              (b === 3) ? 'rd' : 'th';
          return number + output;
      }
  });

  // Side effect imports

  hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
  hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

  var mathAbs = Math.abs;

  function abs () {
      var data           = this._data;

      this._milliseconds = mathAbs(this._milliseconds);
      this._days         = mathAbs(this._days);
      this._months       = mathAbs(this._months);

      data.milliseconds  = mathAbs(data.milliseconds);
      data.seconds       = mathAbs(data.seconds);
      data.minutes       = mathAbs(data.minutes);
      data.hours         = mathAbs(data.hours);
      data.months        = mathAbs(data.months);
      data.years         = mathAbs(data.years);

      return this;
  }

  function addSubtract$1 (duration, input, value, direction) {
      var other = createDuration(input, value);

      duration._milliseconds += direction * other._milliseconds;
      duration._days         += direction * other._days;
      duration._months       += direction * other._months;

      return duration._bubble();
  }

  // supports only 2.0-style add(1, 's') or add(duration)
  function add$1 (input, value) {
      return addSubtract$1(this, input, value, 1);
  }

  // supports only 2.0-style subtract(1, 's') or subtract(duration)
  function subtract$1 (input, value) {
      return addSubtract$1(this, input, value, -1);
  }

  function absCeil (number) {
      if (number < 0) {
          return Math.floor(number);
      } else {
          return Math.ceil(number);
      }
  }

  function bubble () {
      var milliseconds = this._milliseconds;
      var days         = this._days;
      var months       = this._months;
      var data         = this._data;
      var seconds, minutes, hours, years, monthsFromDays;

      // if we have a mix of positive and negative values, bubble down first
      // check: https://github.com/moment/moment/issues/2166
      if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
              (milliseconds <= 0 && days <= 0 && months <= 0))) {
          milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
          days = 0;
          months = 0;
      }

      // The following code bubbles up values, see the tests for
      // examples of what that means.
      data.milliseconds = milliseconds % 1000;

      seconds           = absFloor(milliseconds / 1000);
      data.seconds      = seconds % 60;

      minutes           = absFloor(seconds / 60);
      data.minutes      = minutes % 60;

      hours             = absFloor(minutes / 60);
      data.hours        = hours % 24;

      days += absFloor(hours / 24);

      // convert days to months
      monthsFromDays = absFloor(daysToMonths(days));
      months += monthsFromDays;
      days -= absCeil(monthsToDays(monthsFromDays));

      // 12 months -> 1 year
      years = absFloor(months / 12);
      months %= 12;

      data.days   = days;
      data.months = months;
      data.years  = years;

      return this;
  }

  function daysToMonths (days) {
      // 400 years have 146097 days (taking into account leap year rules)
      // 400 years have 12 months === 4800
      return days * 4800 / 146097;
  }

  function monthsToDays (months) {
      // the reverse of daysToMonths
      return months * 146097 / 4800;
  }

  function as (units) {
      if (!this.isValid()) {
          return NaN;
      }
      var days;
      var months;
      var milliseconds = this._milliseconds;

      units = normalizeUnits(units);

      if (units === 'month' || units === 'quarter' || units === 'year') {
          days = this._days + milliseconds / 864e5;
          months = this._months + daysToMonths(days);
          switch (units) {
              case 'month':   return months;
              case 'quarter': return months / 3;
              case 'year':    return months / 12;
          }
      } else {
          // handle milliseconds separately because of floating point math errors (issue #1867)
          days = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
              case 'week'   : return days / 7     + milliseconds / 6048e5;
              case 'day'    : return days         + milliseconds / 864e5;
              case 'hour'   : return days * 24    + milliseconds / 36e5;
              case 'minute' : return days * 1440  + milliseconds / 6e4;
              case 'second' : return days * 86400 + milliseconds / 1000;
              // Math.floor prevents floating point math errors here
              case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
              default: throw new Error('Unknown unit ' + units);
          }
      }
  }

  // TODO: Use this.as('ms')?
  function valueOf$1 () {
      if (!this.isValid()) {
          return NaN;
      }
      return (
          this._milliseconds +
          this._days * 864e5 +
          (this._months % 12) * 2592e6 +
          toInt(this._months / 12) * 31536e6
      );
  }

  function makeAs (alias) {
      return function () {
          return this.as(alias);
      };
  }

  var asMilliseconds = makeAs('ms');
  var asSeconds      = makeAs('s');
  var asMinutes      = makeAs('m');
  var asHours        = makeAs('h');
  var asDays         = makeAs('d');
  var asWeeks        = makeAs('w');
  var asMonths       = makeAs('M');
  var asQuarters     = makeAs('Q');
  var asYears        = makeAs('y');

  function clone$1 () {
      return createDuration(this);
  }

  function get$3 (units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + 's']() : NaN;
  }

  function makeGetter(name) {
      return function () {
          return this.isValid() ? this._data[name] : NaN;
      };
  }

  var milliseconds = makeGetter('milliseconds');
  var seconds      = makeGetter('seconds');
  var minutes      = makeGetter('minutes');
  var hours        = makeGetter('hours');
  var days         = makeGetter('days');
  var months       = makeGetter('months');
  var years        = makeGetter('years');

  function weeks () {
      return absFloor(this.days() / 7);
  }

  var round = Math.round;
  var thresholds = {
      ss: 44,         // a few seconds to seconds
      s : 45,         // seconds to minute
      m : 45,         // minutes to hour
      h : 22,         // hours to day
      d : 26,         // days to month
      M : 11          // months to year
  };

  // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
      return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }

  function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
      var duration = createDuration(posNegDuration).abs();
      var seconds  = round(duration.as('s'));
      var minutes  = round(duration.as('m'));
      var hours    = round(duration.as('h'));
      var days     = round(duration.as('d'));
      var months   = round(duration.as('M'));
      var years    = round(duration.as('y'));

      var a = seconds <= thresholds.ss && ['s', seconds]  ||
              seconds < thresholds.s   && ['ss', seconds] ||
              minutes <= 1             && ['m']           ||
              minutes < thresholds.m   && ['mm', minutes] ||
              hours   <= 1             && ['h']           ||
              hours   < thresholds.h   && ['hh', hours]   ||
              days    <= 1             && ['d']           ||
              days    < thresholds.d   && ['dd', days]    ||
              months  <= 1             && ['M']           ||
              months  < thresholds.M   && ['MM', months]  ||
              years   <= 1             && ['y']           || ['yy', years];

      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale;
      return substituteTimeAgo.apply(null, a);
  }

  // This function allows you to set the rounding function for relative time strings
  function getSetRelativeTimeRounding (roundingFunction) {
      if (roundingFunction === undefined) {
          return round;
      }
      if (typeof(roundingFunction) === 'function') {
          round = roundingFunction;
          return true;
      }
      return false;
  }

  // This function allows you to set a threshold for relative time strings
  function getSetRelativeTimeThreshold (threshold, limit) {
      if (thresholds[threshold] === undefined) {
          return false;
      }
      if (limit === undefined) {
          return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === 's') {
          thresholds.ss = limit - 1;
      }
      return true;
  }

  function humanize (withSuffix) {
      if (!this.isValid()) {
          return this.localeData().invalidDate();
      }

      var locale = this.localeData();
      var output = relativeTime$1(this, !withSuffix, locale);

      if (withSuffix) {
          output = locale.pastFuture(+this, output);
      }

      return locale.postformat(output);
  }

  var abs$1 = Math.abs;

  function sign(x) {
      return ((x > 0) - (x < 0)) || +x;
  }

  function toISOString$1() {
      // for ISO strings we do not use the normal bubbling rules:
      //  * milliseconds bubble up until they become hours
      //  * days do not bubble at all
      //  * months bubble up until they become years
      // This is because there is no context-free conversion between hours and days
      // (think of clock changes)
      // and also not between days and months (28-31 days per month)
      if (!this.isValid()) {
          return this.localeData().invalidDate();
      }

      var seconds = abs$1(this._milliseconds) / 1000;
      var days         = abs$1(this._days);
      var months       = abs$1(this._months);
      var minutes, hours, years;

      // 3600 seconds -> 60 minutes -> 1 hour
      minutes           = absFloor(seconds / 60);
      hours             = absFloor(minutes / 60);
      seconds %= 60;
      minutes %= 60;

      // 12 months -> 1 year
      years  = absFloor(months / 12);
      months %= 12;


      // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
      var Y = years;
      var M = months;
      var D = days;
      var h = hours;
      var m = minutes;
      var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
      var total = this.asSeconds();

      if (!total) {
          // this is the same as C#'s (Noda) and python (isodate)...
          // but not other JS (goog.date)
          return 'P0D';
      }

      var totalSign = total < 0 ? '-' : '';
      var ymSign = sign(this._months) !== sign(total) ? '-' : '';
      var daysSign = sign(this._days) !== sign(total) ? '-' : '';
      var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

      return totalSign + 'P' +
          (Y ? ymSign + Y + 'Y' : '') +
          (M ? ymSign + M + 'M' : '') +
          (D ? daysSign + D + 'D' : '') +
          ((h || m || s) ? 'T' : '') +
          (h ? hmsSign + h + 'H' : '') +
          (m ? hmsSign + m + 'M' : '') +
          (s ? hmsSign + s + 'S' : '');
  }

  var proto$2 = Duration.prototype;

  proto$2.isValid        = isValid$1;
  proto$2.abs            = abs;
  proto$2.add            = add$1;
  proto$2.subtract       = subtract$1;
  proto$2.as             = as;
  proto$2.asMilliseconds = asMilliseconds;
  proto$2.asSeconds      = asSeconds;
  proto$2.asMinutes      = asMinutes;
  proto$2.asHours        = asHours;
  proto$2.asDays         = asDays;
  proto$2.asWeeks        = asWeeks;
  proto$2.asMonths       = asMonths;
  proto$2.asQuarters     = asQuarters;
  proto$2.asYears        = asYears;
  proto$2.valueOf        = valueOf$1;
  proto$2._bubble        = bubble;
  proto$2.clone          = clone$1;
  proto$2.get            = get$3;
  proto$2.milliseconds   = milliseconds;
  proto$2.seconds        = seconds;
  proto$2.minutes        = minutes;
  proto$2.hours          = hours;
  proto$2.days           = days;
  proto$2.weeks          = weeks;
  proto$2.months         = months;
  proto$2.years          = years;
  proto$2.humanize       = humanize;
  proto$2.toISOString    = toISOString$1;
  proto$2.toString       = toISOString$1;
  proto$2.toJSON         = toISOString$1;
  proto$2.locale         = locale;
  proto$2.localeData     = localeData;

  proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
  proto$2.lang = lang;

  // FORMATTING

  addFormatToken('X', 0, 0, 'unix');
  addFormatToken('x', 0, 0, 'valueOf');

  // PARSING

  addRegexToken('x', matchSigned);
  addRegexToken('X', matchTimestamp);
  addParseToken('X', function (input, array, config) {
      config._d = new Date(parseFloat(input, 10) * 1000);
  });
  addParseToken('x', function (input, array, config) {
      config._d = new Date(toInt(input));
  });

  //! moment.js

  hooks.version = '2.24.0';

  setHookCallback(createLocal);

  hooks.fn                    = proto;
  hooks.min                   = min;
  hooks.max                   = max;
  hooks.now                   = now;
  hooks.utc                   = createUTC;
  hooks.unix                  = createUnix;
  hooks.months                = listMonths;
  hooks.isDate                = isDate;
  hooks.locale                = getSetGlobalLocale;
  hooks.invalid               = createInvalid;
  hooks.duration              = createDuration;
  hooks.isMoment              = isMoment;
  hooks.weekdays              = listWeekdays;
  hooks.parseZone             = createInZone;
  hooks.localeData            = getLocale;
  hooks.isDuration            = isDuration;
  hooks.monthsShort           = listMonthsShort;
  hooks.weekdaysMin           = listWeekdaysMin;
  hooks.defineLocale          = defineLocale;
  hooks.updateLocale          = updateLocale;
  hooks.locales               = listLocales;
  hooks.weekdaysShort         = listWeekdaysShort;
  hooks.normalizeUnits        = normalizeUnits;
  hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
  hooks.calendarFormat        = getCalendarFormat;
  hooks.prototype             = proto;

  // currently HTML5 input type only supports 24-hour formats
  hooks.HTML5_FMT = {
      DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
      DATE: 'YYYY-MM-DD',                             // <input type="date" />
      TIME: 'HH:mm',                                  // <input type="time" />
      TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
      TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
      WEEK: 'GGGG-[W]WW',                             // <input type="week" />
      MONTH: 'YYYY-MM'                                // <input type="month" />
  };

  /**
   * 时间展示类型改变事件
   * @param val
   */

  var changeDateFormat = function changeDateFormat(val, modeType) {
    var dateFormat = '';

    switch (modeType) {
      case 'datetime':
        dateFormat = hooks(val).format('YYYY-MM-DD HH:mm');
        break;

      case 'month':
        dateFormat = hooks(val).format('YYYY-MM');
        break;

      case 'time':
        dateFormat = hooks(val).format('hh:mm');
        break;

      case 'year':
        dateFormat = hooks(val).format('YYYY');
        break;

      default:
        dateFormat = hooks(val).format('YYYY-MM-DD');
        break;
    }

    return dateFormat;
  };
  var dateChange = function dateChange(date) {
    var stringDate = hooks(date).format('YYYY-MM-DD-HH-mm-ss');
    var dateList = stringDate.split('-');
    var numberDateList = dateList.map(function (item) {
      return parseInt(item, 10);
    });
    return new Date(numberDateList[0], numberDateList[1] - 1, numberDateList[2], numberDateList[3], numberDateList[4], numberDateList[5]);
  };
  var getByteLen = function getByteLen(val) {
    var len = 0;
    val.split('').forEach(function (item) {
      // eslint-disable-next-line no-control-regex
      if (item.match(/[^\x00-\xff]/gi) != null) {
        len += 2;
      } else {
        len += 1;
      }
    });
    return len;
  };
  var resetLabel = function resetLabel() {
    var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var placeholderList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    // switch (list.length) {
    //   case 0:
    //     list.push('请选择省');
    //     break;
    //   case 1:
    //     list.push('请选择市');
    //     break;
    //   case 2:
    //     list.push('请选择区/县');
    //     break;
    //   case 3:
    //     break;
    //   default:
    //     break;
    // }
    // return list;
    if (list.length === placeholderList.length) return list;
    list.push(placeholderList[list.length]);
    return list;
  };

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css = "@-webkit-keyframes colorful {\n  0% {\n    background-color: #fff;\n  }\n  100% {\n    background-color: #108ee9;\n  }\n}\n@keyframes colorful {\n  0% {\n    background-color: #fff;\n  }\n  100% {\n    background-color: #108ee9;\n  }\n}\n.alitajs-dform-title-content {\n  font-size: 0.17rem !important;\n}\n.alitajs-dform-item {\n  font-size: 0.17rem !important;\n  color: #000 !important;\n}\n.alitajs-dform-title {\n  color: #000;\n  font-size: 0.17rem !important;\n}\n.alitajs-dform-vertical-title {\n  margin-bottom: 0;\n  padding-top: 0.2rem;\n  padding-left: 0.3rem;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-start;\n}\n.alitajs-dform-line {\n  display: inline-block;\n  min-width: 0.38rem;\n  height: 100%;\n  color: rgba(0, 0, 0, 0.45);\n  font-size: 0.32rem;\n  white-space: nowrap;\n  text-align: center;\n  vertical-align: top;\n  pointer-events: none;\n}\n.alitajs-dform-placeholder .am-input-control input::-webkit-input-placeholder {\n  font-size: 0.17rem;\n}\n.alitajs-dform-placeholder .am-input-control input::-moz-placeholder {\n  font-size: 0.17rem;\n}\n.alitajs-dform-placeholder .am-input-control input:-ms-input-placeholder {\n  font-size: 0.17rem;\n}\n.alitajs-dform-placeholder .am-input-control input::-ms-input-placeholder {\n  font-size: 0.17rem;\n}\n.alitajs-dform-placeholder .am-input-control input::placeholder {\n  font-size: 0.17rem;\n}\n.alitajs-dform-placeholder .am-textarea-control textarea::-webkit-input-placeholder {\n  font-size: 0.17rem;\n}\n.alitajs-dform-placeholder .am-textarea-control textarea::-moz-placeholder {\n  font-size: 0.17rem;\n}\n.alitajs-dform-placeholder .am-textarea-control textarea:-ms-input-placeholder {\n  font-size: 0.17rem;\n}\n.alitajs-dform-placeholder .am-textarea-control textarea::-ms-input-placeholder {\n  font-size: 0.17rem;\n}\n.alitajs-dform-placeholder .am-textarea-control textarea::placeholder {\n  font-size: 0.17rem;\n}\n.alitajs-dform-placeholder .am-list-extra {\n  font-size: 0.17rem !important;\n}\n.alitajs-dform-value-content .am-list-extra {\n  color: #000 !important;\n  font-size: 0.17rem !important;\n}\n.alitajs-dform-value-content .am-input-control input {\n  color: #000;\n  font-size: 0.17rem;\n}\n.alitajs-dform-value-content .am-textarea-control textarea {\n  color: #000;\n  font-size: 0.17rem;\n}\n.alitajs-dform-redStar {\n  width: 0.14rem;\n  height: 0.5rem;\n  margin-right: 0.06rem;\n  color: #ff4848;\n  font-size: 0.17rem !important;\n}\n.alitajs-dform-input-title {\n  display: flex;\n  flex-direction: row;\n  align-items: flex-end;\n  justify-content: space-between;\n  padding-right: 0.15rem;\n}\n.alitajs-dform-input .am-input-extra {\n  max-height: 0.88rem;\n}\n.alitajs-dform-input .am-input-control input {\n  color: #000;\n  font-size: 0.17rem;\n}\n.alitajs-dform-vertical-input .am-input-extra {\n  max-height: 0.88rem;\n}\n.alitajs-dform-vertical-input .am-input-label {\n  display: none;\n}\n.alitajs-dform-vertical-input .am-input-control input {\n  color: #000;\n  font-size: 0.17rem;\n}\n.alitajs-dform-vertical-picker .am-list-extra {\n  flex-basis: 100% !important;\n  text-align: left !important;\n}\n.alitajs-dform-radio .am-list-extra {\n  flex-basis: 50% !important;\n}\n.alitajs-dform-radio .alitajs-dform-radio-group {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-start;\n}\n.alitajs-dform-radio .alitajs-dform-radio-group .alitajs-dform-radio-wrapper {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n}\n.alitajs-dform-radio .alitajs-dform-radio-group .alitajs-dform-radio-wrapper .alitajs-dform-radio-button {\n  width: 0.4rem;\n  height: 0.4rem;\n  border: 0.02rem solid #d9d9d9;\n  border-radius: 50%;\n  padding: 0.08rem;\n}\n.alitajs-dform-radio .alitajs-dform-radio-group .alitajs-dform-radio-wrapper .alitajs-dform-radio-button .alitajs-dform-radio-inner-button {\n  width: 100%;\n  height: 100%;\n  border-radius: 50%;\n  background-color: #108ee9;\n}\n.alitajs-dform-radio .alitajs-dform-radio-group .alitajs-dform-radio-wrapper .alitajs-dform-radio-checked {\n  border: 0.02rem solid #108ee9;\n  box-shadow: 0 0 0.02rem;\n}\n.alitajs-dform-radio .alitajs-dform-radio-group .alitajs-dform-radio-wrapper .alitajs-dform-radio-label {\n  font-size: 0.17rem;\n  color: #000;\n  padding-left: 0.08rem;\n  padding-right: 0.08rem;\n  display: flex;\n  align-items: center;\n}\n.alitajs-dform-radio .alitajs-dform-radio-group .alitajs-dform-radio-wrapper-item-vertical {\n  padding-bottom: 0.14rem;\n  padding-top: 0.14rem;\n}\n.alitajs-dform-radio .alitajs-dform-radio-position {\n  justify-content: flex-end;\n}\n.alitajs-dform-radio .alitajs-dform-radio-item-vertical {\n  flex-direction: column;\n  align-items: flex-start;\n}\n.alitajs-dform-vertical-radio .am-list-extra {\n  flex-basis: 50% !important;\n}\n.alitajs-dform-vertical-radio .alitajs-dform-radio-group {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-start;\n}\n.alitajs-dform-vertical-radio .alitajs-dform-radio-group .alitajs-dform-radio-wrapper {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n}\n.alitajs-dform-vertical-radio .alitajs-dform-radio-group .alitajs-dform-radio-wrapper .alitajs-dform-radio-button {\n  width: 0.4rem;\n  height: 0.4rem;\n  border: 0.02rem solid #d9d9d9;\n  border-radius: 50%;\n  padding: 0.08rem;\n}\n.alitajs-dform-vertical-radio .alitajs-dform-radio-group .alitajs-dform-radio-wrapper .alitajs-dform-radio-button .alitajs-dform-radio-inner-button {\n  width: 100%;\n  height: 100%;\n  border-radius: 50%;\n  background-color: #108ee9;\n}\n.alitajs-dform-vertical-radio .alitajs-dform-radio-group .alitajs-dform-radio-wrapper .alitajs-dform-radio-checked {\n  border: 0.02rem solid #108ee9;\n  box-shadow: 0 0 0.02rem;\n}\n.alitajs-dform-vertical-radio .alitajs-dform-radio-group .alitajs-dform-radio-wrapper .alitajs-dform-radio-label {\n  font-size: 0.17rem;\n  color: #000;\n  padding-left: 0.08rem;\n  padding-right: 0.08rem;\n  display: flex;\n  align-items: center;\n}\n.alitajs-dform-vertical-radio .alitajs-dform-radio-group .alitajs-dform-radio-wrapper-item-vertical {\n  padding-bottom: 0.14rem;\n  padding-top: 0.14rem;\n}\n.alitajs-dform-vertical-radio .alitajs-dform-radio-position {\n  justify-content: flex-end;\n}\n.alitajs-dform-vertical-radio .alitajs-dform-radio-item-vertical {\n  flex-direction: column;\n  align-items: flex-start;\n}\n.alitajs-dform-vertical-radio .am-list-extra {\n  flex-basis: 100% !important;\n}\n.alitajs-dform-vertical-date-picker .am-list-content {\n  display: none;\n}\n.alitajs-dform-vertical-date-picker .am-list-extra {\n  flex-basis: 100% !important;\n  text-align: left !important;\n}\n.alitajs-dform-area .am-textarea-control textarea {\n  padding: 0.04rem 0.1rem;\n  background-color: #f7f6f9;\n  border-radius: 0.06rem;\n}\n.alitajs-dform-area .am-textarea-label {\n  color: #000;\n  font-size: 0.17rem !important;\n}\n.alitajs-dform-area .am-list-item {\n  border-bottom: 1px solid #ddd !important;\n  margin-left: 0.3rem;\n  padding-left: 0px !important;\n}\n.alitajs-dform-area-title {\n  display: flex;\n  flex-direction: row;\n  align-items: flex-end;\n  justify-content: space-between;\n  padding-right: 0.3rem;\n}\n.alitajs-dform-vertical-area .am-textarea-label {\n  display: none;\n}\n.alitajs-dform-range-date-picker {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-range-horizontal .am-list-item .am-list-line .am-list-arrow {\n  display: none;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-begin-picker {\n  width: 65%;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-begin-picker .am-list-extra {\n  display: flex;\n  flex-basis: 50%;\n  align-items: center;\n  justify-content: center;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-begin-vertical-picker {\n  width: 48%;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-begin-vertical-picker .am-list-content {\n  display: none;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-begin-vertical-picker .am-list-extra {\n  flex-basis: 90%;\n  text-align: center;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-end-picker {\n  width: 30%;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-end-picker .am-list-line {\n  justify-content: flex-end;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-end-picker .am-list-extra {\n  flex-basis: 100%;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-end-picker .am-list-item {\n  padding-left: 0;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-end-vertical-picker {\n  width: 47%;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-end-vertical-picker .am-list-extra {\n  flex-basis: 90%;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-end-vertical-picker .am-list-line {\n  border-bottom: 0;\n}\n.alitajs-dform-range-date-picker .alitajs-dform-end-vertical-picker .am-list-item {\n  padding-left: 0 !important;\n  border-bottom: 1px solid #ddd;\n}\n.alitajs-dform-check-box .alitajs-dform-box-content {\n  padding-left: 0.3rem;\n  font-size: 0.17rem;\n}\n.alitajs-dform-check-box .alitajs-dform-box-content .alitajs-dform-box-wrapper {\n  padding-bottom: 0.14rem;\n  padding-top: 0.14rem;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n}\n.alitajs-dform-check-box .alitajs-dform-box-content .alitajs-dform-box-wrapper .alitajs-dform-box-botton {\n  width: 0.4rem;\n  height: 0.4rem;\n  border: 0.02rem solid #d9d9d9;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n}\n.alitajs-dform-check-box .alitajs-dform-box-content .alitajs-dform-box-wrapper .alitajs-dform-box-botton .alitajs-dform-box-tick {\n  width: 0.1rem;\n  height: 0.2rem;\n  border-bottom: 0.03rem solid #fff;\n  border-right: 0.03rem solid #fff;\n  transform: rotate(40deg);\n}\n.alitajs-dform-check-box .alitajs-dform-box-content .alitajs-dform-box-wrapper .alitajs-dform-box-botton-checked {\n  background-color: #108ee9;\n  border: 0.02rem solid #108ee9;\n  box-shadow: 0 0 0.03rem #108ee9;\n}\n.alitajs-dform-check-box .alitajs-dform-box-content .alitajs-dform-box-wrapper .alitajs-dform-box-label {\n  padding-left: 0.08rem;\n  padding-right: 0.08rem;\n}\n.alitajs-dform-extra-input {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-between;\n}\n.alitajs-dform-extra-input .alitajs-dform-begin-input {\n  width: 65%;\n}\n.alitajs-dform-extra-input .alitajs-dform-begin-input .am-input-control input {\n  text-align: center !important;\n}\n.alitajs-dform-extra-input .alitajs-dform-begin-vertical-input {\n  width: 48%;\n}\n.alitajs-dform-extra-input .alitajs-dform-begin-vertical-input .am-input-label {\n  display: none;\n}\n.alitajs-dform-extra-input .alitajs-dform-begin-vertical-input .am-input-control input {\n  text-align: center !important;\n}\n.alitajs-dform-extra-input .alitajs-dform-end-input {\n  width: 30%;\n}\n.alitajs-dform-extra-input .alitajs-dform-end-input .am-list-line {\n  justify-content: flex-end;\n}\n.alitajs-dform-extra-input .alitajs-dform-end-input .am-list-extra {\n  flex-basis: 90%;\n}\n.alitajs-dform-extra-input .alitajs-dform-end-input .am-list-item {\n  padding-left: 0;\n}\n.alitajs-dform-extra-input .alitajs-dform-end-vertical-input {\n  width: 47%;\n}\n.alitajs-dform-extra-input .alitajs-dform-end-vertical-input .am-list-item {\n  padding-left: 0 !important;\n}\n.alitajs-dform-extra-input .alitajs-dform-end-vertical-input .am-list-line {\n  justify-content: flex-end;\n}\n.alitajs-dform-extra-input .alitajs-dform-end-vertical-input .am-list-extra {\n  flex-basis: 90%;\n}\n.alitajs-dform-cover-radio .am-list-extra {\n  flex-basis: 50% !important;\n}\n.alitajs-dform-cover-radio .alitajs-dform-cover-radio-group {\n  display: flex;\n  align-items: center;\n  width: 100%;\n}\n.alitajs-dform-cover-radio .alitajs-dform-cover-radio-group .alitajs-dform-cover-radio-wrapper {\n  font-size: 0.17rem;\n  padding: 0.05rem 0.3rem;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-left: 0.2rem;\n  color: #000;\n}\n.alitajs-dform-cover-radio .alitajs-dform-cover-radio-group .alitajs-dform-cover-radio-wrapper-checked {\n  font-size: 0.17rem;\n  padding: 0.05rem 0.3rem;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-left: 0.2rem;\n  color: #000;\n  background-color: #108ee9;\n  color: #fff;\n  -webkit-animation-name: colorful;\n          animation-name: colorful;\n  -webkit-animation-duration: 1s;\n          animation-duration: 1s;\n}\n.alitajs-dform-cover-radio .alitajs-dform-cover-radio-group .alitajs-dform-cover-radio-wrapper-margin {\n  margin-left: 0px;\n  margin-right: 0.2rem;\n}\n.alitajs-dform-cover-radio .alitajs-dform-cover-radio-group .alitajs-dform-cover-radio-wrapper-cover {\n  color: #108ee9;\n}\n.alitajs-dform-cover-radio .alitajs-dform-cover-radio-item-vertical {\n  flex-direction: column;\n  align-items: flex-start;\n}\n.alitajs-dform-cover-radio .alitajs-dform-cover-radio-position {\n  justify-content: flex-end !important;\n}\n.alitajs-dform-vertical-cover-radio .am-list-extra {\n  flex-basis: 50% !important;\n}\n.alitajs-dform-vertical-cover-radio .alitajs-dform-cover-radio-group {\n  display: flex;\n  align-items: center;\n  width: 100%;\n}\n.alitajs-dform-vertical-cover-radio .alitajs-dform-cover-radio-group .alitajs-dform-cover-radio-wrapper {\n  font-size: 0.17rem;\n  padding: 0.05rem 0.3rem;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-left: 0.2rem;\n  color: #000;\n}\n.alitajs-dform-vertical-cover-radio .alitajs-dform-cover-radio-group .alitajs-dform-cover-radio-wrapper-checked {\n  font-size: 0.17rem;\n  padding: 0.05rem 0.3rem;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-left: 0.2rem;\n  color: #000;\n  background-color: #108ee9;\n  color: #fff;\n  -webkit-animation-name: colorful;\n          animation-name: colorful;\n  -webkit-animation-duration: 1s;\n          animation-duration: 1s;\n}\n.alitajs-dform-vertical-cover-radio .alitajs-dform-cover-radio-group .alitajs-dform-cover-radio-wrapper-margin {\n  margin-left: 0px;\n  margin-right: 0.2rem;\n}\n.alitajs-dform-vertical-cover-radio .alitajs-dform-cover-radio-group .alitajs-dform-cover-radio-wrapper-cover {\n  color: #108ee9;\n}\n.alitajs-dform-vertical-cover-radio .alitajs-dform-cover-radio-item-vertical {\n  flex-direction: column;\n  align-items: flex-start;\n}\n.alitajs-dform-vertical-cover-radio .alitajs-dform-cover-radio-position {\n  justify-content: flex-end !important;\n}\n.alitajs-dform-vertical-cover-radio .am-list-content {\n  display: none;\n}\n.alitajs-dform-vertical-cover-radio .am-list-extra {\n  flex-basis: 100% !important;\n}\n.alitajs-dform-image-picker .am-image-picker-list {\n  border-bottom: 1px solid #ddd;\n  padding-left: 0px;\n}\n.alitajs-dform-image-picker .am-image-picker {\n  padding-left: 0.3rem;\n}\n.alitajs-dform-dom .am-list-extra {\n  flex-basis: 50% !important;\n}\n.alitajs-dform-vertical-dom .am-list-extra {\n  flex-basis: 50% !important;\n}\n.alitajs-dform-vertical-dom .am-list-content {\n  display: none;\n}\n.alitajs-dform-vertical-dom .am-list-extra {\n  flex-basis: 100% !important;\n}\n.alitajs-dform-modal-content {\n  overflow-y: auto;\n  max-height: 8rem;\n}\n.alitajs-dform-multiple-picker .am-modal-header {\n  padding: 0px !important;\n}\n.alitajs-dform-multiple-picker .alitajs-dform-multiple-picker-item {\n  width: 100%;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-between;\n}\n.alitajs-dform-multiple-picker .alitajs-dform-multiple-picker-item .alitajs-dform-multiple-picker-label {\n  font-size: 0.17rem;\n  color: #000;\n}\n.alitajs-dform-multiple-picker .alitajs-dform-multiple-picker-item .alitajs-dform-multiple-picker-checked {\n  color: #108ee9;\n}\n.alitajs-dform-multiple-picker .alitajs-dform-multiple-picker-item .alitajs-dform-multiple-picker-right {\n  width: 0.4rem;\n  height: 0.4rem;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n}\n.alitajs-dform-tick {\n  width: 0.1rem;\n  height: 0.2rem;\n  border-bottom: 0.03rem solid #108ee9;\n  border-right: 0.03rem solid #108ee9;\n  transform: rotate(40deg);\n  margin-right: 0.3rem;\n}\n.alitajs-dform-input-item {\n  height: 0.44rem;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n}\n.alitajs-dform-input-item .alitajs-dform-input-tltle {\n  font-size: 0.17rem;\n  color: #000;\n}\n.alitajs-dform-input-item .alitajs-dform-input-value {\n  font-size: 0.17rem;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n}\n.alitajs-dform-input-item .alitajs-dform-input-value .alitajs-dform-input-text {\n  width: 100%;\n  border: 0px;\n  color: #000;\n}\n.alitajs-dform-right {\n  width: 0.3rem !important;\n  height: 0.3rem !important;\n  margin-left: 0.16rem;\n}\n.alitajs-dform-address .am-modal-header {\n  padding: 0px !important;\n}\n.alitajs-dform-address .alitajs-dform-address-content {\n  max-height: 8rem;\n}\n.alitajs-dform-address .alitajs-dform-address-content .alitajs-dform-address-value {\n  padding: 0 0.3rem;\n}\n.alitajs-dform-address .alitajs-dform-address-content .alitajs-dform-address-value .alitajs-dform-address-value-item {\n  font-size: 0.17rem;\n}\n.alitajs-dform-address .alitajs-dform-address-content .alitajs-dform-address-value .alitajs-dform-address-value-select {\n  color: #108ee9;\n  border-bottom: 0.04rem solid #108ee9;\n  width: -webkit-fit-content;\n  width: -moz-fit-content;\n  width: fit-content;\n}\n.alitajs-dform-address .alitajs-dform-address-content .alitajs-dform-address-value .alitajs-dform-address-value-item-label {\n  padding-top: 0.3rem;\n  padding-bottom: 0.3rem;\n}\n.alitajs-dform-address .alitajs-dform-address-content .alitajs-dform-address-list .alitajs-dform-address-list-content {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: space-between;\n}\n";
  styleInject(css);

  var CustomField = function CustomField(props) {
    var _React$useState = React__default.useState(false),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        valueFlag = _React$useState2[0],
        setValueFlag = _React$useState2[1];

    var shouldUpdate = function shouldUpdate(prevValue, nextValue) {
      if (props.shouldUpdate && typeof props.shouldUpdate === 'function') {
        props.shouldUpdate(prevValue, nextValue, {});
      }

      setValueFlag(nextValue && nextValue[props.name]);
      return prevValue !== nextValue;
    };

    return /*#__PURE__*/React__default.createElement("div", {
      className: valueFlag ? 'alitajs-dform-value-content' : 'alitajs-dform-placeholder'
    }, /*#__PURE__*/React__default.createElement(WrapperField, _extends({}, props, {
      shouldUpdate: shouldUpdate
    })));
  };

  var NomarInput = function NomarInput(props) {
    var _props$inputType = props.inputType,
        inputType = _props$inputType === void 0 ? 'text' : _props$inputType,
        coverStyle = props.coverStyle,
        _props$title = props.title,
        title = _props$title === void 0 ? '' : _props$title,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        fieldProps = props.fieldProps,
        rules = props.rules,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'horizontal' : _props$positionType,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        extra = props.extra,
        subTitle = props.subTitle,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden,
        onBlur = props.onBlur,
        otherProps = _objectWithoutProperties(props, ["inputType", "coverStyle", "title", "required", "fieldProps", "rules", "positionType", "hasStar", "extra", "subTitle", "hidden", "onBlur"]);

    var isVertical = positionType === 'vertical';

    var inputOnBlur = function inputOnBlur(val) {
      window.scrollTo(0, 0);
      if (onBlur) onBlur(val);
    };

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-input-title"
    }, isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle), extra !== '' && isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-area-extra"
    }, extra)), /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform".concat(isVertical ? '-vertical' : '', "-input")
    }, /*#__PURE__*/React__default.createElement(CustomField, {
      name: fieldProps,
      rules: rules || [{
        required: required,
        message: "\u8BF7\u8F93\u5165".concat(title)
      }]
    }, /*#__PURE__*/React__default.createElement(_InputItem, _extends({}, otherProps, {
      extra: isVertical ? '' : extra,
      type: inputType,
      style: _objectSpread2({
        textAlign: isVertical ? 'left' : 'right'
      }, coverStyle),
      onBlur: function onBlur(val) {
        inputOnBlur(val);
      }
    }), required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title))))));
  };

  var NomarPicker = function NomarPicker(props) {
    var coverStyle = props.coverStyle,
        title = props.title,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        fieldProps = props.fieldProps,
        rules = props.rules,
        placeholder = props.placeholder,
        _props$data = props.data,
        data = _props$data === void 0 ? [] : _props$data,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'horizontal' : _props$positionType,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        subTitle = props.subTitle,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden,
        otherProps = _objectWithoutProperties(props, ["coverStyle", "title", "required", "fieldProps", "rules", "placeholder", "data", "positionType", "hasStar", "subTitle", "hidden"]);

    var isVertical = positionType === 'vertical';
    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle), /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform".concat(isVertical ? '-vertical' : '', "-picker")
    }, /*#__PURE__*/React__default.createElement(CustomField, {
      name: fieldProps,
      rules: rules || [{
        required: required,
        message: "\u8BF7\u8F93\u5165".concat(title)
      }]
    }, /*#__PURE__*/React__default.createElement(_Picker, _extends({
      cascade: false
    }, otherProps, {
      style: coverStyle,
      extra: placeholder,
      data: data,
      title: title
    }), /*#__PURE__*/React__default.createElement(_List.Item, {
      arrow: "horizontal"
    }, !isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-title-content"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title))))))));
  };

  var NomarSwitch = function NomarSwitch(props) {
    var coverStyle = props.coverStyle,
        title = props.title,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        fieldProps = props.fieldProps,
        rules = props.rules,
        placeholder = props.placeholder,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden,
        otherProps = _objectWithoutProperties(props, ["coverStyle", "title", "required", "fieldProps", "rules", "placeholder", "hasStar", "hidden"]);

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement(_List.Item, {
      key: fieldProps,
      style: coverStyle,
      extra: /*#__PURE__*/React__default.createElement(CustomField, {
        name: fieldProps,
        valuePropName: "checked",
        rules: rules || [{
          required: required,
          message: "\u8BF7\u8F93\u5165".concat(title)
        }]
      }, /*#__PURE__*/React__default.createElement(_Switch, otherProps))
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-title-content"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title))));
  };

  var classnames = createCommonjsModule(function (module) {
  /*!
    Copyright (c) 2017 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  */
  /* global define */

  (function () {

  	var hasOwn = {}.hasOwnProperty;

  	function classNames () {
  		var classes = [];

  		for (var i = 0; i < arguments.length; i++) {
  			var arg = arguments[i];
  			if (!arg) continue;

  			var argType = typeof arg;

  			if (argType === 'string' || argType === 'number') {
  				classes.push(arg);
  			} else if (Array.isArray(arg) && arg.length) {
  				var inner = classNames.apply(null, arg);
  				if (inner) {
  					classes.push(inner);
  				}
  			} else if (argType === 'object') {
  				for (var key in arg) {
  					if (hasOwn.call(arg, key) && arg[key]) {
  						classes.push(key);
  					}
  				}
  			}
  		}

  		return classes.join(' ');
  	}

  	if ( module.exports) {
  		classNames.default = classNames;
  		module.exports = classNames;
  	} else {
  		window.classNames = classNames;
  	}
  }());
  });

  var NomarTextArea = function NomarTextArea(props) {
    var coverStyle = props.coverStyle,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        fieldProps = props.fieldProps,
        rules = props.rules,
        _props$rows = props.rows,
        rows = _props$rows === void 0 ? 3 : _props$rows,
        title = props.title,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'vertical' : _props$positionType,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        _props$extra = props.extra,
        extra = _props$extra === void 0 ? '' : _props$extra,
        subTitle = props.subTitle,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden,
        onBlur = props.onBlur,
        otherProps = _objectWithoutProperties(props, ["coverStyle", "required", "fieldProps", "rules", "rows", "title", "positionType", "hasStar", "extra", "subTitle", "hidden", "onBlur"]);

    var isVertical = positionType === 'vertical';
    if (extra) isVertical = true;

    var titleDiv = function titleDiv() {
      return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
        className: "alitajs-dform-redStar"
      }, "*"), /*#__PURE__*/React__default.createElement("span", {
        id: fieldProps,
        className: "alitajs-dform-title"
      }, title));
    };

    var inputOnBlur = function inputOnBlur(val) {
      window.scrollTo(0, 0);
      if (onBlur) onBlur(val);
    };

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-area-title"
    }, isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle), extra !== '' && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-area-extra"
    }, extra)), /*#__PURE__*/React__default.createElement("div", {
      className: classnames({
        'alitajs-dform-vertical-area': isVertical,
        'alitajs-dform-area': true
      })
    }, /*#__PURE__*/React__default.createElement(CustomField, {
      name: fieldProps,
      rules: rules || [{
        required: required,
        message: "\u8BF7\u8F93\u5165".concat(title)
      }]
    }, /*#__PURE__*/React__default.createElement(_TextareaItem, _extends({}, otherProps, {
      title: titleDiv(),
      style: coverStyle,
      rows: rows,
      onBlur: function onBlur(val) {
        inputOnBlur(val);
      }
    }))))));
  };

  var OnlyReadInput = function OnlyReadInput(props) {
    return /*#__PURE__*/React__default.createElement(NomarInput, _extends({}, props, {
      editable: false,
      inputType: "text",
      value: props.placeholder
    }));
  };

  var NomarDatePicker = function NomarDatePicker(props) {
    var fieldProps = props.fieldProps,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        title = props.title,
        rules = props.rules,
        _props$modeType = props.modeType,
        modeType = _props$modeType === void 0 ? 'date' : _props$modeType,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'horizontal' : _props$positionType,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        subTitle = props.subTitle,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden,
        otherProps = _objectWithoutProperties(props, ["fieldProps", "required", "title", "rules", "modeType", "positionType", "hasStar", "subTitle", "hidden"]);

    var isVertical = positionType === 'vertical';
    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle), /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform".concat(isVertical ? '-vertical' : '', "-date-picker")
    }, /*#__PURE__*/React__default.createElement(CustomField, {
      name: fieldProps,
      rules: rules || [{
        required: required,
        message: "\u8BF7\u9009\u62E9".concat(title)
      }]
    }, /*#__PURE__*/React__default.createElement(_DatePicker, _extends({}, otherProps, {
      mode: modeType,
      title: title,
      format: function format(value) {
        return changeDateFormat(value, modeType);
      }
    }), /*#__PURE__*/React__default.createElement(_List.Item, {
      arrow: "horizontal"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title)))))));
  };

  var RadioGroup = function RadioGroup(props) {
    var data = props.data,
        onChange = props.onChange,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'horizontal' : _props$positionType,
        _props$radioType = props.radioType,
        radioType = _props$radioType === void 0 ? 'horizontal' : _props$radioType,
        initValue = props.initValue,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        coverStyle = props.coverStyle;

    var _useState = React.useState([]),
        _useState2 = _slicedToArray(_useState, 2),
        context = _useState2[0],
        setContext = _useState2[1];

    var isVertical = positionType === 'vertical';

    if (radioType === 'vertical') {
      isVertical = true;
    }

    React.useEffect(function () {
      var dataList = JSON.parse(JSON.stringify(data));
      setContext(_toConsumableArray(dataList).map(function (item) {
        var initItem = item;

        if (initItem.value === initValue) {
          initItem.flag = true;
        } else {
          initItem.flag = false;
        }

        initItem.moveFlag = false;
        return initItem;
      }));
    }, [data, initValue]);

    var radioClick = function radioClick(e, dataItem) {
      e.stopPropagation();
      if (disabled) return;
      if (onChange) onChange("".concat(dataItem.value));
      setContext(context.map(function (item) {
        var selItem = item;

        if (item.value === dataItem.value) {
          selItem.flag = true;
        } else {
          selItem.flag = false;
        }

        return selItem;
      }));
    };

    return /*#__PURE__*/React__default.createElement("div", {
      className: classnames({
        'alitajs-dform-radio-group': true,
        'alitajs-dform-radio-position': !isVertical,
        'alitajs-dform-radio-item-vertical': radioType === 'vertical'
      })
    }, context.map(function (item) {
      return /*#__PURE__*/React__default.createElement("div", {
        key: item.value,
        className: classnames({
          'alitajs-dform-radio-wrapper': true,
          'alitajs-dform-radio-wrapper-item-vertical': radioType === 'vertical'
        }),
        onClick: function onClick(e) {
          radioClick(e, item);
        }
      }, /*#__PURE__*/React__default.createElement("div", {
        className: classnames({
          'alitajs-dform-radio-button': true,
          'alitajs-dform-radio-checked': item.flag
        })
      }, item.flag && /*#__PURE__*/React__default.createElement("div", {
        className: "alitajs-dform-radio-inner-button"
      })), /*#__PURE__*/React__default.createElement("div", {
        className: "alitajs-dform-radio-label",
        style: coverStyle
      }, item.label));
    }));
  };

  var NomarRadio = function NomarRadio(props) {
    var _useState = React.useState(''),
        _useState2 = _slicedToArray(_useState, 2),
        initValue = _useState2[0],
        setInitValue = _useState2[1];

    var coverStyle = props.coverStyle,
        fieldProps = props.fieldProps,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        rules = props.rules,
        title = props.title,
        _props$data = props.data,
        data = _props$data === void 0 ? [] : _props$data,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'horizontal' : _props$positionType,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        _props$radioType = props.radioType,
        radioType = _props$radioType === void 0 ? 'horizontal' : _props$radioType,
        subTitle = props.subTitle,
        onChange = props.onChange,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden;
    var isVertical = positionType === 'vertical';

    if (radioType === 'vertical') {
      isVertical = true;
    }

    var RadioGroup$1 = function RadioGroup$1() {
      return /*#__PURE__*/React__default.createElement(CustomField, {
        name: fieldProps,
        rules: rules || [{
          required: required,
          message: "\u8BF7\u9009\u62E9".concat(title)
        }],
        shouldUpdate: function shouldUpdate(prevValue, nextValue) {
          setInitValue(nextValue && nextValue[fieldProps]);
          return prevValue !== nextValue;
        }
      }, /*#__PURE__*/React__default.createElement(RadioGroup, {
        data: data,
        positionType: positionType,
        radioType: radioType,
        initValue: initValue,
        onChange: onChange,
        coverStyle: coverStyle
      }));
    };

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle), /*#__PURE__*/React__default.createElement("div", {
      className: classnames({
        'alitajs-dform-vertical-radio': isVertical,
        'alitajs-dform-radio': true
      })
    }, /*#__PURE__*/React__default.createElement(_List.Item, {
      key: fieldProps,
      extra: RadioGroup$1()
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title)))));
  };

  var RangeDatePicker = function RangeDatePicker(props) {
    var _useState = React.useState(),
        _useState2 = _slicedToArray(_useState, 2),
        beginDate = _useState2[0],
        setBeginDate = _useState2[1];

    var _useState3 = React.useState(),
        _useState4 = _slicedToArray(_useState3, 2),
        endDate = _useState4[0],
        setEndDate = _useState4[1];

    var fieldProps = props.fieldProps,
        fieldProps2 = props.fieldProps2,
        _props$placeholder = props.placeholder,
        placeholder = _props$placeholder === void 0 ? '开始时间' : _props$placeholder,
        _props$placeholder2 = props.placeholder2,
        placeholder2 = _props$placeholder2 === void 0 ? '结束时间' : _props$placeholder2,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        _props$modeType = props.modeType,
        modeType = _props$modeType === void 0 ? 'date' : _props$modeType,
        _props$rules = props.rules,
        rules = _props$rules === void 0 ? [] : _props$rules,
        title = props.title,
        minDate = props.minDate,
        maxDate = props.maxDate,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'vertical' : _props$positionType,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        secondProps = props.secondProps,
        firstProps = props.firstProps,
        subTitle = props.subTitle,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden,
        otherProps = _objectWithoutProperties(props, ["fieldProps", "fieldProps2", "placeholder", "placeholder2", "required", "modeType", "rules", "title", "minDate", "maxDate", "positionType", "hasStar", "secondProps", "firstProps", "subTitle", "hidden"]);

    var isVertical = positionType === 'vertical';
    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle), /*#__PURE__*/React__default.createElement("div", {
      className: classnames({
        'alitajs-dform-range-horizontal': !isVertical,
        'alitajs-dform-range-date-picker': true
      }),
      style: {
        justifyContent: isVertical ? 'space-between' : 'center',
        width: isVertical ? '' : '100%'
      }
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-begin".concat(isVertical ? '-vertical' : '', "-picker")
    }, /*#__PURE__*/React__default.createElement(CustomField, {
      name: fieldProps,
      rules: rules || [{
        required: required,
        message: "\u8BF7\u9009\u62E9".concat(title)
      }],
      shouldUpdate: function shouldUpdate(prevValue, nextValue) {
        setBeginDate(nextValue && nextValue[fieldProps]);
        return prevValue !== nextValue;
      }
    }, /*#__PURE__*/React__default.createElement(_DatePicker, _extends({}, otherProps, firstProps, {
      mode: modeType,
      extra: placeholder,
      minDate: minDate,
      maxDate: endDate || maxDate,
      title: title,
      format: function format(value) {
        return changeDateFormat(value, modeType);
      },
      onChange: function onChange(e) {
        setBeginDate(e);
      }
    }), /*#__PURE__*/React__default.createElement(_List.Item, null, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps2
    }))))), /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-line"
    }, "~"), /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-end".concat(isVertical ? '-vertical' : '', "-picker")
    }, /*#__PURE__*/React__default.createElement(CustomField, {
      name: fieldProps2,
      rules: rules || [{
        required: required,
        message: "\u8BF7\u9009\u62E9".concat(title)
      }],
      shouldUpdate: function shouldUpdate(prevValue, nextValue) {
        setEndDate(nextValue && nextValue[fieldProps2]);
        return prevValue !== nextValue;
      }
    }, /*#__PURE__*/React__default.createElement(_DatePicker, _extends({}, otherProps, secondProps, {
      extra: placeholder2,
      mode: modeType,
      minDate: beginDate || minDate,
      maxDate: maxDate,
      title: title,
      format: function format(value) {
        return changeDateFormat(value, modeType);
      },
      onChange: function onChange(e) {
        setEndDate(e);
      }
    }), /*#__PURE__*/React__default.createElement(_List.Item, {
      arrow: "horizontal"
    })))))));
  };

  var ExtraInput = function ExtraInput(props) {
    var _props$inputType = props.inputType,
        inputType = _props$inputType === void 0 ? 'text' : _props$inputType,
        fieldProps = props.fieldProps,
        fieldProps2 = props.fieldProps2,
        title = props.title,
        required = props.required,
        rules = props.rules,
        coverStyle = props.coverStyle,
        placeholder2 = props.placeholder2,
        _props$extraType = props.extraType,
        extraType = _props$extraType === void 0 ? 'input' : _props$extraType,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'vertical' : _props$positionType,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        data = props.data,
        firstProps = props.firstProps,
        secondProps = props.secondProps,
        subTitle = props.subTitle,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden,
        otherProps = _objectWithoutProperties(props, ["inputType", "fieldProps", "fieldProps2", "title", "required", "rules", "coverStyle", "placeholder2", "extraType", "positionType", "hasStar", "data", "firstProps", "secondProps", "subTitle", "hidden"]);

    var isVertical = positionType === 'vertical';

    var extraDiv = function extraDiv() {
      if (extraType === 'select') {
        return /*#__PURE__*/React__default.createElement(CustomField, {
          name: fieldProps2,
          rules: rules || [{
            required: required,
            message: "\u8BF7\u8F93\u5165".concat(title)
          }]
        }, /*#__PURE__*/React__default.createElement(_Picker, _extends({}, secondProps, {
          style: coverStyle,
          title: title,
          data: data,
          cascade: false,
          extra: placeholder2
        }), /*#__PURE__*/React__default.createElement(_List.Item, {
          arrow: "horizontal"
        })));
      }

      return /*#__PURE__*/React__default.createElement(CustomField, {
        name: fieldProps2,
        rules: rules || [{
          required: required,
          message: "\u8BF7\u8F93\u5165".concat(title)
        }]
      }, /*#__PURE__*/React__default.createElement(_InputItem, _extends({}, otherProps, secondProps, {
        type: inputType,
        style: _objectSpread2({
          textAlign: 'right'
        }, coverStyle),
        placeholder: placeholder2
      })));
    };

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle), /*#__PURE__*/React__default.createElement("div", {
      className: classnames({
        'alitajs-dform-extra-input': true,
        'alitajs-dform-extra-horizontal': !isVertical
      })
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-begin".concat(isVertical ? '-vertical' : '', "-input")
    }, /*#__PURE__*/React__default.createElement(NomarInput, _extends({}, otherProps, firstProps, {
      required: required,
      rules: rules,
      coverStyle: _objectSpread2({
        textAlign: 'left'
      }, coverStyle),
      fieldProps: fieldProps,
      title: title,
      extra: ""
    }))), extraType === 'input' && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-line"
    }, "~"), /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-end".concat(isVertical ? '-vertical' : '', "-input"),
      style: {
        width: isVertical ? '' : ''
      }
    }, extraDiv()))));
  };

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  var _freeGlobal = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = _freeGlobal || freeSelf || Function('return this')();

  var _root = root;

  /** Built-in value references. */
  var Symbol$1 = _root.Symbol;

  var _Symbol = Symbol$1;

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto.toString;

  /** Built-in value references. */
  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }

  var _getRawTag = getRawTag;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$1.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag$1 && symToStringTag$1 in Object(value))
      ? _getRawTag(value)
      : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$2(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject$2;

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$1(value) {
    if (!isObject_1(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = _baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction$1;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = _root['__core-js_shared__'];

  var _coreJsData = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  var _isMasked = isMasked;

  /** Used for built-in method references. */
  var funcProto = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  var _toSource = toSource;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype,
      objectProto$2 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }
    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue$1(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue$1;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = _getValue(object, key);
    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  /* Built-in method references that are verified to be native. */
  var nativeCreate = _getNative(Object, 'create');

  var _nativeCreate = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
  }

  var _hashHas = hashHas;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;

  var _Hash = Hash;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  var eq_1 = eq;

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  var _assocIndexOf = assocIndexOf;

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  var _listCacheSet = listCacheSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;

  var _ListCache = ListCache;

  /* Built-in method references that are verified to be native. */
  var Map = _getNative(_root, 'Map');

  var _Map = Map;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash,
      'map': new (_Map || _ListCache),
      'string': new _Hash
    };
  }

  var _mapCacheClear = mapCacheClear;

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  var _isKeyable = isKeyable;

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  var _getMapData = getMapData;

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;

  var _MapCache = MapCache;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);
    return this;
  }

  var _setCacheAdd = setCacheAdd;

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new _MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;

  var _SetCache = SetCache;

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  var _baseFindIndex = baseFindIndex;

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  var _baseIsNaN = baseIsNaN;

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  var _strictIndexOf = strictIndexOf;

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? _strictIndexOf(array, value, fromIndex)
      : _baseFindIndex(array, _baseIsNaN, fromIndex);
  }

  var _baseIndexOf = baseIndexOf;

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && _baseIndexOf(array, value, 0) > -1;
  }

  var _arrayIncludes = arrayIncludes;

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  var _arrayIncludesWith = arrayIncludesWith;

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  var _arrayMap = arrayMap;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * The base implementation of methods like `_.difference` without support
   * for excluding multiple arrays or iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Array} values The values to exclude.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   */
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1,
        includes = _arrayIncludes,
        isCommon = true,
        length = array.length,
        result = [],
        valuesLength = values.length;

    if (!length) {
      return result;
    }
    if (iteratee) {
      values = _arrayMap(values, _baseUnary(iteratee));
    }
    if (comparator) {
      includes = _arrayIncludesWith;
      isCommon = false;
    }
    else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = _cacheHas;
      isCommon = false;
      values = new _SetCache(values);
    }
    outer:
    while (++index < length) {
      var value = array[index],
          computed = iteratee == null ? value : iteratee(value);

      value = (comparator || value !== 0) ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values[valuesIndex] === computed) {
            continue outer;
          }
        }
        result.push(value);
      }
      else if (!includes(values, computed, comparator)) {
        result.push(value);
      }
    }
    return result;
  }

  var _baseDifference = baseDifference;

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  var _arrayPush = arrayPush;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
  }

  var _baseIsArguments = baseIsArguments;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
    return isObjectLike_1(value) && hasOwnProperty$4.call(value, 'callee') &&
      !propertyIsEnumerable.call(value, 'callee');
  };

  var isArguments_1 = isArguments;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$1 = Array.isArray;

  var isArray_1 = isArray$1;

  /** Built-in value references. */
  var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */
  function isFlattenable(value) {
    return isArray_1(value) || isArguments_1(value) ||
      !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  var _isFlattenable = isFlattenable;

  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;

    predicate || (predicate = _isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          _arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }

  var _baseFlatten = baseFlatten;

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  var identity_1 = identity;

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  var _apply = apply;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return _apply(func, this, otherArgs);
    };
  }

  var _overRest = overRest;

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant(value) {
    return function() {
      return value;
    };
  }

  var constant_1 = constant;

  var defineProperty = (function() {
    try {
      var func = _getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  var _defineProperty$3 = defineProperty;

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !_defineProperty$3 ? identity_1 : function(func, string) {
    return _defineProperty$3(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant_1(string),
      'writable': true
    });
  };

  var _baseSetToString = baseSetToString;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  var _shortOut = shortOut;

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = _shortOut(_baseSetToString);

  var _setToString = setToString;

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return _setToString(_overRest(func, start, identity_1), func + '');
  }

  var _baseRest = baseRest;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  var isLength_1 = isLength;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike_1(value) && isArrayLike_1(value);
  }

  var isArrayLikeObject_1 = isArrayLikeObject;

  /**
   * Creates an array of `array` values not included in the other given arrays
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. The order and references of result values are
   * determined by the first array.
   *
   * **Note:** Unlike `_.pullAll`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...Array} [values] The values to exclude.
   * @returns {Array} Returns the new array of filtered values.
   * @see _.without, _.xor
   * @example
   *
   * _.difference([2, 1], [2, 3]);
   * // => [1]
   */
  var difference = _baseRest(function(array, values) {
    return isArrayLikeObject_1(array)
      ? _baseDifference(array, _baseFlatten(values, 1, isArrayLikeObject_1, true))
      : [];
  });

  var difference_1 = difference;

  var CheckBoxGroup = function CheckBoxGroup(props) {
    var data = props.data,
        onChange = props.onChange,
        _props$initValue = props.initValue,
        initValue = _props$initValue === void 0 ? [] : _props$initValue,
        coverStyle = props.coverStyle,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled;

    var _useState = React.useState([]),
        _useState2 = _slicedToArray(_useState, 2),
        context = _useState2[0],
        setContext = _useState2[1];

    var _useState3 = React.useState([]),
        _useState4 = _slicedToArray(_useState3, 2),
        preInitValue = _useState4[0],
        setPreInitValue = _useState4[1];

    React.useEffect(function () {
      if (context.length === 0 || difference_1(initValue, preInitValue).length !== 0) {
        var dataList = JSON.parse(JSON.stringify(data));
        setContext(_toConsumableArray(dataList).map(function (item) {
          var initItem = item;

          if (initValue.indexOf(initItem.value) !== -1) {
            initItem.flag = true;
          } else {
            initItem.flag = false;
          }

          return initItem;
        }));
        setPreInitValue(initValue);
      }
    }, [data, initValue]);

    var boxClick = function boxClick(e, dataItem) {
      e.stopPropagation();
      if (disabled) return;
      var values = [];
      var newData = context.map(function (item) {
        var selItem = item;
        if (item.value === dataItem.value) selItem.flag = !item.flag;
        if (selItem.flag) values.push(selItem.value);
        return selItem;
      });
      setContext(newData);
      if (onChange) onChange(values);
    };

    return /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-box-content"
    }, _toConsumableArray(context).map(function (item) {
      return /*#__PURE__*/React__default.createElement("div", {
        key: item.value,
        className: classnames({
          'alitajs-dform-box-wrapper': true
        }),
        onClick: function onClick(e) {
          boxClick(e, item);
        }
      }, /*#__PURE__*/React__default.createElement("div", {
        className: classnames({
          'alitajs-dform-box-botton': true,
          'alitajs-dform-box-botton-checked': item.flag
        })
      }, item.flag && /*#__PURE__*/React__default.createElement("div", {
        className: "alitajs-dform-box-tick"
      })), /*#__PURE__*/React__default.createElement("div", {
        className: "alitajs-dform-box-label",
        style: coverStyle
      }, item.label));
    }));
  };

  var NomarCheckBox = function NomarCheckBox(props) {
    var _useState = React.useState([]),
        _useState2 = _slicedToArray(_useState, 2),
        initValue = _useState2[0],
        setInitValue = _useState2[1];

    var coverStyle = props.coverStyle,
        fieldProps = props.fieldProps,
        title = props.title,
        rules = props.rules,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        _props$data = props.data,
        data = _props$data === void 0 ? [] : _props$data,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        subTitle = props.subTitle,
        onChange = props.onChange,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden;
    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-check-box"
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle), /*#__PURE__*/React__default.createElement(CustomField, {
      name: fieldProps,
      rules: rules || [{
        required: required,
        message: "\u8BF7\u9009\u62E9".concat(title)
      }],
      shouldUpdate: function shouldUpdate(prevValue, nextValue) {
        setInitValue(nextValue && nextValue[fieldProps]);
        return prevValue !== nextValue;
      }
    }, /*#__PURE__*/React__default.createElement(CheckBoxGroup, {
      data: data,
      onChange: onChange,
      coverStyle: coverStyle,
      initValue: initValue,
      disabled: disabled
    }))));
  };

  var RadioGroup$1 = function RadioGroup(props) {
    var data = props.data,
        onChange = props.onChange,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'horizontal' : _props$positionType,
        _props$radioType = props.radioType,
        radioType = _props$radioType === void 0 ? 'horizontal' : _props$radioType,
        _props$initValue = props.initValue,
        initValue = _props$initValue === void 0 ? '' : _props$initValue,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        coverStyle = props.coverStyle;

    var _useState = React.useState([]),
        _useState2 = _slicedToArray(_useState, 2),
        context = _useState2[0],
        setContext = _useState2[1];

    var isVertical = positionType === 'vertical';

    if (radioType === 'vertical') {
      isVertical = true;
    }

    React.useEffect(function () {
      var dataList = JSON.parse(JSON.stringify(data));
      setContext(_toConsumableArray(dataList).map(function (item) {
        var initItem = item;

        if (initItem.value === initValue) {
          initItem.flag = true;
        } else {
          initItem.flag = false;
        }

        initItem.moveFlag = false;
        return initItem;
      }));
    }, [data, initValue]);

    var radioMove = function radioMove(flag, val) {
      if (disabled) return;
      setContext(context.map(function (item) {
        var selItem = item;

        if (item.value === val.value) {
          selItem.moveFlag = flag;
        } else {
          selItem.moveFlag = false;
        }

        return selItem;
      }));
    };

    var radioClick = function radioClick(e, dataItem) {
      e.stopPropagation();
      if (disabled) return;
      if (onChange) onChange("".concat(dataItem.value));
      setContext(context.map(function (item) {
        var selItem = item;

        if (item.value === dataItem.value) {
          selItem.flag = true;
        } else {
          selItem.flag = false;
        }

        return selItem;
      }));
    };

    return /*#__PURE__*/React__default.createElement("div", {
      className: classnames({
        'alitajs-dform-cover-radio-group': true,
        'alitajs-dform-cover-radio-position': !isVertical,
        'alitajs-dform-cover-radio-item-vertical': radioType === 'vertical'
      })
    }, _toConsumableArray(context).map(function (item) {
      return /*#__PURE__*/React__default.createElement("div", {
        key: item.value,
        className: classnames({
          'alitajs-dform-cover-radio-wrapper': true,
          'alitajs-dform-cover-radio-wrapper-checked': item.flag,
          'alitajs-dform-cover-radio-wrapper-margin': isVertical,
          'alitajs-dform-cover-radio-wrapper-cover': item.moveFlag && !item.flag
        }),
        style: coverStyle,
        onMouseDown: function onMouseDown() {
          radioMove(true, item);
        },
        onMouseUp: function onMouseUp() {
          radioMove(false, item);
        },
        onClick: function onClick(e) {
          radioClick(e, item);
        }
      }, item.label);
    }));
  };

  var NomarTab = function NomarTab(props) {
    var _useState = React.useState(''),
        _useState2 = _slicedToArray(_useState, 2),
        initValue = _useState2[0],
        setInitValue = _useState2[1];

    var coverStyle = props.coverStyle,
        fieldProps = props.fieldProps,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        rules = props.rules,
        title = props.title,
        data = props.data,
        onChange = props.onChange,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'horizontal' : _props$positionType,
        _props$radioType = props.radioType,
        radioType = _props$radioType === void 0 ? 'horizontal' : _props$radioType,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden,
        subTitle = props.subTitle;
    var isVertical = positionType === 'vertical';

    if (radioType === 'vertical') {
      isVertical = true;
    }

    var RadioGroup = function RadioGroup() {
      return /*#__PURE__*/React__default.createElement(CustomField, {
        name: fieldProps,
        rules: rules || [{
          required: required,
          message: "\u8BF7\u9009\u62E9".concat(title)
        }],
        shouldUpdate: function shouldUpdate(prevValue, nextValue) {
          setInitValue(nextValue && nextValue[fieldProps]);
          return prevValue !== nextValue;
        }
      }, /*#__PURE__*/React__default.createElement(RadioGroup$1, {
        data: data,
        positionType: positionType,
        radioType: radioType,
        initValue: initValue,
        onChange: onChange,
        disabled: disabled,
        coverStyle: coverStyle
      }));
    };

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle), /*#__PURE__*/React__default.createElement("div", {
      className: classnames({
        'alitajs-dform-cover-radio': true,
        'alitajs-dform-vertical-cover-radio': isVertical
      })
    }, /*#__PURE__*/React__default.createElement(_List.Item, {
      key: fieldProps,
      extra: RadioGroup()
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title)))));
  };

  var NomarImagePicker = function NomarImagePicker(props) {
    var coverStyle = props.coverStyle,
        title = props.title,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        fieldProps = props.fieldProps,
        rules = props.rules,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        _props$limitSize = props.limitSize,
        limitSize = _props$limitSize === void 0 ? 0 : _props$limitSize,
        subTitle = props.subTitle,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden,
        otherProps = _objectWithoutProperties(props, ["coverStyle", "title", "required", "fieldProps", "rules", "hasStar", "limitSize", "subTitle", "hidden"]);

    var _useState = React.useState([]),
        _useState2 = _slicedToArray(_useState, 2),
        fileList = _useState2[0],
        setFileList = _useState2[1];

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-image-picker"
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle), /*#__PURE__*/React__default.createElement(CustomField, {
      name: fieldProps,
      rules: rules || [{
        required: required,
        message: "\u8BF7\u9009\u62E9".concat(title)
      }],
      shouldUpdate: function shouldUpdate(prevValue, nextValue) {
        var files = nextValue[fieldProps] || [];

        if (files && files.length > fileList.length) {
          var lastFile = files[files.length - 1];
          var _lastFile$file = lastFile.file,
              file = _lastFile$file === void 0 ? {} : _lastFile$file;

          if (limitSize && file && file.size && file.size > limitSize) {
            _Toast.fail('图片过大', 1);

            return false;
          }
        }

        setFileList(nextValue && nextValue[fieldProps] || []);
        return prevValue !== nextValue;
      }
    }, /*#__PURE__*/React__default.createElement(_ImagePicker, _extends({}, otherProps, {
      files: fileList
    })))));
  };

  var NomarCustom = function NomarCustom(props) {
    var _useState = React.useState(),
        _useState2 = _slicedToArray(_useState, 2),
        initValue = _useState2[0],
        setInitValue = _useState2[1];

    var fieldProps = props.fieldProps,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        rules = props.rules,
        title = props.title,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'vertical' : _props$positionType,
        CustomDom = props.CustomDom,
        customDomProps = props.customDomProps,
        subTitle = props.subTitle,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden;
    var isVertical = positionType === 'vertical';

    var dom = function dom() {
      return /*#__PURE__*/React__default.createElement(CustomField, {
        name: fieldProps,
        rules: rules || [{
          required: required,
          message: "\u8BF7\u9009\u62E9".concat(title)
        }],
        shouldUpdate: function shouldUpdate(prevValue, nextValue) {
          setInitValue(nextValue && nextValue[fieldProps]);
          return prevValue !== nextValue;
        }
      }, /*#__PURE__*/React__default.createElement(CustomDom, _extends({}, customDomProps, {
        initValue: initValue
      })));
    };

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle), /*#__PURE__*/React__default.createElement("div", {
      className: classnames({
        'alitajs-dform-dom': true,
        'alitajs-dform-vertical-dom': isVertical
      })
    }, /*#__PURE__*/React__default.createElement(_List.Item, {
      key: fieldProps,
      extra: dom()
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title)))));
  };

  var Item = _List.Item;

  var MultiplePickerGroup = function MultiplePickerGroup(props) {
    var _props$data = props.data,
        data = _props$data === void 0 ? [] : _props$data,
        title = props.title,
        _props$placeholder = props.placeholder,
        placeholder = _props$placeholder === void 0 ? '请选择' : _props$placeholder,
        onChange = props.onChange,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'horizontal' : _props$positionType,
        _props$initValue = props.initValue,
        initValue = _props$initValue === void 0 ? [] : _props$initValue,
        maxValueLength = props.maxValueLength,
        coverStyle = props.coverStyle,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        fieldProps = props.fieldProps,
        _props$labelNumber = props.labelNumber,
        labelNumber = _props$labelNumber === void 0 ? 5 : _props$labelNumber,
        _onClick = props.onClick;

    var _useState = React.useState([]),
        _useState2 = _slicedToArray(_useState, 2),
        context = _useState2[0],
        setContext = _useState2[1];

    var _useState3 = React.useState([]),
        _useState4 = _slicedToArray(_useState3, 2),
        preContext = _useState4[0],
        setPreContext = _useState4[1];

    var _useState5 = React.useState([]),
        _useState6 = _slicedToArray(_useState5, 2),
        preInitValue = _useState6[0],
        setPreInitValue = _useState6[1];

    var _useState7 = React.useState([]),
        _useState8 = _slicedToArray(_useState7, 2),
        selList = _useState8[0],
        setSelList = _useState8[1];

    var _useState9 = React.useState(false),
        _useState10 = _slicedToArray(_useState9, 2),
        modalFlag = _useState10[0],
        setModalFlag = _useState10[1];

    var _useState11 = React.useState(''),
        _useState12 = _slicedToArray(_useState11, 2),
        multipleLabel = _useState12[0],
        setMultipleLabel = _useState12[1];

    var isVertical = positionType === 'vertical';
    React.useEffect(function () {
      if (!data || data.length === 0) return;

      if (context.length === 0 || difference_1(initValue, preInitValue).length !== 0) {
        var dataList = JSON.parse(JSON.stringify(data));
        var selLabelList = [];
        var selValueList = [];
        setContext(_toConsumableArray(dataList).map(function (item) {
          var initItem = item;

          if (initValue.indexOf(initItem.value) !== -1) {
            if (!maxValueLength || maxValueLength && maxValueLength > selValueList.length) {
              initItem.flag = true;
              selLabelList.push(item.label);
              selValueList.push(item.value);
            } else {
              initItem.flag = false;
            }
          } else {
            initItem.flag = false;
          }

          return initItem;
        }));
        setMultipleLabel(selLabelList.join(','));
        setPreInitValue(initValue);
        setSelList(selValueList);
      }
    }, [data, initValue]);

    var pickerClick = function pickerClick(val) {
      var dataList = JSON.parse(JSON.stringify(context));

      if (selList.indexOf(val.value) !== -1) {
        selList.splice(selList.indexOf(val.value), 1);
      } else {
        selList.push(val.value);
      }

      if (maxValueLength && selList.length > maxValueLength) {
        selList.shift();
      }

      setContext(_toConsumableArray(dataList).map(function (item) {
        var initItem = item;

        if (selList.indexOf(initItem.value) !== -1) {
          initItem.flag = true;
        } else {
          initItem.flag = false;
        }

        return initItem;
      }));
    };

    var openMoal = function openMoal() {
      if (disabled) return;
      setPreContext(_toConsumableArray(context));
      setModalFlag(true);
    };

    var onCancel = function onCancel() {
      setModalFlag(false);
      setContext(_toConsumableArray(preContext));
    };

    var onConfirm = function onConfirm() {
      var selLabelList = context.filter(function (it) {
        return it.flag;
      }).map(function (item) {
        return item.label;
      });
      var selValueList = context.filter(function (it) {
        return it.flag;
      }).map(function (item) {
        return item.value;
      });
      setMultipleLabel(selLabelList.join(','));
      setModalFlag(false);
      if (onChange) onChange(selValueList);
    };

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(InputItem, {
      isVertical: isVertical,
      value: multipleLabel,
      placeholder: placeholder,
      labelNumber: labelNumber,
      coverStyle: coverStyle,
      onClick: function onClick() {
        if (_onClick) _onClick();
        openMoal();
      },
      readOnly: true
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title)), /*#__PURE__*/React__default.createElement(_Modal, {
      popup: true,
      visible: modalFlag,
      onClose: function onClose() {
        onCancel();
      },
      className: "alitajs-dform-multiple-picker",
      animationType: "slide-up",
      title: /*#__PURE__*/React__default.createElement("div", {
        className: "am-picker-popup-header"
      }, /*#__PURE__*/React__default.createElement("div", {
        className: "am-picker-popup-item am-picker-popup-header-left",
        onClick: function onClick() {
          onCancel();
        }
      }, "\u53D6\u6D88"), /*#__PURE__*/React__default.createElement("div", {
        className: "am-picker-popup-item am-picker-popup-title"
      }, title), /*#__PURE__*/React__default.createElement("div", {
        className: "am-picker-popup-item am-picker-popup-header-right",
        onClick: function onClick() {
          onConfirm();
        }
      }, "\u786E\u5B9A"))
    }, /*#__PURE__*/React__default.createElement(_List, {
      className: "alitajs-dform-modal-content"
    }, _toConsumableArray(context).map(function (item) {
      return /*#__PURE__*/React__default.createElement(Item, {
        key: item.value
      }, /*#__PURE__*/React__default.createElement("div", {
        className: "alitajs-dform-multiple-picker-item",
        onClick: function onClick() {
          pickerClick(item);
        }
      }, /*#__PURE__*/React__default.createElement("div", {
        className: classnames({
          'alitajs-dform-multiple-picker-label': true,
          'alitajs-dform-multiple-picker-checked': item.flag
        })
      }, item.label), item.flag && /*#__PURE__*/React__default.createElement("div", {
        className: "alitajs-dform-tick"
      })));
    }))));
  };

  var MultiplePicker = function MultiplePicker(props) {
    var _useState = React.useState([]),
        _useState2 = _slicedToArray(_useState, 2),
        initValue = _useState2[0],
        setInitValue = _useState2[1];

    var fieldProps = props.fieldProps,
        rules = props.rules,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        title = props.title,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'horizontal' : _props$positionType,
        subTitle = props.subTitle,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden;
    var isVertical = positionType === 'vertical';
    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-input-title"
    }, isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle)), /*#__PURE__*/React__default.createElement(CustomField, {
      name: fieldProps,
      rules: rules || [{
        required: required,
        message: "\u8BF7\u9009\u62E9".concat(title)
      }],
      shouldUpdate: function shouldUpdate(prevValue, nextValue) {
        setInitValue(nextValue && nextValue[fieldProps]);
        return prevValue !== nextValue;
      }
    }, /*#__PURE__*/React__default.createElement(MultiplePickerGroup, _extends({}, props, {
      initValue: initValue
    }), required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title)))));
  };

  var InputItem = function InputItem(props) {
    var _props$isVertical = props.isVertical,
        isVertical = _props$isVertical === void 0 ? false : _props$isVertical,
        _props$value = props.value,
        value = _props$value === void 0 ? '' : _props$value,
        _props$placeholder = props.placeholder,
        placeholder = _props$placeholder === void 0 ? '' : _props$placeholder,
        onClick = props.onClick,
        _props$readOnly = props.readOnly,
        readOnly = _props$readOnly === void 0 ? false : _props$readOnly,
        onChange = props.onChange,
        _props$labelNumber = props.labelNumber,
        labelNumber = _props$labelNumber === void 0 ? 5 : _props$labelNumber,
        _props$coverStyle = props.coverStyle,
        coverStyle = _props$coverStyle === void 0 ? {} : _props$coverStyle;
    var labelCls = classnames('am-input-label', 'alitajs-dform-input-tltle', {
      'am-input-label-2': labelNumber === 2,
      'am-input-label-3': labelNumber === 3,
      'am-input-label-4': labelNumber === 4,
      'am-input-label-5': labelNumber === 5,
      'am-input-label-6': labelNumber === 6,
      'am-input-label-7': labelNumber === 7
    });

    var inputItemClick = function inputItemClick() {
      if (onClick) onClick();
    };

    var inputItemChange = function inputItemChange(e) {
      if (onChange) onChange(e);
    };

    return /*#__PURE__*/React__default.createElement("div", {
      className: "am-list-item am-list-item-middle alitajs-dform-input-item"
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "am-list-line"
    }, !isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: labelCls
    }, props.children), /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-input-value",
      style: {
        // width: isVertical ? '100%' : '60%',
        flex: '1'
      },
      onClick: function onClick() {
        inputItemClick();
      }
    }, /*#__PURE__*/React__default.createElement("input", {
      type: "text",
      value: value,
      readOnly: readOnly,
      style: _objectSpread2({
        textAlign: isVertical ? 'left' : 'right'
      }, coverStyle),
      onChange: function onChange(e) {
        inputItemChange(e);
      },
      className: "alitajs-dform-input-text",
      placeholder: placeholder
    }), /*#__PURE__*/React__default.createElement("img", {
      className: "alitajs-dform-right",
      src: "data:image/svg+xml;charset=utf-8,%3Csvg%20width%3D%2216%22%20height%3D%2226%22%20viewBox%3D%220%200%2016%2026%22%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%3E%3Cg%20id%3D%22UI-KIT_%E5%9F%BA%E7%A1%80%E5%85%83%E4%BB%B6%22%20stroke%3D%22none%22%20stroke-width%3D%221%22%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%3Cg%20id%3D%229.9%E5%9F%BA%E7%A1%80%E5%85%83%E4%BB%B6%22%20transform%3D%22translate(-5809.000000%2C%20-8482.000000)%22%20fill%3D%22%23C7C7CC%22%3E%3Cpolygon%20id%3D%22Disclosure-Indicator%22%20points%3D%225811%208482%205809%208484%205820.5%208495%205809%208506%205811%208508%205825%208495%22%3E%3C%2Fpolygon%3E%3C%2Fg%3E%3C%2Fg%3E%3C%2Fsvg%3E",
      alt: ""
    }))));
  };

  var Item$1 = _List.Item;

  var AddressPickerGroup = function AddressPickerGroup(props) {
    var _props$data = props.data,
        data = _props$data === void 0 ? [] : _props$data,
        _props$placeholder = props.placeholder,
        placeholder = _props$placeholder === void 0 ? '请选择' : _props$placeholder,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'horizontal' : _props$positionType,
        title = props.title,
        _props$disabled = props.disabled,
        disabled = _props$disabled === void 0 ? false : _props$disabled,
        onChangeLevel = props.onChangeLevel,
        onChange = props.onChange,
        _props$level = props.level,
        level = _props$level === void 0 ? 3 : _props$level,
        _props$placeholderLis = props.placeholderList,
        placeholderList = _props$placeholderLis === void 0 ? [] : _props$placeholderLis,
        _props$initValue = props.initValue,
        initValue = _props$initValue === void 0 ? {} : _props$initValue,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        fieldProps = props.fieldProps,
        _props$labelNumber = props.labelNumber,
        labelNumber = _props$labelNumber === void 0 ? 5 : _props$labelNumber,
        coverStyle = props.coverStyle,
        _onClick = props.onClick; // input 框的值

    var _useState = React.useState(''),
        _useState2 = _slicedToArray(_useState, 2),
        inputLabel = _useState2[0],
        setInputLabel = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray(_useState3, 2),
        modalFlag = _useState4[0],
        setModalFlag = _useState4[1];

    var _useState5 = React.useState(true),
        _useState6 = _slicedToArray(_useState5, 2),
        changeFlag = _useState6[0],
        setChangeFlag = _useState6[1]; // 弹框选中的头部文字列表


    var _useState7 = React.useState(placeholderList && placeholderList.length ? [placeholderList[0]] : ['请选择']),
        _useState8 = _slicedToArray(_useState7, 2),
        labelList = _useState8[0],
        setLabelList = _useState8[1]; // value 值列表


    var _useState9 = React.useState([]),
        _useState10 = _slicedToArray(_useState9, 2),
        valueList = _useState10[0],
        setValueList = _useState10[1]; // 当前列表数据


    var _useState11 = React.useState([]),
        _useState12 = _slicedToArray(_useState11, 2),
        dataList = _useState12[0],
        setDataList = _useState12[1]; // 当前所在层级数字


    var _useState13 = React.useState(0),
        _useState14 = _slicedToArray(_useState13, 2),
        nowLevel = _useState14[0],
        setNowLevel = _useState14[1];

    var isVertical = positionType === 'vertical';
    React.useEffect(function () {
      if (onChange) onChange({
        label: [],
        value: []
      });
    }, []);
    React.useEffect(function () {
      if (data.length === 0) return;
      setDataList(data.map(function (item) {
        var newItem = item;

        if (newItem.value === valueList[valueList.length - 1]) {
          newItem.flag = true;
        } else newItem.flag = false;

        return newItem;
      }));
    }, [data]);
    React.useEffect(function () {
      if (initValue && Object.keys(initValue).length && changeFlag) {
        var _initValue$label = initValue.label,
            label = _initValue$label === void 0 ? [] : _initValue$label,
            _initValue$value = initValue.value,
            value = _initValue$value === void 0 ? [] : _initValue$value;
        setDataList(data.map(function (item) {
          var newItem = item;

          if (newItem.value === value[value.length]) {
            newItem.flag = true;
          } else newItem.flag = false;

          return newItem;
        }));
        var newLabelList = resetLabel(JSON.parse(JSON.stringify(_toConsumableArray(label))), placeholderList);
        setLabelList(newLabelList);
        setNowLevel(value.length);
        if (onChangeLevel) onChangeLevel(value);
        setInputLabel(label.join(','));
        setValueList(value);
        setChangeFlag(false);
      }
    }, [initValue]);

    var openMoal = function openMoal() {
      if (disabled) return;
      setModalFlag(true);
    };

    var onCancel = function onCancel() {
      setModalFlag(false);
    };

    var onConfirm = function onConfirm() {
      var newLabelList = JSON.parse(JSON.stringify(labelList));
      if (nowLevel !== level) newLabelList.pop();
      setInputLabel(newLabelList.join(','));
      if (onChange) onChange({
        label: newLabelList,
        value: valueList
      });
      setModalFlag(false);
    };

    var listClick = function listClick(val) {
      // 选中数据的时候刷新列表
      setDataList(_toConsumableArray(dataList).map(function (item) {
        var newItem = item;
        if (item.value === val.value) newItem.flag = true;else newItem.flag = false;
        return newItem;
      }));
      var newList = JSON.parse(JSON.stringify(labelList));
      var newValueList = JSON.parse(JSON.stringify(valueList)); // 设置当前层级

      newList.splice(newList.length - 1, 1, val.label);
      var insLevel = nowLevel;
      if (nowLevel !== level) insLevel += 1;
      setNowLevel(insLevel); // 如果层级符合，将数据放入input 中，并且关闭弹框

      var newLabelList = JSON.parse(JSON.stringify(newList));

      if (insLevel === level) {
        if (insLevel !== level) newLabelList.pop();
        setInputLabel(newLabelList.join(','));
        if (onChange) onChange({
          label: newLabelList,
          value: newValueList
        });
        setModalFlag(false);
      }

      if (newValueList.length === insLevel) {
        newValueList.pop();
      }

      newValueList.push(val.value); // 设置头部展示列表和值列表

      setLabelList(resetLabel(newList, placeholderList));
      setValueList(newValueList); // 调用改变层级的事件给用户

      if (onChangeLevel) onChangeLevel(newValueList);
    };

    var labelClick = function labelClick(index) {
      // 设置当前的层级
      setNowLevel(index);
      var newLabelList = labelList.splice(0, index);
      var newValueList = valueList.splice(0, index); // 设置头部展示列表

      setLabelList(resetLabel(JSON.parse(JSON.stringify(newLabelList)), placeholderList));
      setValueList(newValueList); // 调用改变层级的事件给用户

      if (onChangeLevel) onChangeLevel(newValueList);
    };

    var listReverse = []; // eslint-disable-next-line no-plusplus

    for (var i = labelList.length; i < 4; i++) {
      listReverse.push(Math.random().toString(36).substring(7));
    }

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(InputItem, {
      isVertical: isVertical,
      value: inputLabel,
      placeholder: placeholder,
      readOnly: true,
      coverStyle: coverStyle,
      labelNumber: labelNumber,
      onClick: function onClick() {
        if (_onClick) _onClick();
        openMoal();
      },
      onChange: function onChange(e) {
        setInputLabel(e.target.value);
      }
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title)), /*#__PURE__*/React__default.createElement(_Modal, {
      popup: true,
      visible: modalFlag,
      onClose: function onClose() {
        onCancel();
      },
      className: "alitajs-dform-address",
      animationType: "slide-up",
      title: /*#__PURE__*/React__default.createElement("div", {
        className: "am-picker-popup-header"
      }, /*#__PURE__*/React__default.createElement("div", {
        className: "am-picker-popup-item am-picker-popup-header-left",
        onClick: function onClick() {
          onCancel();
        }
      }, "\u53D6\u6D88"), /*#__PURE__*/React__default.createElement("div", {
        className: "am-picker-popup-item am-picker-popup-title"
      }, title), /*#__PURE__*/React__default.createElement("div", {
        className: "am-picker-popup-item am-picker-popup-header-right",
        onClick: function onClick() {
          onConfirm();
        }
      }, "\u786E\u5B9A"))
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-address-content"
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-address-value"
    }, /*#__PURE__*/React__default.createElement(_Flex, {
      align: "start"
    }, _toConsumableArray(labelList).map(function (label, index) {
      return /*#__PURE__*/React__default.createElement(_Flex.Item, {
        key: label,
        className: classnames({
          'alitajs-dform-address-value-item': true
        }),
        onClick: function onClick() {
          labelClick(index);
        }
      }, /*#__PURE__*/React__default.createElement("div", {
        className: classnames({
          'alitajs-dform-address-value-item-label': true,
          'alitajs-dform-address-value-select': index + 1 === labelList.length
        })
      }, label));
    }), listReverse.map(function (val) {
      return /*#__PURE__*/React__default.createElement(_Flex.Item, {
        key: val
      });
    }))), /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-address-list"
    }, /*#__PURE__*/React__default.createElement(_List, null, _toConsumableArray(dataList).map(function (item) {
      return /*#__PURE__*/React__default.createElement(Item$1, {
        key: item.value
      }, /*#__PURE__*/React__default.createElement("div", {
        className: "alitajs-dform-address-list-content",
        onClick: function onClick() {
          listClick(item);
        }
      }, /*#__PURE__*/React__default.createElement("div", null, item.label), item.flag && /*#__PURE__*/React__default.createElement("div", {
        className: "alitajs-dform-tick"
      })));
    }))))));
  };

  var AddressPicker = function AddressPicker(props) {
    var _useState = React.useState([]),
        _useState2 = _slicedToArray(_useState, 2),
        initValue = _useState2[0],
        setInitValue = _useState2[1];

    var fieldProps = props.fieldProps,
        rules = props.rules,
        _props$required = props.required,
        required = _props$required === void 0 ? false : _props$required,
        title = props.title,
        _props$hasStar = props.hasStar,
        hasStar = _props$hasStar === void 0 ? true : _props$hasStar,
        _props$positionType = props.positionType,
        positionType = _props$positionType === void 0 ? 'horizontal' : _props$positionType,
        subTitle = props.subTitle,
        _props$hidden = props.hidden,
        hidden = _props$hidden === void 0 ? false : _props$hidden;
    var isVertical = positionType === 'vertical';
    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, !hidden && /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-input-title"
    }, isVertical && /*#__PURE__*/React__default.createElement("div", {
      className: "alitajs-dform-vertical-title"
    }, required && hasStar && /*#__PURE__*/React__default.createElement("span", {
      className: "alitajs-dform-redStar"
    }, "*"), /*#__PURE__*/React__default.createElement("span", {
      id: fieldProps,
      className: "alitajs-dform-title"
    }, title), subTitle)), /*#__PURE__*/React__default.createElement(CustomField, {
      name: fieldProps,
      rules: rules || [{
        required: required,
        message: "\u8BF7\u9009\u62E9".concat(title)
      }],
      shouldUpdate: function shouldUpdate(prevValue, nextValue) {
        setInitValue(nextValue && nextValue[fieldProps]);
        return prevValue !== nextValue;
      }
    }, /*#__PURE__*/React__default.createElement(AddressPickerGroup, _extends({}, props, {
      initValue: initValue
    })))));
  };

  var toggleSelection = function () {
    var selection = document.getSelection();
    if (!selection.rangeCount) {
      return function () {};
    }
    var active = document.activeElement;

    var ranges = [];
    for (var i = 0; i < selection.rangeCount; i++) {
      ranges.push(selection.getRangeAt(i));
    }

    switch (active.tagName.toUpperCase()) { // .toUpperCase handles XHTML
      case 'INPUT':
      case 'TEXTAREA':
        active.blur();
        break;

      default:
        active = null;
        break;
    }

    selection.removeAllRanges();
    return function () {
      selection.type === 'Caret' &&
      selection.removeAllRanges();

      if (!selection.rangeCount) {
        ranges.forEach(function(range) {
          selection.addRange(range);
        });
      }

      active &&
      active.focus();
    };
  };

  var clipboardToIE11Formatting = {
    "text/plain": "Text",
    "text/html": "Url",
    "default": "Text"
  };

  var defaultMessage = "Copy to clipboard: #{key}, Enter";

  function format$2(message) {
    var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
    return message.replace(/#{\s*key\s*}/g, copyKey);
  }

  function copy(text, options) {
    var debug,
      message,
      reselectPrevious,
      range,
      selection,
      mark,
      success = false;
    if (!options) {
      options = {};
    }
    debug = options.debug || false;
    try {
      reselectPrevious = toggleSelection();

      range = document.createRange();
      selection = document.getSelection();

      mark = document.createElement("span");
      mark.textContent = text;
      // reset user styles for span element
      mark.style.all = "unset";
      // prevents scrolling to the end of the page
      mark.style.position = "fixed";
      mark.style.top = 0;
      mark.style.clip = "rect(0, 0, 0, 0)";
      // used to preserve spaces and line breaks
      mark.style.whiteSpace = "pre";
      // do not inherit user-select (it may be `none`)
      mark.style.webkitUserSelect = "text";
      mark.style.MozUserSelect = "text";
      mark.style.msUserSelect = "text";
      mark.style.userSelect = "text";
      mark.addEventListener("copy", function(e) {
        e.stopPropagation();
        if (options.format) {
          e.preventDefault();
          if (typeof e.clipboardData === "undefined") { // IE 11
            debug && console.warn("unable to use e.clipboardData");
            debug && console.warn("trying IE specific stuff");
            window.clipboardData.clearData();
            var format = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
            window.clipboardData.setData(format, text);
          } else { // all other browsers
            e.clipboardData.clearData();
            e.clipboardData.setData(options.format, text);
          }
        }
        if (options.onCopy) {
          e.preventDefault();
          options.onCopy(e.clipboardData);
        }
      });

      document.body.appendChild(mark);

      range.selectNodeContents(mark);
      selection.addRange(range);

      var successful = document.execCommand("copy");
      if (!successful) {
        throw new Error("copy command was unsuccessful");
      }
      success = true;
    } catch (err) {
      debug && console.error("unable to copy using execCommand: ", err);
      debug && console.warn("trying IE specific stuff");
      try {
        window.clipboardData.setData(options.format || "text", text);
        options.onCopy && options.onCopy(window.clipboardData);
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using clipboardData: ", err);
        debug && console.error("falling back to prompt");
        message = format$2("message" in options ? options.message : defaultMessage);
        window.prompt(message, text);
      }
    } finally {
      if (selection) {
        if (typeof selection.removeRange == "function") {
          selection.removeRange(range);
        } else {
          selection.removeAllRanges();
        }
      }

      if (mark) {
        document.body.removeChild(mark);
      }
      reselectPrevious();
    }

    return success;
  }

  var copyToClipboard = copy;

  var FormItemType = {
    input: NomarInput,
    select: NomarPicker,
    area: NomarTextArea,
    date: NomarDatePicker,
    switch: NomarSwitch,
    radio: NomarRadio,
    extraInput: ExtraInput,
    rangeDatePicker: RangeDatePicker,
    coverRadio: NomarTab,
    multiplePicker: MultiplePicker,
    image: NomarImagePicker,
    checkbox: NomarCheckBox
  };
  var radioList = [{
    label: '是',
    value: 'yes'
  }, {
    label: '否',
    value: 'no'
  }];
  var EditFormItemLabel = {
    title: '标题',
    fieldProps: '绑定关键字',
    required: '是否必填',
    placeholder: '输入提示',
    disabled: '是否可编辑',
    data: '表单数据',
    inputType: '输入框类型',
    modeType: '选择器类型',
    fieldProps2: '副绑定关键字',
    placeholder2: '副输入提示',
    extraType: '扩展类型',
    type: '类型',
    positionType: '位置'
  }; // inputType:'text' | 'bankCard' | 'phone' | 'password' | 'number' | 'digit' | 'money';
  // modeType:mode?: 'datetime' | 'date' | 'year' | 'month' | 'time';

  var EditFormItemType = {
    title: NomarInput,
    fieldProps: NomarInput,
    required: NomarSwitch,
    placeholder: NomarInput,
    disabled: NomarRadio,
    data: NomarInput,
    type: NomarInput,
    positionType: function positionType(props) {
      return /*#__PURE__*/React__default.createElement(NomarPicker, _extends({
        data: [['horizontal', 'vertical'].map(function (item) {
          return {
            value: item,
            label: item
          };
        })],
        cols: 1
      }, props));
    },
    inputType: function inputType(props) {
      return /*#__PURE__*/React__default.createElement(NomarPicker, _extends({
        data: [['text', 'bankCard', 'phone', 'password', 'number', 'digit', 'money'].map(function (item) {
          return {
            value: item,
            label: item
          };
        })],
        cols: 1
      }, props));
    },
    modeType: function modeType(props) {
      return /*#__PURE__*/React__default.createElement(NomarPicker, _extends({
        data: [['datetime', 'date', 'year', 'month', 'time'].map(function (item) {
          return {
            value: item,
            label: item
          };
        })],
        cols: 1
      }, props));
    },
    fieldProps2: NomarInput,
    placeholder2: NomarInput,
    extraType: function extraType(props) {
      return /*#__PURE__*/React__default.createElement(NomarPicker, _extends({
        data: [['input', 'select'].map(function (item) {
          return {
            value: item,
            label: item
          };
        })],
        cols: 1
      }, props));
    }
  };

  var getFormItem = function getFormItem(fieldItemKey) {
    var EditFormItemComponent = EditFormItemType[fieldItemKey];
    var title = EditFormItemLabel[fieldItemKey];
    return /*#__PURE__*/React__default.createElement(EditFormItemComponent, {
      key: "alita-dform-edit-".concat(fieldItemKey),
      fieldProps: fieldItemKey,
      title: title,
      editable: fieldItemKey !== 'type'
    });
  };

  var getShowDeitItem = function getShowDeitItem(editData) {
    if (!editData) return;
    var _ref = editData,
        inputType = _ref.inputType,
        modeType = _ref.modeType,
        extraType = _ref.extraType,
        positionType = _ref.positionType;

    var _ref2 = editData,
        type = _ref2.type,
        otherProps = _objectWithoutProperties(_ref2, ["type"]); // 选择类型的初始值要手动转化一下 2/3


    if (inputType) {
      inputType = inputType[0];
      otherProps.inputType = inputType;
    }

    if (modeType) {
      modeType = modeType[0];
      otherProps.modeType = modeType;
    }

    if (extraType) {
      extraType = extraType[0];
      otherProps.extraType = extraType;
    }

    if (positionType) {
      // eslint-disable-next-line prefer-destructuring
      positionType = positionType[0];
      otherProps.positionType = positionType;
    }

    var ShowItemComponent = FormItemType[type]; // eslint-disable-next-line consistent-return

    return /*#__PURE__*/React__default.createElement(ShowItemComponent, otherProps);
  };

  var defaultFailed = function defaultFailed(errorInfo, onFinishFailed) {
    if (!errorInfo || !errorInfo.errorFields || errorInfo.errorFields.length === 0) {
      if (onFinishFailed) {
        onFinishFailed(errorInfo);
      }

      return;
    }

    var scrollToField = function scrollToField(fieldKey) {
      var labelNode = document.getElementById("aliat-dform-".concat(fieldKey));

      if (labelNode) {
        labelNode.scrollIntoView(true);
      }
    };

    scrollToField(errorInfo.errorFields[0].name[0]);
    if (onFinishFailed) onFinishFailed(errorInfo);
  };

  var EditForm = function EditForm(_ref3) {
    var _ref3$data = _ref3.data,
        data = _ref3$data === void 0 ? [] : _ref3$data,
        onChange = _ref3.onChange;

    var _useForm = useForm(),
        _useForm2 = _slicedToArray(_useForm, 1),
        form = _useForm2[0]; // 选择类型的初始值要手动转化一下 1/3


    if (data.fieldProps) {
      // 加了随机数
      data.fieldProps = "".concat(Math.random().toString(36).slice(2, 6)).concat(data.fieldProps);
    }

    if (data.fieldProps2) {
      // 加了随机数
      data.fieldProps2 = "".concat(Math.random().toString(36).slice(2, 6)).concat(data.fieldProps2);
    }

    if (data.inputType) {
      data.inputType = [data.inputType];
    }

    if (data.modeType) {
      data.modeType = [data.modeType];
    }

    if (data.extraType) {
      data.extraType = [data.extraType];
    }

    if (data.positionType) {
      data.positionType = [data.positionType];
    }

    var _useState = React.useState(_objectSpread2({}, data)),
        _useState2 = _slicedToArray(_useState, 2),
        editData = _useState2[0],
        setEditData = _useState2[1];

    var onFinish = function onFinish(values) {
      // eslint-disable-next-line no-console
      console.log('Success:', values); // 选择类型的初始值要手动转化一下 3/3

      var newFormItem = _objectSpread2({}, values);

      var inputType = newFormItem.inputType,
          modeType = newFormItem.modeType,
          extraType = newFormItem.extraType,
          type = newFormItem.type,
          positionType = newFormItem.positionType;

      if (inputType && typeof inputType !== 'string') {
        newFormItem.inputType = inputType[0];
      }

      if (modeType && typeof modeType !== 'string') {
        newFormItem.modeType = modeType[0];
      }

      if (extraType && typeof extraType !== 'string') {
        newFormItem.extraType = extraType[0];
      }

      if (positionType && typeof positionType !== 'string') {
        newFormItem.positionType = positionType[0];
      }

      if (type === 'radio' || type === 'coverRadio' || type === 'checkbox' || type === 'multiplePicker') {
        newFormItem.data = radioList;
      }

      if (type === 'select' || type === 'extraInput') {
        newFormItem.data = [radioList];
      } // newFormItem.type = 'input';


      if (onChange) onChange(newFormItem);
    };

    var _onFinishFailed = function onFinishFailed(errorInfo) {
      // eslint-disable-next-line no-console
      console.log('Failed:', errorInfo);
    };

    return /*#__PURE__*/React__default.createElement("div", {
      style: {
        textAlign: 'left'
      }
    }, /*#__PURE__*/React__default.createElement(RefForm, null, /*#__PURE__*/React__default.createElement(_List, {
      renderHeader: function renderHeader() {
        return '效果演示';
      }
    }, getShowDeitItem(editData))), /*#__PURE__*/React__default.createElement(RefForm, {
      form: form,
      initialValues: _objectSpread2({}, editData),
      onFinish: onFinish,
      onFinishFailed: function onFinishFailed(errorInfo) {
        return defaultFailed(errorInfo, _onFinishFailed);
      },
      onValuesChange: function onValuesChange(changFeil) {
        var newData = _objectSpread2({}, editData, {}, changFeil);

        setEditData(newData);
      }
    }, /*#__PURE__*/React__default.createElement(_List, {
      renderHeader: function renderHeader() {
        return '编辑数据';
      }
    }, Object.keys(data || {}).filter(function (i) {
      return i !== 'data';
    }) // .filter(i => i !== 'type' && i !== 'data')
    .map(function (fieldItemKey) {
      return getFormItem(fieldItemKey);
    })), /*#__PURE__*/React__default.createElement(_WhiteSpace, {
      size: "lg"
    }), /*#__PURE__*/React__default.createElement(WrapperField, null, /*#__PURE__*/React__default.createElement(_Button, {
      type: "primary",
      onClick: function onClick() {
        return form.submit();
      }
    }, "\u5B8C\u6210"))));
  };

  var radioList$1 = [{
    label: '是',
    value: 'yes'
  }, {
    label: '否',
    value: 'no'
  }];
  var seasons = [[{
    label: '2013',
    value: '2013'
  }, {
    label: '2014',
    value: '2014'
  }], [{
    label: '春',
    value: '春'
  }, {
    label: '夏',
    value: '夏'
  }]];
  var seasonsUti = [[{
    label: '元',
    value: '元'
  }, {
    label: '亿元',
    value: '亿元'
  }]];
  var InitFormData = [{
    type: 'input',
    fieldProps: 'username',
    required: true,
    placeholder: '请输入',
    title: '输入框',
    inputType: 'text',
    positionType: 'horizontal'
  }, {
    type: 'select',
    fieldProps: 'userdata',
    required: true,
    placeholder: '请选择',
    title: '选择框',
    data: seasons,
    positionType: 'horizontal'
  }, {
    type: 'area',
    fieldProps: 'usertextarea',
    required: true,
    positionType: 'vertical',
    placeholder: '请输入',
    title: '多行输入框'
  }, {
    type: 'date',
    fieldProps: 'userDataPicker',
    required: true,
    placeholder: '请选择',
    title: '时间选择框',
    modeType: 'datetime',
    positionType: 'horizontal'
  }, {
    type: 'switch',
    fieldProps: 'userswitch1',
    required: true,
    placeholder: '请选择',
    title: '开关',
    positionType: 'horizontal'
  }, {
    type: 'radio',
    fieldProps: 'userRadio1',
    required: true,
    placeholder: '请选择',
    title: 'radio框',
    data: radioList$1,
    positionType: 'horizontal'
  }, {
    type: 'extraInput',
    fieldProps: 'extraInput5',
    fieldProps2: 'extraInput6',
    required: true,
    placeholder: '请输入',
    placeholder2: '请选择',
    title: '多类型输入框',
    data: seasonsUti,
    extraType: 'select',
    positionType: 'vertical'
  }, {
    type: 'rangeDatePicker',
    fieldProps: 'datePicker1',
    fieldProps2: 'datePicker2',
    required: true,
    placeholder: '请输入',
    placeholder2: '请选择',
    title: '时间区间选择框',
    modeType: 'datetime',
    positionType: 'vertical'
  }, {
    type: 'coverRadio',
    fieldProps: 'cover',
    required: true,
    title: '覆盖式Radio框',
    data: radioList$1,
    positionType: 'horizontal'
  }, {
    type: 'multiplePicker',
    fieldProps: 'multiplePicker',
    required: true,
    title: '多选弹窗列表框',
    data: radioList$1,
    positionType: 'horizontal'
  }, {
    type: 'image',
    fieldProps: 'image',
    required: true,
    title: '图片上传'
  }, {
    type: 'checkbox',
    fieldProps: 'box1',
    required: true,
    title: '多选框',
    data: radioList$1
  }];
  var InitFormValue = {
    username: '张三'
  };

  var NewFieldPicker = function NewFieldPicker(_ref) {
    var value = _ref.value;

    var _useState = React.useState(false),
        _useState2 = _slicedToArray(_useState, 2),
        modal = _useState2[0],
        setModal = _useState2[1];

    var _useState3 = React.useState(false),
        _useState4 = _slicedToArray(_useState3, 2),
        modal2 = _useState4[0],
        setModal2 = _useState4[1];

    var _useState5 = React.useState(),
        _useState6 = _slicedToArray(_useState5, 2),
        selectFieldItem = _useState6[0],
        setSelectFieldItem = _useState6[1];

    var _useState7 = React.useState(value || []),
        _useState8 = _slicedToArray(_useState7, 2),
        alitaDformExtraField = _useState8[0],
        setAlitaDformExtraField = _useState8[1];

    var onSelectFieldItem = function onSelectFieldItem(formItem) {
      alitaDformExtraField.push(_objectSpread2({}, formItem));
      setAlitaDformExtraField(alitaDformExtraField); // onChange && onChange(alitaDformExtraField);

      setModal2(false);
    };

    var onFinish = function onFinish(values) {
      // eslint-disable-next-line no-console
      console.log('Success:', values);
    };

    var onFinishFailed = function onFinishFailed(errorInfo) {
      // eslint-disable-next-line no-console
      console.log('Failed:', errorInfo);
    };

    var defaultFailed = function defaultFailed(errorInfo) {
      if (!errorInfo || !errorInfo.errorFields || errorInfo.errorFields.length === 0 || onFinishFailed) {
        onFinishFailed(errorInfo);
        return;
      }

      var scrollToField = function scrollToField(fieldKey) {
        var labelNode = document.getElementById("aliat-dform-".concat(fieldKey));

        if (labelNode) {
          labelNode.scrollIntoView(true);
        }
      };

      scrollToField(errorInfo.errorFields[0].name[0]);

      if (onFinishFailed) {
        onFinishFailed(errorInfo);
      }
    };

    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(RefForm, null, /*#__PURE__*/React__default.createElement(_List, {
      renderHeader: function renderHeader() {
        return /*#__PURE__*/React__default.createElement("div", {
          style: {
            textAlign: 'center',
            display: alitaDformExtraField.length > 0 ? 'block' : 'none'
          }
        }, "\u4EE5\u4E0B\u8868\u5355\u4E3A\u7F16\u8F91\u751F\u6210\uFF0C\u8BF7\u624B\u52A8\u4FDD\u5B58\u5230\u4EE3\u7801\u4E2D");
      }
    }, alitaDformExtraField.map(function (item) {
      return getFormItem$1(item, false);
    }))), /*#__PURE__*/React__default.createElement(_WingBlank, {
      size: "lg"
    }, /*#__PURE__*/React__default.createElement(_Button, {
      inline: true,
      type: "primary",
      onClick: function onClick() {
        return setModal(true);
      },
      style: {
        width: '50%'
      }
    }, "\u65B0\u589E\u8868\u5355"), /*#__PURE__*/React__default.createElement(_Button, {
      inline: true,
      type: "primary",
      onClick: function onClick() {
        return copyToClipboard(JSON.stringify(alitaDformExtraField));
      },
      style: {
        width: '50%'
      }
    }, "\u62F7\u8D1D\u914D\u7F6E")), /*#__PURE__*/React__default.createElement(_WhiteSpace, null), /*#__PURE__*/React__default.createElement(_Modal, {
      popup: true,
      visible: modal,
      onClose: function onClose() {
        return setModal(false);
      },
      animationType: "slide-up",
      style: {
        height: '12rem'
      }
    }, /*#__PURE__*/React__default.createElement(RefForm, {
      initialValues: InitFormValue,
      onFinish: onFinish,
      onFinishFailed: function onFinishFailed(errorInfo) {
        return defaultFailed(errorInfo);
      }
    }, /*#__PURE__*/React__default.createElement(_List, {
      renderHeader: function renderHeader() {
        return /*#__PURE__*/React__default.createElement("div", {
          style: {
            textAlign: 'center'
          }
        }, "\u9009\u62E9\u8868\u5355\u7C7B\u578B");
      },
      style: {
        textAlign: 'left'
      }
    }, InitFormData.map(function (item) {
      return /*#__PURE__*/React__default.createElement("div", {
        style: {
          position: 'relative'
        },
        key: item.fieldProps
      }, getFormItem$1(item, false), /*#__PURE__*/React__default.createElement("div", {
        style: {
          width: '100%',
          // height: '1.32rem',
          height: '100%',
          position: 'absolute',
          top: '0',
          left: '0',
          zIndex: 99
        },
        onClick: function onClick(e) {
          e.stopPropagation();
          setSelectFieldItem(_objectSpread2({}, item));
          setModal(false);
          setModal2(true);
        }
      }));
    }), /*#__PURE__*/React__default.createElement(_Button, {
      type: "primary",
      onClick: function onClick() {
        return setModal(false);
      }
    }, "\u53D6\u6D88")))), /*#__PURE__*/React__default.createElement(_Modal, {
      popup: true,
      visible: modal2,
      onClose: function onClose() {
        return setModal2(false);
      },
      animationType: "slide-up"
    }, /*#__PURE__*/React__default.createElement(_List, {
      renderHeader: function renderHeader() {
        return /*#__PURE__*/React__default.createElement("div", {
          style: {
            textAlign: 'center'
          }
        }, "\u7F16\u8F91\u8868\u5355\u6570\u636E");
      }
    }, /*#__PURE__*/React__default.createElement(EditForm, {
      data: selectFieldItem,
      onChange: onSelectFieldItem
    }))));
  };

  var FormItemType$1 = {
    input: NomarInput,
    select: NomarPicker,
    area: NomarTextArea,
    date: NomarDatePicker,
    switch: NomarSwitch,
    radio: NomarRadio,
    extraInput: ExtraInput,
    rangeDatePicker: RangeDatePicker,
    checkbox: NomarCheckBox,
    coverRadio: NomarTab,
    image: NomarImagePicker,
    custom: NomarCustom,
    multiplePicker: MultiplePicker,
    addressPicker: AddressPicker
  };
  var getFormItem$1 = function getFormItem(formItem, allDisabled) {
    var type = formItem.type,
        _formItem$disabled = formItem.disabled,
        disabled = _formItem$disabled === void 0 ? allDisabled : _formItem$disabled,
        otherProps = _objectWithoutProperties(formItem, ["type", "disabled"]);

    var FormItemComponent = FormItemType$1[formItem.type];
    return /*#__PURE__*/React__default.createElement(FormItemComponent, _extends({}, otherProps, {
      key: formItem.fieldProps,
      disabled: disabled
    }));
  };
  var defaultFailed$1 = function defaultFailed(errorInfo, onFinishFailed) {
    if (!errorInfo || !errorInfo.errorFields || errorInfo.errorFields.length === 0) {
      if (onFinishFailed) onFinishFailed(errorInfo);
      return;
    }

    var scrollToField = function scrollToField(fieldKey) {
      var labelNode = document.getElementById("aliat-dform-".concat(fieldKey));

      if (labelNode) {
        labelNode.scrollIntoView(true);
      }
    };

    scrollToField(errorInfo.errorFields[0].name[0]);
    if (onFinishFailed) onFinishFailed(errorInfo);
  };
  /**
   * 根据传进来的数据判断 DForm 的类型
   * @param data
   */

  var getDFormType = function getDFormType(data) {
    if (data instanceof Array) {
      var isTwoDimensional = false;
      var isCardListType = false;
      data.forEach(function (item) {
        if (item instanceof Array) {
          isTwoDimensional = true;
        } else {
          isCardListType = !item.fieldProps;
        }
      });

      if (isTwoDimensional) {
        return 'NORMALLIST';
      }

      return isCardListType ? 'CARDLIST' : 'NORMAL';
    }

    return 'CARD';
  };

  var changeData = function changeData(oldData, autoLineFeed) {
    return oldData.map(function (item) {
      if (item.positionType === 'vertical' || !autoLineFeed) return item;

      if (item.title) {
        var titleSize = getByteLen(item.title);

        if (titleSize >= 16) {
          item.positionType = 'vertical';
        } else if (item.type === 'input' || item.type === 'extraInput') {
          if (titleSize > 8) {
            item.labelNumber = titleSize / 2 + 1;
          } else {
            item.labelNumber = 5;
          }
        }
      }

      return item;
    });
  };

  var renderCardMain = function renderCardMain(formData, allDisabled, autoLineFeed) {
    var _ref = formData,
        data = _ref.data,
        otherData = _objectWithoutProperties(_ref, ["data"]);

    return /*#__PURE__*/React__default.createElement(_WingBlank, {
      size: "lg"
    }, /*#__PURE__*/React__default.createElement(_Card, {
      style: {
        paddingBottom: 0
      }
    }, /*#__PURE__*/React__default.createElement(_Card.Header, otherData), /*#__PURE__*/React__default.createElement(_List, null, changeData(data, autoLineFeed).map(function (item) {
      return getFormItem$1(item, allDisabled);
    }))));
  };

  var renderListMain = function renderListMain(formData, allDisabled, autoLineFeed) {
    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(_List, null, changeData(formData, autoLineFeed).map(function (item) {
      return getFormItem$1(item, allDisabled);
    })));
  };

  var renderMainList = function renderMainList(type, formData, allDisabled, autoLineFeed) {
    if (type === 'CARD') {
      return renderCardMain(formData, allDisabled, autoLineFeed);
    }

    if (type === 'CARDLIST') {
      return formData.map(function (item) {
        return renderCardMain(item, allDisabled, autoLineFeed);
      });
    }

    if (type === 'NORMALLIST') {
      return formData.map(function (item) {
        return renderListMain(item, allDisabled, autoLineFeed);
      });
    }

    return renderListMain(formData, allDisabled, autoLineFeed);
  };

  var DynamicForm = function DynamicForm(_ref2) {
    var children = _ref2.children,
        _ref2$data = _ref2.data,
        data = _ref2$data === void 0 ? [] : _ref2$data,
        form = _ref2.form,
        _ref2$allDisabled = _ref2.allDisabled,
        allDisabled = _ref2$allDisabled === void 0 ? false : _ref2$allDisabled,
        _ref2$formsValues = _ref2.formsValues,
        formsValues = _ref2$formsValues === void 0 ? {} : _ref2$formsValues,
        onFinish = _ref2.onFinish,
        _onFinishFailed = _ref2.onFinishFailed,
        onValuesChange = _ref2.onValuesChange,
        isDev = _ref2.isDev,
        _ref2$autoLineFeed = _ref2.autoLineFeed,
        autoLineFeed = _ref2$autoLineFeed === void 0 ? true : _ref2$autoLineFeed;
    React.useEffect(function () {
      form.setFieldsValue(formsValues);
    }, [formsValues]);
    var dFormType = getDFormType(data); // 开启条件是开发模式，并且data没有传，或者data传空数组[]

    var showAddItem = isDev ||  (!data || data instanceof Array && data.length === 0);
    var rederChildren = renderMainList(dFormType, data, allDisabled, autoLineFeed);
    return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement(RefForm, {
      form: form,
      initialValues: formsValues,
      onFinish: onFinish,
      onFinishFailed: function onFinishFailed(errorInfo) {
        return defaultFailed$1(errorInfo, _onFinishFailed);
      },
      onValuesChange: onValuesChange
    }, rederChildren, children), showAddItem && /*#__PURE__*/React__default.createElement(NewFieldPicker, null));
  };

  exports.AddressPicker = AddressPicker;
  exports.CoverRadio = NomarTab;
  exports.ExtraInput = ExtraInput;
  exports.Field = CustomField;
  exports.Form = RefForm;
  exports.InputItem = InputItem;
  exports.MultiplePicker = MultiplePicker;
  exports.NomarCheckBox = NomarCheckBox;
  exports.NomarCustom = NomarCustom;
  exports.NomarDatePicker = NomarDatePicker;
  exports.NomarImagePicker = NomarImagePicker;
  exports.NomarInput = NomarInput;
  exports.NomarPicker = NomarPicker;
  exports.NomarRadio = NomarRadio;
  exports.NomarSwitch = NomarSwitch;
  exports.NomarTextArea = NomarTextArea;
  exports.OnlyReadInput = OnlyReadInput;
  exports.RangeDatePicker = RangeDatePicker;
  exports.changeDateFormat = changeDateFormat;
  exports.dateChange = dateChange;
  exports.default = DynamicForm;
  exports.defaultFailed = defaultFailed$1;
  exports.getByteLen = getByteLen;
  exports.getDFormType = getDFormType;
  exports.getFormItem = getFormItem$1;
  exports.resetLabel = resetLabel;
  exports.useForm = useForm;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
