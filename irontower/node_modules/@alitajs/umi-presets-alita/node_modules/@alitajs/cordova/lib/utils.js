"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getIpAddress = getIpAddress;
exports.setCordovaConfig = setCordovaConfig;
exports.supportViewPortForAndroid = supportViewPortForAndroid;
exports.fixScrollIssueForIOS = fixScrollIssueForIOS;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = require("fs-extra");

  _fsExtra = function _fsExtra() {
    return data;
  };

  return data;
}

function _os() {
  const data = _interopRequireDefault(require("os"));

  _os = function _os() {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

function _cordovaCommon() {
  const data = require("cordova-common");

  _cordovaCommon = function _cordovaCommon() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getIpAddress() {
  const networkInterfaces = _os().default.networkInterfaces();

  let ipAddress = '127.0.0.1'; // eslint-disable-next-line no-restricted-syntax

  for (const key in networkInterfaces) {
    if (networkInterfaces.hasOwnProperty(key)) {
      const iface = networkInterfaces[key]; // eslint-disable-next-line no-plusplus

      for (let i = 0; i < iface.length; i++) {
        const alias = iface[i];

        if (alias.family === 'IPv4' && alias.address !== '127.0.0.1' && !alias.address.startsWith('169.254') && !alias.internal) {
          ipAddress = alias.address;
        }
      }
    }
  }

  return ipAddress;
}

function setCordovaConfig(path, isProduction) {
  const webPort = process.env.PORT || 8000;
  const ip = getIpAddress();
  const webUrl = !isProduction ? `http://${ip}:${webPort}` : 'index.html';
  const configPath = (0, _path().join)(path, 'config.xml');
  let content = (0, _fsExtra().readFileSync)(configPath).toString();
  const contentPattern = '<content (.*)src="[^"]*"(.*)/>';
  const contentRegex = new RegExp(contentPattern);
  content = content.replace(contentRegex, `<content $1src="${webUrl}"$2/>`);

  if (!isProduction) {
    const navPattern = '(<allow-navigation .*)href="[^"]*"(.*/>)';
    const navRegex = new RegExp(navPattern);

    if (navRegex.test(content)) {
      content = content.replace(navRegex, `$1href="${webUrl}"$2`);
    } else {
      const widgePattern = '</widget>';
      const widgeRegex = new RegExp(widgePattern);
      content = content.replace(widgeRegex, `\t<allow-navigation href="${webUrl}" />\n</widget>`);
    }
  }

  (0, _fsExtra().writeFileSync)(configPath, content);
} // android 支持 view port


function supportViewPortForAndroid(path) {
  const configPath = (0, _path().join)(path, 'config.xml');
  const config = new (_cordovaCommon().ConfigParser)(configPath);
  const packageName = config.packageName();
  const paths = packageName.split('.');
  const mainActivityPath = (0, _path().join)(path, 'platforms/android/app/src/main/java', ...paths, 'MainActivity.java');
  if (!(0, _fsExtra().existsSync)(mainActivityPath)) return;
  let content = (0, _fsExtra().readFileSync)(mainActivityPath).toString();

  if (!/WebView webView = \(WebView\)[\s]?this\.appView\.getView\(\);/.test(content)) {
    content = content.replace('loadUrl(launchUrl);', 'loadUrl(launchUrl);\n\t//下面能让 Android 设备支持 viewport\n\tWebView webView = (WebView) this.appView.getView();\n\twebView.getSettings().setLoadWithOverviewMode(true);\n\twebView.getSettings().setUseWideViewPort(true);');
    (0, _fsExtra().writeFileSync)(mainActivityPath, content);
  }

  if (!/import android.webkit.*;/.test(content)) {
    content = content.replace('import android.os.Bundle;', 'import android.os.Bundle;\nimport android.webkit.*;');
    (0, _fsExtra().writeFileSync)(mainActivityPath, content);
  }
} // 修复ios外层滚动


function fixScrollIssueForIOS(path) {
  const configPath = (0, _path().join)(path, 'config.xml');
  const config = new (_cordovaCommon().ConfigParser)(configPath);
  const appName = config.name();
  const mainViewControllerPath = (0, _path().join)(path, 'platforms/ios/', appName, 'Classes/MainViewController.m');
  if (!(0, _fsExtra().existsSync)(mainViewControllerPath)) return;
  let content = (0, _fsExtra().readFileSync)(mainViewControllerPath).toString();

  if (!/self\.webView\.scrollView\.bounces[\s]?=[\s]?NO;/.test(content)) {
    content = content.replace('[super viewDidLoad];', '[super viewDidLoad];\n\tself.webView.scrollView.bounces = NO;\n\tself.webView.scrollView.scrollEnabled = NO;');
    (0, _fsExtra().writeFileSync)(mainViewControllerPath, content);
  }
}