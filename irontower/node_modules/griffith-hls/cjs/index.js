'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var Hls = _interopDefault(require('hls.js/dist/hls.light.min'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function createMasterM3U8(list) {
  const result = [];
  result.push('#EXTM3U');
  list.forEach(item => {
    const meta = {
      'PROGRAM-ID': '1',
      BANDWIDTH: String(item.bandwidth)
    };

    if (item.resolution) {
      const {
        width,
        height
      } = item.resolution;
      meta.RESOLUTION = `${width}x${height}`;
    }

    result.push(`#EXT-X-STREAM-INF:${Object.entries(meta).map(([key, value]) => `${key}=${value}`).join(',')}`);
    result.push(item.source);
  });
  return result.join('\n');
}

var getMasterM3U8Blob = (sources => {
  const list = sources.map(item => ({
    source: item.source,
    bandwidth: item.bitrate * 1024,
    resolution: {
      width: item.width,
      height: item.height
    }
  }));
  return new Blob([createMasterM3U8(list)], {
    type: 'application/vnd.apple.mpegURL'
  });
});

class Video extends React.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "hasLoadStarted", false);
  }

  componentDidMount() {
    this.hls = new Hls({
      autoStartLoad: false
    });
    this.hls.attachMedia(this.video);
    const {
      sources
    } = this.props;
    const master = getMasterM3U8Blob(sources);
    this.src = URL.createObjectURL(master);
    this.hls.loadSource(this.src);
  }

  componentDidUpdate(prevProps) {
    const {
      currentQuality,
      sources,
      paused
    } = this.props;

    if (currentQuality !== prevProps.currentQuality) {
      const source = sources.find(source => source.quality === currentQuality);

      if (source) {
        const levels = this.hls.levels;
        const level = levels.findIndex(item => item.url.includes(source.source));
        this.hls.nextLevel = level;
      } else {
        this.hls.nextLevel = -1;
      }
    }

    if (!paused && prevProps.paused && !this.hasLoadStarted) {
      this.hls.startLoad();
      this.hasLoadStarted = true;
    }
  }

  componentWillUnmount() {
    this.hls.destroy();
    URL.revokeObjectURL(this.src);
  }

  render() {
    // eslint-disable-next-line no-unused-vars
    const {
      onRef,
      currentQuality,
      src,
      sources,
      paused,
      ...props
    } = this.props;
    return React__default.createElement("video", _extends({
      ref: el => {
        if (onRef) {
          onRef(el);
        }

        this.video = el;
      }
    }, props));
  }

}

var index = {
  pluginName: 'griffith-hls',
  VideoComponent: Video,
  willHandleSrcChange: true
};

module.exports = index;
//# sourceMappingURL=index.js.map
